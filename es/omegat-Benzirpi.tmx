<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx11.dtd">
<tmx version="1.1">
  <header
    creationtool="OmegaT"
    creationtoolversion="2.2.3_3"
    segtype="sentence"
    o-tmf="OmegaT TMX"
    adminlang="EN-US"
    srclang="EN"
    datatype="plaintext"
  >
  </header>
  <body>
    <tu>
      <tuv lang="EN">
        <seg>The subdirectory is named with the first 2 characters of the SHA, and the filename is the remaining 38 characters.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La subcarpeta se nombra con los primeros 2 caracteres del SHA, y el archivo con los restantes 38 caracteres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>A branch in Git is simply a lightweight movable pointer to one of these commits.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Una rama Git es simplemente un apuntador móvil apuntando a una de esas confirmaciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Setting Up a User Account ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Configurando una cuenta de usuario ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Once again, this changes the SHAs of all the commits in your list, so make sure no commit shows up in that list that you’ve already pushed to a shared repository.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T190510Z" changeid="juan">
        <seg>De nuevo, merece recalcar el hecho de que estas operaciones cambian los códigos SHA-1 de todas las confirmaciones de cambio afectadas. Y que, por tanto, no se deben hacer sobre confirmaciones de cambio enviadas(push) a algún repositorio compartido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>base_branch = ARGV[0]
	if ARGV[1]
	  topic_branch = ARGV[1]
	else
	  topic_branch = &quot;HEAD&quot;
	end</seg>
      </tuv>
      <tuv lang="ES">
        <seg>base_branch = ARGV[0]
	if ARGV[1]
	  topic_branch = ARGV[1]
	else
	  topic_branch = &quot;HEAD&quot;
	end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You’re taken to the Create a New Repository form (see Figure 4-5).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Irás al formulario de Crear un Nuevo Repositorio (ver Figura 4-5).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Then, run</seg>
      </tuv>
      <tuv lang="ES" changedate="20120728T090034Z" changeid="juan">
        <seg>Para luego lanzar</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>There, you can do a mixed reset of that commit with `git reset HEAD^`, which effectively undoes that commit and leaves the modified files unstaged.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T190334Z" changeid="juan">
        <seg>En esta línea de comando, es donde se desharan los cambios tecleando el comando `git reset HEAD^` para dejar sin preparar (unstaged) los archivos cambiados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git diff
	diff --git a/rack b/rack
	index 6c5e70b..08d709f 160000
	--- a/rack
	+++ b/rack
	@@ -1 +1 @@
	-Subproject commit 6c5e70b984a60b3cecd395edd5b48a7575bf58e0
	+Subproject commit 08d709f78b8c5b0fbeb7821e37fa53e69afcf433</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T110144Z" changeid="juan">
        <seg>$ git diff
	diff --git a/rack b/rack
	index 6c5e70b..08d709f 160000
	--- a/rack
	+++ b/rack
	@@ -1 +1 @@
	-Subproject commit 6c5e70b984a60b3cecd395edd5b48a7575bf58e0
	+Subproject commit 08d709f78b8c5b0fbeb7821e37fa53e69afcf433</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The pre hooks can exit non-zero at any time to reject the push as well as print an error message back to the client; you can set up a push policy that’s as complex as you wish.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El script previo, puede terminar con un código de salida distinto de cero y abortar el envio, devolviendo el correspondiente mensaje de error al cliente. Este script puede implementar políticas de recepción tan complejas como desees.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You have to unstage the `rack` directory first.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T135828Z" changeid="juan">
        <seg>Para evitarlo, se debe sacar la carpeta 'rack' del área de preparación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Basic sequence of this managed-team workflow.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Secuencia básica de este flujo de trabajo en equipo gestionado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can also pipe it through the `tail` command because you’re only interested in the last few largest files:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T135020Z" changeid="juan">
        <seg>Puedes también redirigir su salida a través del comando `tail`. Porque realmente solo nos interesan las últimas líneas, las correspondientes a los archivos más grandes. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Submodules allow you to keep a Git repository as a subdirectory of another Git repository.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T085029Z" changeid="juan">
        <seg>Los submódulos permiten mantener un repositorio Git como una subcarpeta de otro repositorio Git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When you’re thinking of integrating new work, it’s generally a good idea to try it out in a topic branch — a temporary branch specifically made to try out that new work.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cuando estás pensando en integrar nuevo trabajo, suele ser buena idea utilizar una rama puntual para cada tema concreto --una rama temporal creada específicamente para trabajar dicho tema--</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now, Git will use the KDiff3 tool for diff viewing and merge conflict resolution.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>A partir de ahora, Git utilizará la herramienta KDiff3 para mostrar y resolver conflictos de integración.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## Branch Management ##</seg>
      </tuv>
      <tuv lang="ES">
        <seg>## Gestión de ramificaciones ##</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>#</seg>
      </tuv>
      <tuv lang="ES" changedate="20120728T091349Z" changeid="juan">
        <seg>###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0504.png
Figure 5-4.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0504.png
Figura 5-4.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Jessica’s history after pushing all changes back to the server.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El historial de Jessica tras enviar de vuelta todos los cambios al servidor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git does this if you have too many loose objects around, if you run the `git gc` command manually, or if you push to a remote server.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T114012Z" changeid="juan">
        <seg>Esto sucede cada vez que tiene demasiados objetos en formato &quot;relajado&quot;; o cuando tu invocas manualmente al comando `git gc`; o justo antes de enviar cualquier cosa a un servidor remoto. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>git rev-list ^#{sha}^@ refs/remotes/#{remote_ref}</seg>
      </tuv>
      <tuv lang="ES">
        <seg>git rev-list ^#{sha}^@ refs/remotes/#{remote_ref}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>fetch = +refs/heads/qa*:refs/remotes/origin/qa*</seg>
      </tuv>
      <tuv lang="ES" changedate="20110815T221319Z" changeid="juan">
        <seg>fetch = +refs/heads/qa*:refs/remotes/origin/qa*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg># If this is not correct, please remove the file
	# .git/MERGE_HEAD
	# and try again.</seg>
      </tuv>
      <tuv lang="ES">
        <seg># If this is not correct, please remove the file
	# .git/MERGE_HEAD
	# and try again.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is useful if you have a number of commits on a topic branch and you want to integrate only one of them, or if you only have one commit on a topic branch and you’d prefer to cherry-pick it rather than run rebase.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puede ser util si tienes varias confirmaciones de cambios en una rama puntual, y tan solo deseas integar una de ellas; o si tienes una única confirmación de cambios en una rama puntual, y prefieres entresacarla en lugar de reorganizar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git merge-base contrib master
	36c7dba2c95e6bbb78dfa822519ecfec6e1ca649
	$ git diff 36c7db</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git merge-base contrib master
	36c7dba2c95e6bbb78dfa822519ecfec6e1ca649
	$ git diff 36c7db</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git apply --check 0001-seeing-if-this-helps-the-gem.patch
	error: patch failed: ticgit.gemspec:1
	error: ticgit.gemspec: patch does not apply</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git apply --check 0001-seeing-if-this-helps-the-gem.patch
	error: patch failed: ticgit.gemspec:1
	error: ticgit.gemspec: patch does not apply</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Because the repository is only used as a collaboration point, there is no reason to have a snapshot checked out on disk; it’s just the Git data.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Debido a que dicho repositorio se va a utilizar exclusivamente como un punto de colaboración, no tiene sentido el tener una instantánea de trabajo (snapshot) activa en el disco (checkout); nos basta con tener solamente los propios datos Git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In this next scenario, you’ll look at contributor roles in a larger private group.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En este próximo escenario, vamos a hechar un vistazo al rol de colaborador en un gran grupo privado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>?</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T214129Z" changeid="juan">
        <seg>?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ cat /tmp/id_rsa.john.pub
	ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCB007n/ww+ouN4gSLKssMxXnBOvf9LGt4L
	ojG6rs6hPB09j9R/T17/x4lhJA0F3FR1rP6kYBRsWj2aThGw6HXLm9/5zytK6Ztg3RPKK+4k
	Yjh6541NYsnEAZuXz0jTTyAUfrtU3Z5E003C4oxOj6H0rfIF1kKI9MAQLMdpGW1GYEIgS9Ez
	Sdfd8AcCIicTDWbqLAcU4UpkaX8KyGlLwsNuuGztobF8m72ALC/nLF6JLtPofwFBlgc+myiv
	O7TCUSBdLQlgMVOFq1I2uPWQOkOWQAHukEOmfjy2jctxSDBQ220ymjaNsHT4kgtZg2AYYgPq
	dAv8JggJICUvax2T9va5 gsg-keypair</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ cat /tmp/id_rsa.john.pub
	ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCB007n/ww+ouN4gSLKssMxXnBOvf9LGt4L
	ojG6rs6hPB09j9R/T17/x4lhJA0F3FR1rP6kYBRsWj2aThGw6HXLm9/5zytK6Ztg3RPKK+4k
	Yjh6541NYsnEAZuXz0jTTyAUfrtU3Z5E003C4oxOj6H0rfIF1kKI9MAQLMdpGW1GYEIgS9Ez
	Sdfd8AcCIicTDWbqLAcU4UpkaX8KyGlLwsNuuGztobF8m72ALC/nLF6JLtPofwFBlgc+myiv
	O7TCUSBdLQlgMVOFq1I2uPWQOkOWQAHukEOmfjy2jctxSDBQ220ymjaNsHT4kgtZg2AYYgPq
	dAv8JggJICUvax2T9va5 gsg-keypair</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It will also use these values to help you when you apply patches with `git apply`.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>También pueden ser útiles estos ajustes cuando estás incorporando parches con 'git apply'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Many times, when working with Git, you may want to revise your commit history for some reason.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120728T074804Z" changeid="juan">
        <seg>Por razones varias, hay ocasiones en que se desea revisar el historial de confirmaciones de cambio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>pick 310154e updated README formatting and added blame
	pick f7f3f6d changed my name a bit</seg>
      </tuv>
      <tuv lang="ES" changedate="20120728T091000Z" changeid="juan">
        <seg>pick 310154e updated README formatting and added blame
	pick f7f3f6d changed my name a bit</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Does it even have a policy?</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Es más, ¿tiene un sistema para ello?.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Pushing ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Publicando ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It’s also important to mention that this isn’t necessarily the fastest option if you’re using a shared mount of some kind.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cabe destacar también que una carpeta compartida no es precisamente la opción más rápida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is the beginning of the output of the format-patch command that you saw in the previous section.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto es el comienzo de la salida del comando format-patch visto en la sección anterior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To see reflog information formatted like the `git log` output, you can run `git log -g`:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T191053Z" changeid="juan">
        <seg>Si se desea ver la información del registro de referencia, formateada de forma similar a la salida del comando 'git log', se puede lanzar el comando 'git log -g':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When you have work in a topic branch and have determined that you want to integrate it, you move to that branch and run the rebase command to rebuild the changes on top of your current master (or `develop`, and so on) branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cuando desees integrar el trabajo que tienes en una rama puntual, te puedes situar sobre ella y lanzar el comando 'rebase'; de esta forma recompondrás los cambios encima de tu actual rama 'master' (o 'develop' o lo que corresponda).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$regex = /\[ref: (\d+)\]/</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$regex = /\[ref: (\d+)\]/$regex = /\[ref: (\d+)\]/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ cat 0001-add-limit-to-log-function.patch
	From 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001
	From: Jessica Smith &lt;jessica@example.com&gt;
	Date: Sun, 6 Apr 2008 10:17:23 -0700
	Subject: [PATCH 1/2] add limit to log function</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ cat 0001-add-limit-to-log-function.patch
	From 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001
	From: Jessica Smith &lt;jessica@example.com&gt;
	Date: Sun, 6 Apr 2008 10:17:23 -0700
	Subject: [PATCH 1/2] add limit to log function</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg># This is a combination of 3 commits.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120728T092008Z" changeid="juan">
        <seg># This is a combination of 3 commits.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>At the bottom, you should find a line that looks something like this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Localizar, al fondo, una línea parecida a:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You get a reference to teamone’s master branch position locally.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Obtienes una referencia local a la posición en la rama 'master' de 'teamone'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is something you’ve likely never done with a VCS before because it’s generally too expensive to create and merge branches.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Es algo que nunca habrías hecho en otro sistema VCS, debido a los altos costos de crear y fusionar ramas que se suelen dar en esos sistemas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can run `git status` again to verify that all conflicts have been resolved:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En cualquier momento, puedes lanzar el comando 'git status' para ver si ya has resuelto todos los conflictos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Instead of forking the project and pushing to your own writable version, you generate e-mail versions of each commit series and e-mail them to the developer mailing list:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En lugar de bifurcar (fork) el proyecto y enviar a tu propia copia editable, generarás correos electrónicos para cada serie de parches y os enviarás a la lista de correo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you do have that commit — if the patch was based on a public commit — then the `-3` option is generally much smarter about applying a conflicting patch:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Sin embargo, si tienes dicha confirmación de cambios (commit), --si el parche está basado en una confirmación pública--, entonces la opción '-3' suele ser mucho más avispada cuando incorporas un parche conflictivo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The client-side hooks are for client operations such as committing and merging.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Los puntos del lado cliente están relacionados con operaciones tales como la confirmación de cambios (commit) o la fusión (merge).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>y</seg>
      </tuv>
      <tuv lang="ES">
        <seg>y</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>However, there is another way: you can take the patch of the change that was introduced in C3 and reapply it on top of C4.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Aunque también hay otra forma de hacerlo: puedes coger los cambios introducidos en C3 y reaplicarlos encima de C4.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>However, it can be very useful.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T190825Z" changeid="juan">
        <seg>De todas formas, allá donde sea aplicable, puede ser de gran utilidad.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When you restart your machine, your Git daemon will start automatically and respawn if it goes down.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tras reiniciar tu máquina, el demonio Git arrancará automáticamente y se reiniciará cuando se caiga.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This rewrites your history to now look like Figure 5-17.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto reescribe tu historial, quedando como se vé en la Figura 5-17.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This also refers to the first parent, so `HEAD~` and `HEAD^` are equivalent.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T114503Z" changeid="juan">
        <seg>Utilizada tal cual, también se refiere al padre. Por lo tanto, `HEAD~` y `HEAD^` son equivalentes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you already have a shared filesystem to which your whole team has access, setting up a repository is very easy.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si tienes un sistema de archivo compartido que todo el equipo pueda usar, preparar un repositorio es muy sencillo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>However, if someone at any point in the history of your project added a single huge file, every clone for all time will be forced to download that large file, even if it was removed from the project in the very next commit.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T134247Z" changeid="juan">
        <seg>Pero, si alguien, en cualquier momento de tu proyecto, ha añadido un solo archivo enorme. A partir de ese momento, todos los clones, siempre, se verán obligados a copiar ese enorme archivo. Incluso si ya ha sido borrado del proyecto en la siguiente confirmación de cambios realizada inmediatamente tras la que lo añadió.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You fetch them and merge the new remote branch into your work, making your history look something like Figure 3-37.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tu te traes (fetch) sus trabajos y los fusionas (merge) sobre una nueva rama en tu trabajo. Quedando tu registro de confirmaciones como en la Figura 3-37.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>#### Making a Subdirectory the New Root ####</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T192136Z" changeid="juan">
        <seg>#### Haciendo que una subcarpeta sea la nueva carpeta raiz ####</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now you’re ready to collaborate on the same project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Ahora ya estás preparado para trabajar con ellos en el proyecto común.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Single commit repository data.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Datos en el repositorio tras una confirmación sencilla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>First you run `git bisect start` to get things going, and then you use `git bisect bad` to tell the system that the current commit you’re on is broken.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T165655Z" changeid="juan">
        <seg>Primero se lanza el comando `git bisect start` para iniciar el proceso de búsqueda. Luego, con el comando `git bisect bad`, se le indica al sistema cual es la confirmación de cambios a partir de donde se han detectado los problemas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The other thing `gc` will do is pack up your references into a single file.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T132729Z" changeid="juan">
        <seg>Otra tarea realizada por `gc` es el empaquetar referencias en un solo archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This lets the user with that key modify the main Git repository that controls the Gitosis setup.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto habilita al usuario con dicha clave pública para que pueda modificar el repositorio principal de Git, y, con ello, pueda controlar la instalación de Gitosis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It’s worth noting here that the work you did in your `hotfix` branch is not contained in the files in your `iss53` branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cabe indicar que todo el trabajo realizado en la rama 'hotfix' no está en los archivos de la rama 'iss53'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Next, John e-mails Jessica to say he’s pushed some changes to the `featureA` branch and ask her to verify them.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>A continuación, John envia un correo-e a jessica comentandole que ha enviado algunos cambios a la rama 'featureA' y pidiendole que los verifique.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If that script is in place (in `.git/hooks/commit-msg`) and executable, and you commit with a message that isn’t properly formatted, you see this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si este script está en su sitio (el archivo '.git/hooks/commit-msg') y es ejecutable, al confirmar cambios con un mensaje inapropiado, verás algo asi como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>However, you should be aware of how ridiculously unlikely this scenario is.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120712T195523Z" changeid="juan">
        <seg>No obstante, hemos de ser conscientes de lo altamente improbable de un suceso así.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>#### The Pros ####</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Ventajas ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>./gitosis.conf
	./keydir
	./keydir/scott.pub</seg>
      </tuv>
      <tuv lang="ES">
        <seg>./gitosis.conf
	./keydir
	./keydir/scott.pub</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Or you can use the shorter scp-like syntax for SSH protocol:

	$ git clone user@server:project.git</seg>
      </tuv>
      <tuv lang="ES">
        <seg>O puedes prescindir del protocolo; Git asume SSH si no indicas nada expresamente: $ git clone user@server:project.git</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>They will be told that they’re trying to push non-fast-forward changes and that they won’t be able to do so until they fetch and merge.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El sistema le avisará de que está intentando enviar (push) cambios no directos (non-fast-forward changes), y de que no podrá hacerlo hasta que recupere (fetch) y fusione (merge) los cambios preexistentes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>After it’s tested, merge the hotfix branch, and push to production.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tras las pertinentes pruebas, fusionas (merge) esa rama y la envias (push) a la rama de producción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Public Small Project ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Pequeño Proyecto Público ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>No `-w` option is needed — calling `write-tree` automatically creates a tree object from the state of the index if that tree doesn’t yet exist:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T144503Z" changeid="juan">
        <seg>Sin necesidad de la opción `-w`, solo llamando al comando `write-tree`, y si dicho árbol no existiera ya, se crea automáticamente un objeto tipo árbol a partir del estado del índice.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>def blame(path)
	Stage this hunk [y,n,a,d,/,j,J,g,e,?]?</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T214047Z" changeid="juan">
        <seg>def blame(path)
	Stage this hunk [y,n,a,d,/,j,J,g,e,?]?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When that is set up, you can use `git send-email` to place the patch series in the Drafts folder of the specified IMAP server:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cuando tengas esto ajustado, podrás utilizar el comando `git send-email` para poner series de parches en la carpeta de borradores (Drafts) de tu servidor IMAP:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you were working on an issue with a partner and they pushed up an `iss53` branch, you might have your own local `iss53` branch; but the branch on the server would point to the commit at `origin/iss53`.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>O si estás trabajando en un problema con un compañero y este envia (push) una rama 'iss53', tu tendrás tu propia rama de trabajo local 'iss53'; pero la rama en el servidor apuntará a la última confirmación (commit) en la rama 'origin/iss53'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It will start at the commit you specify on the command line (`HEAD~3`) and replay the changes introduced in each of these commits from top to bottom.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120728T085535Z" changeid="juan">
        <seg>Un script que, comenzando por la confirmación de cambios indicada en la línea del comando (`HEAD~3`), va a reaplicar los cambios introducidos en cada una de las confirmaciones, desde arriba hasta abajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You also have access to the user doing the pushing if the push is being run over SSH.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>También puedes tener acceso al usuario que está enviando, si este los envia a través de SSH.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0511.png
Figure 5-11.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0511.png
Figura 5-11.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>2^80 is 1.2 x 10^24 or 1 million billion billion.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T095229Z" changeid="juan">
        <seg>2^80 es 1'2 x 10^24, o lo que es lo mismo, 1 billón de billones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Staging the file marks it as resolved in Git.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Marcar archivos como preparados (staging), indica a Git que sus conflictos han sido resueltos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This can involve changing the order of the commits, changing messages or modifying files in a commit, squashing together or splitting apart commits, or removing commits entirely — all before you share your work with others.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T121613Z" changeid="juan">
        <seg>Así, es posible cambiar el orden de las confirmaciones, cambiar sus mensajes, modificar los archivos comprendidos en ellas, juntar varias confirmaciones en una sola, partir una en varias,o incluso borrar alguna completamente. --Aunque todo ello es siempre recomendable hacerlo solo antes de compartir nuestro trabajo con otros.--</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0315.png
Figure 3-15.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0315.png
Figura 3-15.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now, when you run git archive to create a tarball of your project, that directory won’t be included in the archive.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>A partir de ese momento, cada vez que lances el comando 'git archive' para crear un archivo comprimido de tu proyecto, esa carpeta no se incluirá en él.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>One caveat is that it expects you to be running locally as the same user you push as to the remote machine.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Es necesario advertir de que se espera que trabajes localmente con el mismo usuario con el que enviarás (push) a la máquina remota.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The Wiki tab provides a wiki where you can write documentation or other information about your project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La pestaña &quot;Wiki&quot; enlaza con un espacio wiki donde puedes escribir documentación o cualquier otra información relevante sobre tu proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you have an existing public Subversion project that you want to import into Git, GitHub can often do that for you.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si tienes un proyecto público Subversion que deseas pasar a Git, GitHub suele poder realizar la importación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The other files are your new packfile and an index.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110815T211657Z" changeid="juan">
        <seg>Los otros archivos presentes son el nuevo archivo empaquetador y un índice.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You merge in the same work again into a new merge commit.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Vuelves a fusionar el mismo trabajo en una nueva fusión confirmada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you need to revoke access to individuals, you can click the &quot;revoke&quot; link, and their push access will be removed.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si deseas revocar el acceso a alguno de ellos, puedes clicar sobre el enlace &quot;revoke&quot;, y sus permisos de envio (push) serán revocados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>All of these fields are delimited by a pipe (`|`) character.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cada uno de esos campos se separan entre sí con el caracter barra vertical ('|').</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git cat-file -p master^{tree}
	100644 blob a906cb2a4a904a152e80877d4088654daad0c859      README
	100644 blob 8f94139338f9404f26296befa88755fc2598c289      Rakefile
	040000 tree 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0      lib</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T180254Z" changeid="juan">
        <seg>$ git cat-file -p master^{tree}
	100644 blob a906cb2a4a904a152e80877d4088654daad0c859      README
	100644 blob 8f94139338f9404f26296befa88755fc2598c289      Rakefile
	040000 tree 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0      lib</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can see Chapter 9 for more information about plumbing tools; basically, `rev-parse` exists for lower-level operations and isn’t designed to be used in day-to-day operations.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120712T195810Z" changeid="juan">
        <seg>En el capítulo 9 se verá más información sobre las herramientas de fontaneria. Herramientas estas que son utilizadas para operaciones a muy bajo nivel, y que no estan pensadas para ser utilizadas en el trabajo habitual del día a día.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git branch testing</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git branch testing</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0401.png
Figure 4-1.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0401.png
Figura 4-1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Changing Multiple Commit Messages ###</seg>
      </tuv>
      <tuv lang="ES" changedate="20120728T090628Z" changeid="juan">
        <seg>### Modificar múltiples confirmaciones de cambios ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Preparing a Release ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Preparando un lanzamiento de versión ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git stash list
	stash@{0}: WIP on master: 049d078 added the index file
	stash@{1}: WIP on master: c264051...</seg>
      </tuv>
      <tuv lang="ES" changedate="20120712T205951Z" changeid="juan">
        <seg>$ git stash list
	stash@{0}: WIP on master: 049d078 added the index file
	stash@{1}: WIP on master: c264051...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This section outlines the various ways you can refer to a single commit.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T184233Z" changeid="juan">
        <seg>En esta sección se verán las diversas formas existentes para referirse a una determinada confirmación de cambios (commit).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git log experiment..master
	F
	E</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T120643Z" changeid="juan">
        <seg>$ git log experiment..master
	F
	E</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It lists the changes you’ve staged on the left and unstaged changes on the right.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T091941Z" changeid="juan">
        <seg>Se ve una lista de cambios ya preparados, en la izquierda; y de los que están aún sin preparar, en la derecha.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git transport over HTTP is often referred to as the dumb protocol because it requires no Git-specific code on the server side during the transport process.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T130312Z" changeid="juan">
        <seg>El transporte de Git sobre protocolo HTTP es conocido también como protocolo tonto. Porque no requiere ningún tipo de codigo Git en la parte servidor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>One Rubyism that may not be clear is `path.index(access_path) == 0`, which is true if path begins with `access_path` — this ensures that `access_path` is not just in one of the allowed paths, but an allowed path begins with each accessed path.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Un &quot;rubysmo&quot; que posiblemente sea un tanto oscuro puede ser 'path.index(access_path) == 0' . Simplemente devuelve verdadero en el caso de que la ubicacion comience por 'access_path' ; de esta forma, nos aseguramos de que 'access_path' no esté solo contenido en una de las ubicaciones permitidas, sino sea una ubicación permitida la que comience con la ubicación accedida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is shorthand for:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto es un atajo a:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>[remote &quot;origin&quot;]
	       url = git@github.com:schacon/simplegit-progit.git
	       fetch = +refs/heads/*:refs/remotes/origin/*</seg>
      </tuv>
      <tuv lang="ES" changedate="20110815T215503Z" changeid="juan">
        <seg>[remote &quot;origin&quot;]
	       url = git@github.com:schacon/simplegit-progit.git
	       fetch = +refs/heads/*:refs/remotes/origin/*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg># enforces fast-forward only pushes
	def check_fast_forward
	  missed_refs = `git rev-list #{$newrev}..#{$oldrev}`
	  missed_ref_count = missed_refs.split(&quot;\n&quot;).size
	  if missed_ref_count &gt; 0
	    puts &quot;[POLICY] Cannot push a non fast-forward reference&quot;
	    exit 1
	  end
	end</seg>
      </tuv>
      <tuv lang="ES">
        <seg># enforces fast-forward only pushes
	def check_fast_forward
	  missed_refs = `git rev-list #{$newrev}..#{$oldrev}`
	  missed_ref_count = missed_refs.split(&quot;\n&quot;).size
	  if missed_ref_count &gt; 0
	    puts &quot;[POLICY] Cannot push a non fast-forward reference&quot;
	    exit 1
	  end
	end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You get an object back — that object is in loose format on the server, and you fetched it over a static HTTP GET request.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T130812Z" changeid="juan">
        <seg>Cuando recuperas un objeto, dicho objeto se encuentra suelto (loose) en el servidor y lo traes mediante una petición estática HTTP GET.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>remote: Compressing objects: 100% (1465/1465), done.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T142014Z" changeid="juan">
        <seg>remote: Compressing objects: 100% (1465/1465), done.remote: Compressing objects: 100% (1465/1465), done.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ echo '*.txt ident' &gt;&gt; .gitattributes
	$ echo '$Id$' &gt; test.txt</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ echo '*.txt ident' &gt;&gt; .gitattributes
	$ echo '$Id$' &gt; test.txt</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For instance, if you want the iphone project to show up on GitWeb, you make the `repo` setting look like this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por ejemplo, si quieres mostrar el proyecto iphone, has de poner algo así como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Creating a New Repository ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Creando un nuevo repositorio ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Typing `?` shows a list of what you can do:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T214124Z" changeid="juan">
        <seg>Tecleando '?' se muestra una lista de las mismas:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you want to allow anonymous read-only access to your projects, you’ll have to set up SSH for you to push over but something else for others to pull over.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Pero si quieres también habilitar accesos anónimos de solo lectura, tendrás que reservar SSH para tus envios (push) y habilitar algún otro protocolo para las recuperaciones (pull) de los demás.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When you save and exit the editor, Git applies all three changes and then puts you back into the editor to merge the three commit messages:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120728T092006Z" changeid="juan">
        <seg>Cuando se guarde y salga en el editor, Git rebobinará la historia, reaplicará las tres confirmaciones de cambio, y volverá al editor para fusionar también los mensajes de esas tres confirmaciones. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Doing so will allow pushes from their public keys to work.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>De esta forma, funcionarán los envios (push) desde sus respectivas claves públicas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you set `help.autocorrect` to 1, Git will automatically run the command if it has only one match under this scenario.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si ajustas 'help.autocorrect' a 1, Git lanzará automáticamente el comando corregido, (pero solo cuando haya únicamente uno que pueda encajar).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Total 21 (delta 3), reused 15 (delta 1)</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T104827Z" changeid="juan">
        <seg>Total 21 (delta 3), reused 15 (delta 1)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$user    = ENV['USER']</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$user    = ENV['USER']</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Finally, you went back to your server branch and did a few more commits.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por último, vuelves sobre la rama 'server' y haces algunos cambios más.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Instead of &quot;I added tests for&quot; or &quot;Adding tests for,&quot; use &quot;Add tests for.&quot;
Here is a template originally written by Tim Pope at tpope.net:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por ejemplo, en vez de escribir &quot;He añadido comprobaciones para&quot; o &quot;Añadiendo comprobaciones para&quot;, utilizar la frase &quot;Añadir comprobaciones para&quot;. Como plantilla de referencia, podemos utilizar la que escribió Tim Pope en tpope.net:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Some files look like text files but for all intents and purposes are to be treated as binary data.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Algunos archivos aparentan ser textuales, pero a efectos prácticos merece más la pena tratarlos como binarios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>A shell?</seg>
      </tuv>
      <tuv lang="ES">
        <seg>A shell?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The first variable is active contributor size.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La primera variable es el número de colaboradores activos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When you want to share a branch with the world, you need to push it up to a remote that you have write access to.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cuando quieres compartir una rama con el resto del mundo, has de llevarla (push) a un remoto donde tengas permisos de escritura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0334.png
Figure 3-34.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0334.png
Figura 3-34.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Note that the snapshot pointed to by the final commit you end up with, whether it’s the last of the rebased commits for a rebase or the final merge commit after a merge, is the same snapshot — it’s only the history that is different.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cabe destacar que la instantánea (snapshot) apuntada por la confirmación (commit) final, tanto si es producto de una regorganización (rebase) como si lo es de una fusión (merge), es exactamente la misma instantánea. Lo único diferente es el registro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>What does this `post-update` hook do?</seg>
      </tuv>
      <tuv lang="ES">
        <seg>¿Que hace este anclaje 'post-update'?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>She hasn’t fetched John’s changes yet, so her commit history looks like Figure 5-7.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Como todavia no ha recuperado los cambios de John, su historial es como se muestra en la Figura 5-7.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>#### core.excludesfile ####</seg>
      </tuv>
      <tuv lang="ES">
        <seg>#### core.excludesfile ####</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Your history no longer contains a reference to that file.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T134442Z" changeid="juan">
        <seg>Tras esto, el historial ya no contiene ninguna referencia a ese archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When other users visit this project page, they won’t see that URL—only the public one.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cuando otros usuarios visiten la página del proyecto, no verán esta segunda URL --solo verán la URL pública--.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>remote: Compressing objects: 100% (14/14), done.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>remote: Compressing objects: 100% (14/14), done.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You should now be able to make Git fit nearly any workflow you can dream up.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>A partir de ahora estás listo para encajar Git en prácticamente cualquier flujo de trabajo que puedas imaginar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>No problems occur; as you can see it, was a simple fast-forward.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>No hay ningún problema; como puedes observar, es un simple avance rápido (fast-forward).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Running `git show HEAD@{2.months.ago}` will work only if you cloned the project at least two months ago — if you cloned it five minutes ago, you’ll get no results.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120712T200255Z" changeid="juan">
        <seg>Así, un comando tal como `git show HEAD@{2.months.ago}` solo será válido en caso de haber clonado el proyecto como mínimo dos meses antes. Si se acaba de clonar hace cinco minutos, ese comando dará un resultado vacio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>+ XXXXXXXXXXX
	lib/simplegit.rb:26: trailing whitespace.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>+ XXXXXXXXXXX
	lib/simplegit.rb:26: trailing whitespace.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Another cool thing about Git is that it doesn’t track file renames explicitly.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T074127Z" changeid="juan">
        <seg>Otro aspecto interesante de Git es la ausencia de un seguimiento explícito de archivos renombrados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>There are a lot of great things about Git, but one feature that can cause issues is the fact that a `git clone` downloads the entire history of the project, including every version of every file.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T134130Z" changeid="juan">
        <seg>Git tiene grandes cosas. Pero el hecho de que un  `git clone` siempre descarge la historia completa del proyecto (incluyendo todas y cada una de las versiones de todos y cada uno de los archivos). Puede casusar problemas. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0306.png
Figure 3-6.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0306.png
Figura 3-6.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>*** Commands ***
	  1: status     2: update      3: revert     4: add untracked
	  5: patch      6: diff        7: quit       8: help
	What now&gt; 3
	           staged     unstaged path
	  1:        +0/-1      nothing TODO
	  2:        +1/-1      nothing index.html
	  3:    unchanged        +5/-1 lib/simplegit.rb
	Revert&gt;&gt; 1
	           staged     unstaged path
	* 1:        +0/-1      nothing TODO
	  2:        +1/-1      nothing index.html
	  3:    unchanged        +5/-1 lib/simplegit.rb
	Revert&gt;&gt; [enter]
	reverted one path</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T212959Z" changeid="juan">
        <seg>*** Commands ***
	  1: status     2: update      3: revert     4: add untracked
	  5: patch      6: diff        7: quit       8: help
	What now&gt; 3
	           staged     unstaged path
	  1:        +0/-1      nothing TODO
	  2:        +1/-1      nothing index.html
	  3:    unchanged        +5/-1 lib/simplegit.rb
	Revert&gt;&gt; 1
	           staged     unstaged path
	* 1:        +0/-1      nothing TODO
	  2:        +1/-1      nothing index.html
	  3:    unchanged        +5/-1 lib/simplegit.rb
	Revert&gt;&gt; [enter]
	reverted one path</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>TODO |    1 +
	 1 files changed, 1 insertions(+), 0 deletions(-)</seg>
      </tuv>
      <tuv lang="ES">
        <seg>TODO |    1 +
	 1 files changed, 1 insertions(+), 0 deletions(-)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You accomplish that by using refspecs to push.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110817T153709Z" changeid="juan">
        <seg>Pues utilizando las referencias (refspecs) para enviar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Here we’ll discuss what they are and in what basic circumstances you would want (or not want) to use them.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Vamos a ver en qué consisten y las circunstancias en que querrás (o no) utilizar cada uno de ellos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git cat-file blob junio-gpg-pub</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T234815Z" changeid="juan">
        <seg>$ git cat-file blob junio-gpg-pub</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you want to allow Git protocol access for your iphone project, you add this to the end of the `gitosis.conf` file:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por ejemplo, si quieres permitir acceso a tu 'proyecto iphone', puedes añadir lo siguiente al archivo 'gitosis.conf':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can see your reflog by using `git reflog`:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120712T200007Z" changeid="juan">
        <seg>Este registro de referencia se puede consultar con el comando 'git reflog':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you want to remove all accidentally committed editor backup files, you can run something like `git filter-branch --tree-filter 'rm -f *~' HEAD`.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T191909Z" changeid="juan">
        <seg>Otro ejemplo: si se desean eliminar todos los archivos de respaldo del editor que han sido almacenados por error, se podría lanzar algo así como  `git filter-branch --tree-filter 'rm -f *~' HEAD`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>That’s all.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y eso es todo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The two that are turned on by default are `trailing-space`, which looks for spaces at the end of a line, and `space-before-tab`, which looks for spaces before tabs at the beginning of a line.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Los dos activos por defecto son 'trailing-space' (espaciado de relleno), que vigila por si hay espacios al final de las líneas, y 'space-before-tab' (espaciado delante de un tabulador), que mira por si hay espacios al principio de las lineas o por delante de los tabuladores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now you can see how Git has stored your data:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T143102Z" changeid="juan">
        <seg>En estos momentos, ya puedes comprobar la forma en que Git ha guardado tus datos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you try to switch back to a branch where those files are still in the actual tree rather than a submodule — you get this error:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T172830Z" changeid="juan">
        <seg>Si se intenta retornar a dicha rama, cuyos archivos están aún en el árbol actual en lugar de en el submódulo, se obtendrá el siguiente error:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When you run `git submodule update`, it checks out the specific version of the project, but not within a branch.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T133235Z" changeid="juan">
        <seg>Al lanzar `git submodule update`, este comando comprueba la versión específica del proyecto, pero sin tener en cuenta la rama.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ echo 'version 2' &gt; test.txt
	$ git hash-object -w test.txt
	1f7a7a472abf3dd9643fd615f6da379c4acb3e3a</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ echo 'version 2' &gt; test.txt
	$ git hash-object -w test.txt
	1f7a7a472abf3dd9643fd615f6da379c4acb3e3a</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You merged in what is basically a change to the pointer for your submodule; but it doesn’t update the code in the submodule directory, so it looks like you have a dirty state in your working directory:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T171653Z" changeid="juan">
        <seg>Se ha fusionado en algo que es básicamente un cambio en el puntero al submódulo. Pero no se ha actualizado el código en la carpeta del submódulo propiamente dicha. Por lo que se muestra un estado inconsistente en la misma:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Here you can run `rev-parse` on your branch.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T085555Z" changeid="juan">
        <seg>Por ejemplo, lanzando el comando 'rev-parse' sobre una rama, esta muestra el código SHA-1 de la última confirmación de cambios en ella:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>After a topic branch release.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tras un lanzamiento puntual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0409.png
Figure 4-9.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0409.png
Figura 4-9.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To create a branch back at the second commit, you can do this:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T191420Z" changeid="juan">
        <seg>Para crear una rama hacia la segunda confirmación de cambios, puedes hacer:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Feel free to give out that URL and post it on your web site or what have you.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes comunicar libremente ese URL o puedes publicarlo en tu sitio web o en cualquier otro médio que desees.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git clone http://git.gitserver/project.git</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git clone http://git.gitserver/project.git</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>#### Double Dot ####</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T115602Z" changeid="juan">
        <seg>#### Doble punto ####</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This happens because Git directly compares the snapshots of the last commit of the topic branch you’re on and the snapshot of the last commit on the `master` branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Debido a que Git compara directamente las instantáneas de la última confirmación de cambios en la rama puntual donde te encuentras y en la rama 'master'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You use this command to artificially add the earlier version of the test.txt file to a new staging area.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T194207Z" changeid="juan">
        <seg>Este comando se utiliza para añadir artificialmente la versión anterior del archivo test.txt. a una nueva área de preparación </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git remote add origin git@github.com:testinguser/iphone_project.git
	$ git push origin master</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git remote add origin git@github.com:testinguser/iphone_project.git
	$ git push origin master</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>All the lieutenants have one integration manager known as the benevolent dictator.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Todos los tenientes rinden cuentas a un gestor de integración; conocido como el dictador benevolente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This file is written by the `update-server-info` command, which is why you need to enable that as a `post-receive` hook in order for the HTTP transport to work properly:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T130520Z" changeid="juan">
        <seg>Este es un archivo escrito por el comando `update-server-info`, el que has de habilitar como enganche (hook)  `post-receive` para permitir funcionar correctamente al transporte HTTP: </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git applies the last commit (`a5f4a0d`) in the script, and your history looks like this:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120728T093710Z" changeid="juan">
        <seg>Tras esto, Git reaplicará la última de las confirmaciones de cambios  (`a5f4a0d`) en el script. Quedando la historia: </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It’s important to note that with the exception of the HTTP protocols, all of these require Git to be installed and working on the server.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Merece destacar que, con la excepción del protocolo HTTP, todos los demás protocolos requieren que Git esté instalado y operativo en el servidor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ cat ~/.ssh/id_rsa.pub
	ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAklOUpkDHrfHY17SbrmTIpNLTGK9Tjom/BWDSU
	GPl+nafzlHDTYW7hdI4yZ5ew18JH4JW9jbhUFrviQzM7xlELEVf4h9lFX5QVkbPppSwg0cda3
	Pbv7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8V6RjsNAQwdsdMFvSlVK/7XA
	t3FaoJoAsncM1Q9x5+3V0Ww68/eIFmb1zuUFljQJKprrX88XypNDvjYNby6vw/Pb0rwert/En
	mZ+AW4OZPnTPI89ZPmVMLuayrD2cE86Z/il8b+gw3r3+1nKatmIkjn2so1d01QraTlMqVSsbx
	NrRFi9wrf+M7Q== schacon@agadorlaptop.local</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ cat ~/.ssh/id_rsa.pub
	ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAklOUpkDHrfHY17SbrmTIpNLTGK9Tjom/BWDSU
	GPl+nafzlHDTYW7hdI4yZ5ew18JH4JW9jbhUFrviQzM7xlELEVf4h9lFX5QVkbPppSwg0cda3
	Pbv7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8V6RjsNAQwdsdMFvSlVK/7XA
	t3FaoJoAsncM1Q9x5+3V0Ww68/eIFmb1zuUFljQJKprrX88XypNDvjYNby6vw/Pb0rwert/En
	mZ+AW4OZPnTPI89ZPmVMLuayrD2cE86Z/il8b+gw3r3+1nKatmIkjn2so1d01QraTlMqVSsbx
	NrRFi9wrf+M7Q== schacon@agadorlaptop.local</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ echo 'second commit' | git commit-tree 0155eb -p fdf4fc3
	cac0cab538b970a37ea1e769cbbde608743bc96d
	$ echo 'third commit'  | git commit-tree 3c4e9c -p cac0cab
	1a410efbd13591db07496601ebc7a059dd55cfe9</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T180351Z" changeid="juan">
        <seg>$ echo 'second commit' | git commit-tree 0155eb -p fdf4fc3
	cac0cab538b970a37ea1e769cbbde608743bc96d
	$ echo 'third commit'  | git commit-tree 3c4e9c -p cac0cab
	1a410efbd13591db07496601ebc7a059dd55cfe9</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>bak/test.txt |    1 +
	 1 files changed, 1 insertions(+), 0 deletions(-)</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T180403Z" changeid="juan">
        <seg>bak/test.txt |    1 +
	 1 files changed, 1 insertions(+), 0 deletions(-)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It’s worth pointing out that Git determines the best common ancestor to use for its merge base; this is different than CVS or Subversion (before version 1.5), where the developer doing the merge has to figure out the best merge base for themselves.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Merece la pena destacar el hecho de que es el propio Git quien determina automáticamente el mejor ancestro común para realizar la fusión. Diferenciandose de otros sistemas tales como CVS o Subversion, donde es el desarrollador quien ha de imaginarse cuál puede ser dicho mejor ancestro común.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The `--squash` option takes all the work on the merged branch and squashes it into one non-merge commit on top of the branch you’re on.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La opción '--squash' coge todo el trabajo en la rama fusionada y lo aplica, en una sola confirmación de cambios sin fusión (no-merge commit), sobre la rama en la que estés situado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To create a new reference that will help you remember where your latest commit is, you can technically do something as simple as this:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T191012Z" changeid="juan">
        <seg>Para crear una nueva referencia que te sirva de ayuda para recordar cual es tu última confirmación de cambios,  puedes realizar técnicamente algo tan simple como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git checkout -b sc/ruby_client master</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git checkout -b sc/ruby_client master</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git clone http://example.com/gitproject.git</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git clone http://example.com/gitproject.git</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ mv /home/git/.ssh/authorized_keys /home/git/.ssh/ak.bak</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ mv /home/git/.ssh/authorized_keys /home/git/.ssh/ak.bak</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git config --global color.diff.meta “blue black bold”</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git config --global color.diff.meta “blue black bold”</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### RefLog Shortnames ###</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T101638Z" changeid="juan">
        <seg>### Nombres cortos en RefLog ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>=&gt; GET objects/cf/da3bf379e4f8dba8717dee55aab78aef7f4daf
	(404 - Not Found)</seg>
      </tuv>
      <tuv lang="ES" changedate="20110817T223228Z" changeid="juan">
        <seg>=&gt; GET objects/cf/da3bf379e4f8dba8717dee55aab78aef7f4daf
	(404 - Not Found)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You go back to your code, and it turns out you can reproduce the issue, but you can’t figure out what is going wrong.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T074726Z" changeid="juan">
        <seg>Si, volviendo atras, resulta que se consigue reproducir el problema, pero cuesta identificar su causa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The master branch is that of the dictator.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La rama master es la del dictador benevolente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>[repo iphone_project]
	daemon = yes
	gitweb = yes</seg>
      </tuv>
      <tuv lang="ES">
        <seg>[repo iphone_project]
	daemon = yes
	gitweb = yes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The output from the command is a 40-character checksum hash.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La salida del comando es una suma de comprobación (checksum hash) de 40 caracteres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is a tad confusing, because now you’ve seen at least three different ways that Git uses the `^` to modify a commit SHA, but that is what it means here.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120827T144754Z" changeid="juan">
        <seg>Puede ser un poco confuso, debido a que la marca `^` se utiliza también con otros significados diferentes dentro de Git. Pero este es el sentido en que se utiliza aquí: para señalar la confirmación de cambios original. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Splitting a Commit ###</seg>
      </tuv>
      <tuv lang="ES" changedate="20120728T092251Z" changeid="juan">
        <seg>### Dividir una confirmación de cambios en varias ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can download P4Merge here:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>P4Merge se puede descargar desde:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In fact, we used GitHub to privately collaborate on this book.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>De hecho, nosotros utilizamos también GitHub para colaborar privadamente en este libro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>#### Enforcing a Specific Commit-Message Format ####</seg>
      </tuv>
      <tuv lang="ES">
        <seg>#### Obligando a utilizar un formato específico en el mensaje de confirmación de cambios ####</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>1c002dd...</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T102023Z" changeid="juan">
        <seg>1c002dd...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>or the second version:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>o a su segunda versión</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Grab the tree object:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110817T223226Z" changeid="juan">
        <seg>Y el árbol de contenido: </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git branch sc/ruby_client master</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git branch sc/ruby_client master</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git branch -d testing
	error: The branch 'testing' is not an ancestor of your current HEAD.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git branch -d testing
	error: The branch 'testing' is not an ancestor of your current HEAD.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git remote add origin git@gitserver:iphone_project.git
	$ git push origin master
	Initialized empty Git repository in /opt/git/iphone_project.git/
	Counting objects: 3, done.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git remote add origin git@gitserver:iphone_project.git
	$ git push origin master
	Initialized empty Git repository in /opt/git/iphone_project.git/
	Counting objects: 3, done.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Formatting and Whitespace ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Formato y espacios en blanco ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git figured out that about 12 commits came between the commit you marked as the last good commit (v1.0) and the current bad version, and it checked out the middle one for you.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T165724Z" changeid="juan">
        <seg>Git averigua que se han dado 12 confirmaciones de cambio entre la confirmación marcada como buena y la marcada como mala.  Y extrae la confirmación central de la serie, para comenzar las comprobaciones a partir de ahí.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### The Basic Rebase ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Reorganización básica ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>One of the things Git does in the background while you’re working away is keep a reflog — a log of where your HEAD and branch references have been for the last few months.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120712T195946Z" changeid="juan">
        <seg>Una de las tareas realizadas por Git continuamente en segundo plano, mientras nosotros trabajamos, es el mantenimiento de un registro de referencia (reflog). En este registro queda traza de dónde han estado las referencias a HEAD y a las distintas ramas durante los últimos meses.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>All you really have to do is provide a project name, but you can also add a description.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Es suficiente con dar un nombre al proyecto, pero también puedes añadirle una descripción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Superprojects ###</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T132250Z" changeid="juan">
        <seg>### Proyectos padre ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you want your own `serverfix` branch that you can work on, you can base it off your remote branch:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y si quieres tener tu propia rama 'serverfix', donde puedas trabajar, puedes crearla directamente basandote en rama remota:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is a nice shortcut to recover stashed work easily and work on it in a new branch.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T094715Z" changeid="juan">
        <seg>Este es un buen atajo para recuperar con facilidad un cierto trabajo desde la pila y continuar con él en una nueva rama.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Applying Patches from E-mail ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Aplicar parches recibidos por correo-e ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Let’s get rid of it.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T105237Z" changeid="juan">
        <seg>Para arreglar la situación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Then, when the codebase on that branch is stable and passes tests, you merge it into a develop branch; and when that has proven itself stable for a while, you fast-forward your master branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>A continuación, cuando el código en dicha rama sea estable y pase todas las pruebas, la fusionarás con la rama 'develop'; y, cuando se demuestre que permanece estable durante un cierto tiempo, avanzarás la rama 'master' hasta ahí.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg># Jessica's Machine
	$ git fetch origin
	...
	From jessica@githost:simplegit
	   fbff5bc..72bbc59  master     -&gt; origin/master</seg>
      </tuv>
      <tuv lang="ES">
        <seg># Jessica's Machine
	$ git fetch origin
	...
	From jessica@githost:simplegit
	   fbff5bc..72bbc59  master     -&gt; origin/master</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you need to pull it in, you can merge your `master` branch into your `iss53` branch by running `git merge master`, or you can wait to integrate those changes until you decide to pull the `iss53` branch back into `master` later.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si fuera necesario agregarlos, puedes fusionar (merge) la rama 'master' sobre la rama 'iss53' utilizando el comando 'git merge master'. O puedes esperar hasta que decidas llevar (pull) la rama 'iss53' a la rama 'master'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The files end up looking like this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Los archivos serán algo como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Even if you don’t commit during the weekend, use the staging area on Monday to split your work into at least one commit per issue, with a useful message per commit.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Aunque no hagas ninguna confirmación durante el fin de semana, el lunes puedes utilizar el área de preparación (staging area) para ir dividiendo tu trabajo y hacer una confirmación de cambios (commit) separada para cada asunto; con un mensaje adecuado para cada una de ellas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The next line starts with 003e, which is 62, so you read the remaining 62 bytes.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T074107Z" changeid="juan">
        <seg>La siguiente línea comienza con 003e, 62 en decimal, por lo que has de leer otros 62 bytes hasta el final de la linea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Each line starts with a 4-byte hex value specifying how long the rest of the line is.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T073943Z" changeid="juan">
        <seg>Cada linea comienza con un valor de 4 bytes, en hexadecimal, indicando la longitud del resto de la linea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Keyword Expansion ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Expansión de palabras clave ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The project snapshot at the tip of the branch is identical whether you do one commit or five, as long as all the changes are added at some point, so try to make things easier on your fellow developers when they have to review your changes.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El estado del proyecto al final de cada rama será idéntico si haces una sola confirmación o si haces cinco, en tanto en cuanto todos los cambios estén confirmados en un determinado momento. Por consiguiente, intenta facilitar las cosas a tus compañeros y compañeras desarroladores cuando vayan a revisar tus cambios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You’ll now look at each of these sections in detail to see how Git operates.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Vamos a mirar en detalle cada una de esas secciones, para ver cómo trabaja Git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The other main way to specify a commit is via its ancestry.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T113642Z" changeid="juan">
        <seg>Otra forma de especificar una confirmación de cambios es utilizando sus ancestros.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The reason is that if the work isn’t accepted or is cherry picked, you don’t have to rewind your master branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y la razón para ello es que, si el trabajo no es aceptado o se integra solo parcialmente, no tendrás que rebobinar tu rama principal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Otherwise, it will start from the beginning and will unnecessarily take longer.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T134422Z" changeid="juan">
        <seg>De otro modo, el comando comenzaria desde el principio, asumiendo un proceso inecesariamente más largo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For example, if you want to submit a second topic of work to the project, don’t continue working on the topic branch you just pushed up — start over from the main repository’s `master` branch:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por ejemplo, si deseas contribuir al proyecto en un segundo tema, no continues trabajando sobre la rama puntual que acabas de enviar; comienza una nueva rama puntual desde la rama 'master' del repositorio principal: </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This may mean moving in large binary files that you don’t want source controlled, auto-generating documentation, or something along those lines.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Entre otras cosas, puedes mover grandes archivos binarios de los que no quieras llevar control, puedes autogenerar documentación,.... </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>They aren’t necessarily obvious but are helpful to know.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T184055Z" changeid="juan">
        <seg>Algunos de estos modos no son precisamente obvios, pero conviene conocerlos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git automatically colors most of its output if you ask it to.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si se lo pides, Git coloreará automáticamente la mayor parte de los resultados que muestre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is just the default refspec for `git fetch` for that remote.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110815T220800Z" changeid="juan">
        <seg>Quedando así esta referencia como la referencia por defecto para el comando `git fetch` para ese remoto. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>What if you want anonymous read access to your project?</seg>
      </tuv>
      <tuv lang="ES">
        <seg>¿Qué hacer si necesitas acceso anónimo de lectura a tu proyecto?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If another developer makes changes to the rack code and commits, and you pull that reference down and merge it in, you get something a bit odd:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T171628Z" changeid="juan">
        <seg>Si otra persona realiza cambios en el código de `rack`, los confirma y nosotros recuperamos (pull) dicha referencia y la fusionamos (merge), se obtendrá un resultado un tanto extraño:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It turns out that it can.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110810T230914Z" changeid="juan">
        <seg>Pues bien, Git lo puede hacer.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Cloning a Project with Submodules ###</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T105507Z" changeid="juan">
        <seg>### Clonando un proyecto con submódulos ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg># see if anyone is trying to push something they can't
	  new_commits = `git rev-list #{$oldrev}..#{$newrev}`.split(&quot;\n&quot;)
	  new_commits.each do |rev|
	    files_modified = `git log -1 --name-only --pretty=format:'' #{rev}`.split(&quot;\n&quot;)
	    files_modified.each do |path|
	      next if path.size == 0
	      has_file_access = false
	      access[$user].each do |access_path|
	        if !access_path || # user has access to everything
	          (path.index(access_path) == 0) # access to this path
	          has_file_access = true
	        end
	      end
	      if !has_file_access
	        puts &quot;[POLICY] You do not have access to push to #{path}&quot;
	        exit 1
	      end
	    end
	  end
	end</seg>
      </tuv>
      <tuv lang="ES">
        <seg># see if anyone is trying to push something they can't
	  new_commits = `git rev-list #{$oldrev}..#{$newrev}`.split(&quot;\n&quot;)
	  new_commits.each do |rev|
	    files_modified = `git log -1 --name-only --pretty=format:'' #{rev}`.split(&quot;\n&quot;)
	    files_modified.each do |path|
	      next if path.size == 0
	      has_file_access = false
	      access[$user].each do |access_path|
	        if !access_path || # user has access to everything
	          (path.index(access_path) == 0) # access to this path
	          has_file_access = true
	        end
	      end
	      if !has_file_access
	        puts &quot;[POLICY] You do not have access to push to #{path}&quot;
	        exit 1
	      end
	    end
	  end
	end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now, modify that file a little, and see what happens:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110810T230421Z" changeid="juan">
        <seg>Ahora, modifica un poco dicho archivo y comprueba lo que sucede:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can set it up by setting the filter attribute in your `.gitattributes` file to filter `*.c` files with the &quot;indent&quot; filter:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes hacerlo poniendo los atributos adecuados en tu archivo '.gitattributes', para filtrar los archivos '*.c' a través de &quot;indent&quot;:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0305.png
Figure 3-5.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0305.png
Figura 3-5.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It’s nice that you can fetch namespaced references that way, but how does the QA team get their branches into a `qa/` namespace in the first place?</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T125923Z" changeid="juan">
        <seg>Es util poder recuperar (fetch) referencias relativas en espacios de nombres, tal y como hemos visto. Pero, ¿cómo pueden enviar (push) sus ramas al espacio de nombres `qa/` los miembros de equipo QA ?. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git merge origin/master
	Merge made by recursive.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git merge origin/master
	Merge made by recursive.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When you save and exit the editor, Git rewinds to the parent of the first commit in your list, applies the first commit (`f7f3f6d`), applies the second (`310154e`), and drops you to the console.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120728T093212Z" changeid="juan">
        <seg>Al guardar y salir en el editor, Git rebobinará la historia hasta el padre de la primera confirmación de cambios en la lista, reaplicará esa primera confirmación  (`f7f3f6d`), luego reaplicará la segunda (`310154e`) y luego devolverá la línea de comandos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This takes a number of custom settings: `merge.tool` to tell Git what strategy to use, `mergetool.*.cmd` to specify how to run the command, `mergetool.trustExitCode` to tell Git if the exit code of that program indicates a successful merge resolution or not, and `diff.external` to tell Git what command to run for diffs.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tenemos varios parámetros a ajustar: 'merge.tool' para indicar a Git la estrategia que ha de usar, 'mergetool.*.cmd' para especificar como lanzar el comando, 'mergetool.trustExitCode' para decir a Git si el código de salida del programa indica una fusión con éxito o no, y 'diff.external' para decir a Git qué comando lanzar para realizar comparaciones. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It moved the HEAD pointer back to point to the master branch, and it reverted the files in your working directory back to the snapshot that master points to.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110801T122504Z" changeid="juan">
        <seg>Mueve el apuntador HEAD de nuevo a la rama 'master', y revierte los archivos de tu carpeta de trabajo; dejandolos tal y como estaban en la última instantánea confirmada en dicha rama 'master'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Private Small Team ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Pequeño Grupo Privado ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg># The first commit's message is:
	changed my name a bit</seg>
      </tuv>
      <tuv lang="ES" changedate="20120728T092010Z" changeid="juan">
        <seg># The first commit's message is:
	changed my name a bit</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Again, GitWeb can be served with any CGI capable web server; if you prefer to use something else, it shouldn’t be difficult to set up.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Recordar una vez más que GitWeb puede servirse desde cualquier servidor web con capacidades CGI. Por lo que si prefieres utilizar algún otro, no debería ser dificil de configurarlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The logic for checking this is to see if any commits are reachable from the older revision that aren’t reachable from the newer one.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La lógica para hacer así la comprobación es la de mirar por si alguna confirmación de cambios se puede alcanzar desde la versión más antigua pero no desde la más reciente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The reflog is also updated by the `git update-ref` command, which is another reason to use it instead of just writing the SHA value to your ref files, as we covered in the &quot;Git References&quot; section of this chapter earlier.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T133310Z" changeid="juan">
        <seg>El registro reflog se actualiza incluso cuando utilizas el comando `git update-ref`. Siendo esta otra de las razones por las que es recomendable utilizar ese comando en lugar de escribir manualmente los valores SHA en los archivos de referencia, tal y como hemos visto anteriormente en la sección &quot;Referencias Git&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>However, keep in mind that to collaborate with a couple of people on a private project, all you _need_ is an SSH server and a bare repository.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Pero, ten presente que para colaborar con un pequeño grupo de personas en un proyecto privado, todo lo que necesitas es un servidor SSH y un repositorio básico.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## Maintenance and Data Recovery ##</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T090641Z" changeid="juan">
        <seg>## Mantenimiento y recuperación de datos ##</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can bisect the code to find out.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T165541Z" changeid="juan">
        <seg>Se puede ir biseccionando el código para intentar localizar el punto del historial desde donde se presenta el problema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Total 17 (delta 1), reused 10 (delta 0)</seg>
      </tuv>
      <tuv lang="ES" changedate="20110810T231551Z" changeid="juan">
        <seg>Total 17 (delta 1), reused 10 (delta 0)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### The Dumb Protocol ###</seg>
      </tuv>
      <tuv lang="ES" changedate="20110817T155249Z" changeid="juan">
        <seg>### El protocolo tonto (dumb) ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Tracking Branches ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Haciendo seguimiento a las ramas ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>By now, you’ve learned most of the day-to-day commands and workflows that you need to manage or maintain a Git repository for your source code control.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T084825Z" changeid="juan">
        <seg>A estas alturas, hemos aprendido la mayoria de los comandos y flujos de trabajo empleados habitualmente a la hora de utilizar, gestionar y mantener un repositorio Git para el control de versiones de código fuente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## ¿Qué es una rama?</seg>
      </tuv>
      <tuv lang="ES">
        <seg>## ¿Qué es una rama?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Switched to a new branch &quot;rack_branch&quot;</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T142029Z" changeid="juan">
        <seg>Switched to a new branch &quot;rack_branch&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git rebase --onto master server client</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git rebase --onto master server client</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>A good way to do this in Git is to make each of the subfolders a separate Git repository and then create superproject Git repositories that contain multiple submodules.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T132750Z" changeid="juan">
        <seg>La manera más apropiada de hacer esto en Git, es la de crear diferentes repositorios, cada uno en su carpeta; para luego crear un repositorio padre que englobe múltiples submódulos, uno por cada carpeta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The idea is that your branches are at various levels of stability; when they reach a more stable level, they’re merged into the branch above them.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La idea es mantener siempre diversas ramas en diversos grados de estabilidad; pero cuando alguna alcanza un estado más estable, la fusionamos con la rama inmediatamente superior a ella.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Although Git has an internal implementation of diff, which is what you’ve been using, you can set up an external tool instead.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Aunque Git lleva una implementación interna de diff, la que se utiliza habitualmente, se puede sustituir por una herramienta externa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If it sees one that is reachable from one of your remote references, it aborts the rebase:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si encuentra alguna, aborta la reorganización:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Finally, you ask `filter-branch` to rewrite your history only from the `6df7640` commit up, because you know that is where this problem started.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T134335Z" changeid="juan">
        <seg>Y por último, se indica a `filter-branch` que reescriba la historia a partir de la confirmación de cambios `6df7640`, porque ya conocemos que es a partir de ahí donde comenzaba el problema. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>At this point, John’s local repository looks something like Figure 5-4.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En este punto, el repositorio local de John será algo parecido a la Figura 5-4.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Rebasing replays changes from one line of work onto another in the order they were introduced, whereas merging takes the endpoints and merges them together.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La reorganización vuelve a aplicar cambios de una rama de trabajo sobre otra rama, en el mismo orden en que fueron introducidos en la primera. Mientras que la fusión combina entre sí los dos puntos finales de ambas ramas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This means the tag directly above is an annotated tag and that line is the commit that the annotated tag points to.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T093058Z" changeid="juan">
        <seg>Esto nos indica que la etiqueta inmediatamente anterior es una etiqueta anotada y que esa línea es la confirmación de cambios a la que apunta dicha etiqueta anotada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0336.png
Figure 3-36.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0336.png
Figura 3-36.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>All they have to do is copy the contents of the `.pub` file and e-mail it.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto se puede realizar simplemente copiando los contenidos del archivo terminado en '.pub' y enviandoselos por correo electrónico.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>http://www.perforce.com/product/components/perforce-visual-merge-and-diff-tools</seg>
      </tuv>
      <tuv lang="ES">
        <seg>http://www.perforce.com/product/components/perforce-visual-merge-and-diff-tools</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git show HEAD~3
	commit 1c3618887afb5fbcbea25b7c013f4e2114448b8d
	Author: Tom Preston-Werner &lt;tom@mojombo.com&gt;
	Date:   Fri Nov 7 13:47:59 2008 -0500</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T114623Z" changeid="juan">
        <seg>$ git show HEAD~3
	commit 1c3618887afb5fbcbea25b7c013f4e2114448b8d
	Author: Tom Preston-Werner &lt;tom@mojombo.com&gt;
	Date:   Fri Nov 7 13:47:59 2008 -0500</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is a very common workflow with sites like GitHub, where it’s easy to fork a project and push your changes into your fork for everyone to see.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esta es una forma de trabajo muy común en sitios tales como GitHub, donde es sencillo bifurcar (fork) un proyecto y enviar tus cambios a tu copia, donde cualquiera puede verlos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To do so, change the word pick to the word edit for each of the commits you want the script to stop after.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T185518Z" changeid="juan">
        <seg>Y se ha de cambiar la palabra 'pick' por la palabra 'edit' en cada una de las confirmaciones de cambio donde se desee detener el script.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The Network tab shows all the people who have forked your project and contributed back.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La pestaña &quot;Network&quot; muestra una lista de toda la gente que ha bifurcado (forked) tu proyecto y ha contribuido a él.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It’s important to note that this is literally all you need to do to run a useful Git server to which several people have access — just add SSH-able accounts on a server, and stick a bare repository somewhere that all those users have read and write access to.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Es importante destacar que esto es, literalmente, todo lo necesario para preparar un servidor Git compartido. Habilitar unas cuantas cuentas SSH en un servidor; colocar un repositorio básico en algún lugar donde esos usuarios tengan acceso de lectura/escritura;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Checking Out Remote Branches ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Recuperando ramas remotas ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you have any issues, it may be useful to add `loglevel=DEBUG` under the `[gitosis]` section.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si tienes problemas, puede ser util añadir `loglevel=DEBUG` en la sección `[gitosis]`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ rm -Rf rack/
	$ git submodule add git@github.com:schacon/rack.git rack
	'rack' already exists in the index</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T135754Z" changeid="juan">
        <seg>$ rm -Rf rack/
	$ git submodule add git@github.com:schacon/rack.git rack
	'rack' already exists in the index</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>These are the core parts of Git.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T142539Z" changeid="juan">
        <seg>Estos elementos forman el núcleo de Git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You should only have to use `git apply` for legacy patches and things like that.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Solo deberías utilizar 'git apply' en caso de parches antiguos y similares.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git cat-file commit ca82a6 | sed '1,/^$/d'
	changed the version number</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git cat-file commit ca82a6 | sed '1,/^$/d'
	changed the version number</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You do this with the `git branch` command:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Usarás el comando 'git branch':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Next, Gitosis wants to put its repositories under `/home/git`, which is fine.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Gitosis intentará instalar sus repositorios bajo la carpeta '/home/git', lo cual está bien.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can also use this string as the target of a checkout or show command, although it relies on the abbreviated SHA-1 value at the end, so it may not be valid forever.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tambien puedes utilizar esta descripción para indicar lo que deseas activar (checkout) o mostrar (show); pero realmente estarás usando solamente la parte final de la firma SHA-1 abreviada, por lo que no siempre será válida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ ssh git@gitserver
	PTY allocation request failed on channel 0
	fatal: unrecognized command 'gitosis-serve schacon@quaternion'
	  Connection to gitserver closed.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ ssh git@gitserver
	PTY allocation request failed on channel 0
	fatal: unrecognized command 'gitosis-serve schacon@quaternion'
	  Connection to gitserver closed.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git push origin serverfix
	Counting objects: 20, done.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git push origin serverfix
	Counting objects: 20, done.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Next, you’ll see how to work the other side of the coin: maintaining a Git project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>A continuación veremos cómo trabajar en el otro lado de la moneda: manteniendo y gestionando un proyecto Git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>#### core.whitespace ####</seg>
      </tuv>
      <tuv lang="ES">
        <seg>#### core.whitespace ####</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Suppose you add a remote like this:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110815T215312Z" changeid="juan">
        <seg>Supón que añades un remoto tal que:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can do that in Git with `git read-tree`.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T142254Z" changeid="juan">
        <seg>Se ha de lanzar el comando `git read-tree`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>With these basic commands, you can use the interactive add mode to deal with your staging area a little more easily.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120712T201633Z" changeid="juan">
        <seg>Con estos comandos básicos, se ha visto cómo se puede emplear el modo interactivo para interactuar de forma más sencilla con el área de preparación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git branch -d iss53</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git branch -d iss53</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The last thing you have to do is check that you’re not trying to push non-fast-forwarded references, but that is a bit less common.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El último aspecto a comprobar es el de no intentar enviar referencias que no sean de avance-rápido. Pero esto es algo más raro que suceda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you didn’t want it to be called `serverfix` on the remote, you could instead run `git push origin serverfix:awesomebranch` to push your local `serverfix` branch to the `awesomebranch` branch on the remote project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si no quieres que se llame 'serverfix' en el remoto, puedes lanzar, por ejemplo, 'git push origin serverfix:awesomebranch'; para llevar tu rama 'serverfix' local a la rama 'awesomebranch' en el proyecto remoto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Normally, you get as the original commit the commit where you copied the code over, because that is the first time you touched those lines in this file.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T165317Z" changeid="juan">
        <seg>Habitualmente suele mostrarse como confirmación de cambios original aquella confirmación de cambios desde la que se copió el código. Por ser esa la primera ocasión en que se han modificado las líneas en ese archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can also specify multiple refspecs.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T115446Z" changeid="juan">
        <seg>Puedes incluso indicar multiples referencias en un solo comando.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0408.png
Figure 4-8.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0408.png
Figura 4-8.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>La forma en la que Git maneja las ramificaciones es increíblemente rápida, haciendo así de las operaciones de ramificación algo casi instantáneo, al igual que el avance o el retroceso entre distintas ramas, lo cual también es tremendamente rápido.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La forma en la que Git maneja las ramificaciones es increíblemente rápida, haciendo así de las operaciones de ramificación algo casi instantáneo, al igual que el avance o el retroceso entre distintas ramas, lo cual también es tremendamente rápido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Rebasing the change introduced in C3 onto C4.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Reorganizando sobre C4 los cambios introducidos en C3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is also a valid mbox e-mail format.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Es también un formato válido para un mbox.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git am 0001-limit-log-function.patch
	Applying: add limit to log function</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git am 0001-limit-log-function.patch
	Applying: add limit to log function</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now you have two commits that you want to send to the mailing list.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tienes dos confirmaciones de cambios (commits) a enviar a la lista de correo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This setup should leave you with CRLF endings in Windows checkouts but LF endings on Mac and Linux systems and in the repository.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Este ajuste dejará los finales de línea CRLF en las extraciones de código (checkout), pero los finales LF en sistemas Mac o Linux y en el repositorio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Then, you can see what the `master` branch on the `origin` remote was the last time you communicated with the server, by checking the `refs/remotes/origin/master` file:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110810T225112Z" changeid="juan">
        <seg>Tras lo cual puedes confirmar cual era la rama `master` en el remoto `origin` la última vez que comunicase con el servidor. Comprobando el archivo `refs/remotes/origin/master`: </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Your object is there, so go ahead and get the whole packfile:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110817T224648Z" changeid="juan">
        <seg>Una vez comprobada la presencia del objeto, adelante con la recuperación de todo el archivo empaquetado:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## Plumbing and Porcelain ##</seg>
      </tuv>
      <tuv lang="ES">
        <seg>## Fontaneria y porcelana ##</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is most useful if you’re working with a person consistently.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Es muy util cuando trabajas regularmente con una persona.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ echo 'Last commit date: $Format:%cd$' &gt; LAST_COMMIT
	$ echo &quot;LAST_COMMIT export-subst&quot; &gt;&gt; .gitattributes
	$ git add LAST_COMMIT .gitattributes
	$ git commit -am 'adding LAST_COMMIT file for archives'</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ echo 'Last commit date: $Format:%cd$' &gt; LAST_COMMIT
	$ echo &quot;LAST_COMMIT export-subst&quot; &gt;&gt; .gitattributes
	$ git add LAST_COMMIT .gitattributes
	$ git commit -am 'adding LAST_COMMIT file for archives'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Cool — now you have a branch named `recover-branch` that is where your `master` branch used to be, making the first two commits reachable again.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T133450Z" changeid="juan">
        <seg>¡Bravo!, acabas de añadir una rama denominada `recover-branch` al punto donde estaba originalmente tu rama `master`; permitiendo así recuperar el acceso a las dos primeras confirmaciones de cambios. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>=&gt; GET objects/pack/pack-816a9b2334da9953e530f27bcac22082a9f5b835.idx
	(4k of binary data)</seg>
      </tuv>
      <tuv lang="ES" changedate="20110817T224201Z" changeid="juan">
        <seg>=&gt; GET objects/pack/pack-816a9b2334da9953e530f27bcac22082a9f5b835.idx
	(4k of binary data)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The first thing you should do is clone the external repository into your subdirectory.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T103243Z" changeid="juan">
        <seg>La primera tarea a realizar es clonar el repositorio externo dento de una subcarpeta dentro del proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This does a one-time pull and doesn’t save the URL as a remote reference:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto efectua una recuperación (pull) puntual y no conserva la URL como una referencia remota:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ cat /tmp/id_rsa.john.pub &gt;&gt; ~/.ssh/authorized_keys
	$ cat /tmp/id_rsa.josie.pub &gt;&gt; ~/.ssh/authorized_keys
	$ cat /tmp/id_rsa.jessica.pub &gt;&gt; ~/.ssh/authorized_keys</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ cat /tmp/id_rsa.john.pub &gt;&gt; ~/.ssh/authorized_keys
	$ cat /tmp/id_rsa.josie.pub &gt;&gt; ~/.ssh/authorized_keys
	$ cat /tmp/id_rsa.jessica.pub &gt;&gt; ~/.ssh/authorized_keys</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now, the snapshot pointed to by C3 is exactly the same as the one that was pointed to by C5 in the merge example.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Así, la instantánea apuntada por C3 aquí es exactamente la misma apuntada por C5 en el ejemplo de la fusión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Update&gt;&gt; 1,2
	           staged     unstaged path
	* 1:    unchanged        +0/-1 TODO
	* 2:    unchanged        +1/-1 index.html
	  3:    unchanged        +5/-1 lib/simplegit.rb
	Update&gt;&gt;</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T212549Z" changeid="juan">
        <seg>Update&gt;&gt; 1,2
	           staged     unstaged path
	* 1:    unchanged        +0/-1 TODO
	* 2:    unchanged        +1/-1 index.html
	  3:    unchanged        +5/-1 lib/simplegit.rb
	Update&gt;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The downside of serving your repository over HTTP is that it’s relatively inefficient for the client.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La pega de servir un repositorio a través de HTTP es su relativa ineficiencia para el cliente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>We’ll quickly go over how that is done.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Vamos a ver cómo hacerlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>I mentioned earlier that a header is stored with the content.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T145636Z" changeid="juan">
        <seg>He citado anteriormente que siempre se almacena una cabecera  junto al contenido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The next section deals with projects that prefer to accept contributed patches via e-mail.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En la siguiente sección, veremos el caso de los proyectos que prefieren aceptar contribuciones a través del correo electrónico.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It’s used to inspect the snapshot that’s about to be committed, to see if you’ve forgotten something, to make sure tests run, or to examine whatever you need to inspect in the code.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Se suele utilizar para inspeccionar la instantánea (snapshot) que vas a confirmar, para ver si has olvidado algo, para asegurar que las pruebas se ejecutan, o para revisar cualquier aspecto que necesites inspeccionar en el codigo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Lastly, you have this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y, por último, se ve:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>They can add your repository as a remote, test your changes locally, merge them into their branch, and push back to their repository.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Ella podrá añadir tu repositorio como un remoto, chequear tus cambios localmente, fusionarlos (merge) con su rama y enviarlos (push) de vuelta a su repositorio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>By symbolic reference, I mean that unlike a normal reference, it doesn’t generally contain a SHA-1 value but rather a pointer to another reference.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T111416Z" changeid="juan">
        <seg>Por referencia simbólica me refiero a que, a diferencia de una referencia normal, esta contiene un enlace a otra referencia en lugar de un valor SHA-1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The main Source tab that you land on shows your project’s main directory listing and automatically renders the README file below it if you have one.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La pestaña principal &quot;Source&quot; en la que aterrizas cuando llegas al proyecto, muestra un listado de la carpeta principal; y muestra también el contenido del archivo README, si tienes uno en ella.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can also do this with content in files.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110717T113637Z" changeid="juan">
        <seg>Lo puedes hacer también con el propio contenido de los archivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>A short and simple commit history.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Un registro de confirmaciones simple y corto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Jessica’s repository looks like Figure 5-12.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Quedando su repositorio como se muestra en la Figura 5-12</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The `+` tells Git to update the reference even if it isn’t a fast-forward.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110815T215950Z" changeid="juan">
        <seg>El  `+`, si está presente, indica a Git que debe actualizar la referencia incluso en los casos en que no se dé un avance rápido (fast-forward). </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you want an attribute like bold in the previous example, you can choose from bold, dim, ul, blink, and reverse.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>También puedes aplicar atributos tales como 'bold' (negrita), 'dim' (tenue), 'ul' ( ), 'blink' (parpadeante) y 'reverse (video inverso).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It starts with the 4 bytes specifying how much data is following, then the command to run followed by a null byte, and then the server’s hostname followed by a final null byte.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T075803Z" changeid="juan">
        <seg>Como siempre, comienza con 4 bytes indicadores de cuantos datos siguen a continuación, siguiendo con el comando a lanzar, y terminando con un byte nulo, el nombre del servidor y otro byte nulo más.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For example, if you want to change the last three commit messages, or any of the commit messages in that group, you supply as an argument to `git rebase -i` the parent of the last commit you want to edit, which is `HEAD~2^` or `HEAD~3`.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T122215Z" changeid="juan">
        <seg>Por ejemplo, para modificar las tres últimas confirmaciones de cambios, se  indicara el padre de la última conformación a modificar, es decir habrá que escribir `HEAD~2^` or `HEAD~3` tras el comando `git rebase -i`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It lets you edit the default message before the commit author sees it.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Te permite editar el mensaje por defecto, antes de que lo vea el autor de la confirmación de cambios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It’s important to note that when you do a fetch that brings down new remote branches, you don’t automatically have local, editable copies of them.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Es importante destacar que cuando recuperas (fetch) nuevas ramas remotas, no obtienes automáticamente una copia editable local de las mismas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Set up a merge wrapper script named `extMerge` that calls your binary with all the arguments provided:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El primer script a preparar es uno al que denominaremos 'extMerge', para llamar al ejecutable con los correspodientes argumentos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To see what packfiles are available on this server, you need to get the `objects/info/packs` file, which contains a listing of them (also generated by `update-server-info`):</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T131054Z" changeid="juan">
        <seg>Para ver que empaquetados hay disponibles en el servidor, has de recuperar el archivo `objects/info/packs`. Este contiene una lista de todos ellos: (que ha sido generada por `update-server-info`)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you want to version-control Word documents, you can stick them in a Git repository and commit every once in a while; but what good does that do?</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si deseas controlar versiones en documentos Word, puedes añadirlos a un repositorio Git e ir realizando confirmaciones de cambio (commit) cada vez. Pero, ¿qué ganas con ello?.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This looks a bit different than the `hotfix` merge you did earlier.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Es algo diferente de la fusión realizada anteriormente con 'hotfix'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>But you have already set up your repositories in `/opt/git`, so instead of reconfiguring everything, you create a symlink:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Pero si, en lugar de en esa, has instalado tus repositorios bajo la carpeta '/opt/git'. Sin necesidad de reconfigurarlo todo, tan solo has de crear un enlace virtual:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ cat .git/refs/remotes/origin/master
	ca82a6dff817ec66f44342007202690a93763949</seg>
      </tuv>
      <tuv lang="ES" changedate="20110810T225114Z" changeid="juan">
        <seg>$ cat .git/refs/remotes/origin/master
	ca82a6dff817ec66f44342007202690a93763949</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## An Example Git-Enforced Policy ##</seg>
      </tuv>
      <tuv lang="ES">
        <seg>## Un ejemplo de implantación de una determinada política en Git ##</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Remember again that this is a rebasing command — every commit included in the range `HEAD~3..HEAD` will be rewritten, whether you change the message or not.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T181327Z" changeid="juan">
        <seg>Es importante avisar de nuevo que se trata de un comando de reorganización: todas y cada una de las confirmaciones de cambios en el rango `HEAD~3..HEAD` van a ser reescritas, (cambia su código SHA-1), tanto si se modifica algo en ellas como si no.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Is a lieutenant system in place, and do you have to submit your work to them first?</seg>
      </tuv>
      <tuv lang="ES">
        <seg>¿Existe un sistema de tenientes, a los que has de enviar tu trabajo en primer lugar?.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### The HTTP/S Protocol ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### El protocolo HTTP/S ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can also set the value of HEAD:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T192921Z" changeid="juan">
        <seg>Y también puedes cambiar el valor de HEAD a través de él:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>commit ab1afef80fac8e34258ff41fc1b867c702daa24b
	Reflog: HEAD@{1} (Scott Chacon &lt;schacon@gmail.com&gt;)
	Reflog message: updating HEAD
	Author: Scott Chacon &lt;schacon@gmail.com&gt;
	Date:   Fri May 22 18:15:24 2009 -0700</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T143316Z" changeid="juan">
        <seg>commit ab1afef80fac8e34258ff41fc1b867c702daa24b
	Reflog: HEAD@{1} (Scott Chacon &lt;schacon@gmail.com&gt;)
	Reflog message: updating HEAD
	Author: Scott Chacon &lt;schacon@gmail.com&gt;
	Date:   Fri May 22 18:15:24 2009 -0700</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Writing objects: 100% (3/3), 230 bytes, done.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Writing objects: 100% (3/3), 230 bytes, done.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>lib/simplegit.rb |    4 ++++
	 1 files changed, 4 insertions(+), 0 deletions(-)</seg>
      </tuv>
      <tuv lang="ES">
        <seg>lib/simplegit.rb |    4 ++++
	 1 files changed, 4 insertions(+), 0 deletions(-)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In this section, we’ll cover some common workflows that this lightweight branching makes possible, so you can decide if you would like to incorporate it into your own development cycle.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En este apartado vamos a ver algunos de los flujos de trabajo más comunes, de tal forma que puedas decidir si te gustaría incorporar alguno de ellos a tu ciclo de desarrollo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ curl http://kernel.org/pub/software/scm/git/git-1.6.3.1.tar.bz2 &gt; git.tbz2
	$ git add git.tbz2
	$ git commit -am 'added git tarball'
	[master 6df7640] added git tarball
	 1 files changed, 0 insertions(+), 0 deletions(-)
	 create mode 100644 git.tbz2</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T104622Z" changeid="juan">
        <seg>$ curl http://kernel.org/pub/software/scm/git/git-1.6.3.1.tar.bz2 &gt; git.tbz2
	$ git add git.tbz2
	$ git commit -am 'added git tarball'
	[master 6df7640] added git tarball
	 1 files changed, 0 insertions(+), 0 deletions(-)
	 create mode 100644 git.tbz2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In this scenario, you have a `master` branch that contains basically stable code.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En este escenario, tienes una rama 'master' que contiene, principalmente, código estable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To synchronize your work, you run a `git fetch origin` command.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para sincronizarte, puedes utilizar el comando 'git fetch origin'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You may want to use `rebase -i` to squash your work down to a single commit, or rearrange the work in the commits to make the patch easier for the maintainer to review — see Chapter 6 for more information about interactive rebasing.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes querer utilizar 'rebase -i' para reducir tu trabajo a una sola confirmación de cambios (commit), o reorganizar el trabajo en las diversas confirmaciones para facilitar la revisión de parche por parte del gestor del proyecto --ver el Capítulo 6 para más detalles sobre reorganizaciones interactivas--.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>All these questions can affect how you contribute effectively to a project and what workflows are preferred or available to you.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Todas estas preguntas afectan a la forma efectiva de contribuir a un proyecto, y a la forma de trabajo que prefieras o esté disponible para tí.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Merging contributed topic branches into long-term integration branches.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Fusionando aportaciones de ramas puntuales en ramas de más largo recorrido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In the context of the `diff` command, you can put three periods after another branch to do a `diff` between the last commit of the branch you’re on and its common ancestor with another branch:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Estando en el contexto del comando 'diff', puedes indicar tres puntos entre los nombres de las dos ramas; para comparar entre la última confirmación de cambios de la rama donde estás y la respectiva confirmación común con la otra rama:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Boom.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y....Boom!.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can also manually edit this file, but again a safer command exists to do so: `symbolic-ref`.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T112144Z" changeid="juan">
        <seg>Puedes editar manualmente este archivo. Pero, también para esta tarea existe un comando más seguro: `symbolic-ref`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>At this stage, you’ll receive a call that another issue is critical and you need a hotfix.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En este momento, recibes una llamada avisandote de un problema crítico que has de resolver.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The presence of that file tells Git that it’s OK to serve this project without authentication.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La presencia de este archivo, indica a Git que está permitido el servir este proyecto sin necesidad de autentificación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you want to back up or clone your repository, copying this single directory elsewhere gives you nearly everything you need.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T142351Z" changeid="juan">
        <seg>Si deseas hacer una copia de seguridad de tu repositorio, con tan solo copiar esta carpeta a cualquier otro lugar ya tienes tu copia completa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>I found that learning this information was fundamentally important to understanding how useful and powerful Git is, but others have argued to me that it can be confusing and unnecessarily complex for beginners.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T142008Z" changeid="juan">
        <seg>Me parece que esta información es realmente importante para entender cúan util y potente es Git. Pero algunas personas opinan que puede ser confuso e innecesariamente complejo para novatos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When your branch work is finished and you’re ready to contribute it back to the maintainers, go to the original project page and click the &quot;Fork&quot; button, creating your own writable fork of the project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cuando el trabajo en tu rama puntual está terminado y estás listo para enviarlo al gestor del proyecto, vete a la página del proyecto original y clica sobre el botón &quot;Fork&quot; (bifurcar), para crear así tu propia copia editable del proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Say you have a database settings file called database.xml that is different in two branches, and you want to merge in your other branch without messing up the database file.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Digamos que tienes un archivo de datos denominado database.xml, distinto en las dos ramas, y que deseas fusionar en la otra rama sin perturbarlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To create an index with a single entry — the first version of your text.txt file — you can use the plumbing command `update-index`.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T194147Z" changeid="juan">
        <seg>Puedes utilizar el comando de &quot;fontaneria&quot; `update-index` para crear un índice con una sola entrada, --la primera version de tu archivo text.txt--.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Simply set it to the path of a file that has content similar to what a `.gitignore` file would have.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Simplemente, configuralo para que apunte a un archivo con contenido similar al que tendría cualquier archivo '.gitignore'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now, Git won’t try to convert or fix CRLF issues; nor will it try to compute or print a diff for changes in this file when you run git show or git diff on your project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>A partir de ahora, Git no intentará convertir ni corregir problemas CRLF en los finales de línea; ni intentará hacer comparaciones ni mostar diferencias de este archivo cuando lances comandos 'git show' o 'git diff' en tu proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you can, try to make your changes digestible — don’t code for a whole weekend on five different issues and then submit them all as one massive commit on Monday.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Siempre que te sea posible, intenta hacer digeribles tus cambios --no estés trabajando todo el fin de semana, sobre cuatro o cinco asuntos diferentes, y luego confirmes todo junto el lunes--.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git show maintainer-pgp-pub | gpg --import</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git show maintainer-pgp-pub | gpg --import</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You have to either move it out of the way or remove it, in which case you have to clone it again when you switch back—and you may lose local changes or branches that you didn’t push up.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T172632Z" changeid="juan">
        <seg>Forzandonos a removerla del camino. Lo cual obliga a volver a clonarla cuando se retome la rama inicial --con la consiguiente pérdida de los cambios locales si estos no habian sido enviados previamente al servidor--.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Because Git uses a simple three-way merge, merging from one branch into another multiple times over a long period is generally easy to do.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por la sencillez de la fusión a tres bandas de Git, el fusionar de una rama a otra multitud de veces a lo largo del tiempo es facil de hacer.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git can use four major network protocols to transfer data: Local, Secure Shell (SSH), Git, and HTTP.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Git puede usar cuatro protocolos principales para transferir datos: Local, Secure Shell (SSH), Git y HTTP.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git log refA refB ^refC
	$ git log refA refB --not refC</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T201848Z" changeid="juan">
        <seg>$ git log refA refB ^refC
	$ git log refA refB --not refC</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>First, you need to require the library and then run `Zlib::Deflate.deflate()` on the content:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T181743Z" changeid="juan">
        <seg>Primero has de incluir la libreria y luego lanzar la orden `Zlib::Deflate.deflate()` sobre el contenido: </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ vim test.rb
	$ git commit -a -m 'made other changes'</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ vim test.rb
	$ git commit -a -m 'made other changes'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0303.png
Figure 3-3.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0303.png
Figura 3-3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If the pusher is trying to push to multiple branches, `pre-receive` runs only once, whereas update runs once per branch they’re pushing to.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si la persona que realiza el envio intenta actualizar varias ramas, 'pre-receive' se ejecuta una sola vez, mientras que 'update' se ejecuta tantas veces como ramas se estén actualizando.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>From 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001
	From: Jessica Smith &lt;jessica@example.com&gt;
	Date: Sun, 6 Apr 2008 10:17:23 -0700
	Subject: [PATCH 1/2] add limit to log function</seg>
      </tuv>
      <tuv lang="ES">
        <seg>From 330090432754092d704da8e76ca5c05c198e71a8 Mon Sep 17 00:00:00 2001
	From: Jessica Smith &lt;jessica@example.com&gt;
	Date: Sun, 6 Apr 2008 10:17:23 -0700
	Subject: [PATCH 1/2] add limit to log function</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0902.png
Figure 9-2.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110807T145450Z" changeid="juan">
        <seg>Insert 18333fig0902.png
Figura 9-2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>*.doc diff=word</seg>
      </tuv>
      <tuv lang="ES">
        <seg>*.doc diff=word</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You’ve halved your disk usage by packing your objects.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110815T212230Z" changeid="juan">
        <seg>Empaquetando los objetos, has conseguido reducir a la mitad el uso de disco.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The workflow is similar to the previous use case — you create topic branches for each patch series you work on.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El flujo de trabajo es similar a los casos de uso vistos anteriormente; --creando ramas puntuales para cada serie de parches en los que vayas a trabajar--.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you’ve used keyword substitution in CVS or Subversion, you can include a datestamp — the SHA isn’t all that helpful, because it’s fairly random and you can’t tell if one SHA is older or newer than another.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si has utilizado alguna vez las sustituciones de CVS o de Subversion, sabrás que pueden incluir una marca de fecha, --la suma de comprobación SHA no es igual de util, ya que, por ser bastante aleatoria, es imposible deducir si una suma SHA es anterior o posterior a otra--.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>A simple way to get the commit message from a commit when you have the SHA-1 value is to go to the first blank line and take everything after that.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Una vía sencilla para obtener el mensaje, es la de ir hasta la primera línea en blanco y luego coger todo lo que siga a esta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You’ve effectively lost the top two commits — you have no branch from which those commits are reachable.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T133210Z" changeid="juan">
        <seg>Vemos que se han perdido las dos últimas confirmaciones de cambios, --no tienes ninguna rama que te permita acceder a ellas--.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Here’s an example to give you an idea of what it would take to get a SHA-1 collision.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T185848Z" changeid="juan">
        <seg>El siguiente ejemplo puede ser bastante ilustrativo, para hacernos una idea de lo que podría tardarse en darse una colisión en el código SHA-1:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0507.png
Figure 5-7.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0507.png
Figura 5-7.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The changes to your files were reapplied, but the file you staged before wasn’t restaged.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T093719Z" changeid="juan">
        <seg>Las modificaciones sobre los archivos serán aplicadas; pero no así el estado de preparación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you run it with the `--full` option, it shows you all objects that aren’t pointed to by another object:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T134016Z" changeid="juan">
        <seg>Si lo lanzas con la opción `--full`, te mostrará todos los objetos sin referencias a ningún otro objeto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>&gt;&gt; header = &quot;blob #{content.length}\0&quot;
	=&gt; &quot;blob 16\000&quot;</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T181301Z" changeid="juan">
        <seg>&gt;&gt; header = &quot;blob #{content.length}\0&quot;
	=&gt; &quot;blob 16\000&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can also use interactive rebases to reorder or remove commits entirely.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120728T090739Z" changeid="juan">
        <seg>Las reorganizaciones interactivas también se pueden emplear para reordenar o para eliminar completamente ciertas confirmaciones de cambios (commits).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Then, I ran `git diff` to see what changed:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tras lo cual he lanzando el comando 'git diff' para ver lo que ha cambiado:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>git commit --amend</seg>
      </tuv>
      <tuv lang="ES" changedate="20120728T085924Z" changeid="juan">
        <seg>git commit --amend</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can pretty easily see what files have been modified in a single commit with the `--name-only` option to the `git log` command (mentioned briefly in Chapter 2):</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes comprobar facilmente qué archivos han sido modificados en cada confirmación de cambios, utilizando la opción '--name-only' del comando 'git log' (citado brevemente en el capítulo 2):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>#### `color.*` ####</seg>
      </tuv>
      <tuv lang="ES">
        <seg>#### `color.*` ####</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Someone pushes rebased commits, abandoning commits you’ve based your work on.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Alguien envia (push) confirmaciones (commits) reorganizadas, abandonando las confirmaciones en las que tu habias basado tu trabajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Here is an example pre-rebase script that checks for that.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Este es un ejemplo de script previo a reorganización que lo puede comprobar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Perhaps instead of hosting an internal private project, you want to host an open source project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por ejemplo, si en lugar de albergar un proyecto privado interno, quieres albergar un proyecto de código abierto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>These scripts run before and after pushes to the server.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Estos scripts se lanzan antes y después de cada envio (push) al servidor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Also, if you include instructions in the tag message, running `git show &lt;tag&gt;` will let you give the end user more specific instructions about tag verification.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Además, si incluyes instrucciones en el mensaje de etiquetado, con el comando 'git show &lt;tag&gt;', los usuarios podrán tener directrices específicas acerca de la verificación de etiquetas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now you can look at your new commit object with `cat-file`:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110807T150237Z" changeid="juan">
        <seg>Con el comando `cat-file` puedes revisar el nuevo objeto de confirmación de cambios recién creado:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ cat .git/HEAD
	ref: refs/heads/master</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T192320Z" changeid="juan">
        <seg>$ cat .git/HEAD
	ref: refs/heads/master</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It performs a three-way merge between the two latest branch snapshots (C3 and C4) and the most recent common ancestor of the two (C2), creating a new snapshot (and commit), as shown in Figure 3-28.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Realiza una fusión a tres bandas entre las dos últimas instantáneas de cada rama (C3 y C4) y el ancestro común a ambas (C2); creando una nueva instantánea (snapshot)  y la correspondiente confirmación (commit), según se muestra en la Figura 3-28.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Commit Objects ###</seg>
      </tuv>
      <tuv lang="ES" changedate="20110807T145544Z" changeid="juan">
        <seg>### Objetos de confirmación de cambios ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now, if you commit and push the project, GitWeb will automatically start showing your iphone project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>A partir de ese momento, cuando confirmes cambios (commit) y envies (push) el proyecto, GitWeb comenzará a mostrar tu proyecto iphone.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git config --global commit.template $HOME/.gitmessage.txt
	$ git commit</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git config --global commit.template $HOME/.gitmessage.txt
	$ git commit</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now, Jessica can merge her topic work into her master branch, merge John’s work (`origin/master`) into her `master` branch, and then push back to the server again.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Ahora, jessica puede fusionar (merge) su trabajo de la rama puntual 'issue54' en su rama 'master'l, fusionar (merge) el trabajo de John ('origin/master') en su rama 'master', y enviarla de vuelta al servidor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You’ll do the following:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y sigues los siguientes pasos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0403.png
Figure 4-3.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0403.png
Figura 4-3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Perhaps it’s a library that a third party developed or that you’re developing separately and using in multiple parent projects.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T170120Z" changeid="juan">
        <seg>En ocasiones como, por ejemplo, cuando se utiliza una biblioteca de terceros, o cuando se está desarrollando una biblioteca independiente para ser utilizada en múltiples proyectos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You have to figure out how to get the commit message from each of these commits to test.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tienes que imaginarte cómo puedes obtener el mensaj ede cada una de esas confirmaciones de cambios a comprobar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It’s important to note that this file is version-controlled with your other files, like your `.gitignore` file.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T170704Z" changeid="juan">
        <seg>Merece destacar que este archivo está también bajo el control de versiones, como lo están otros archivos tal como `.gitignore`, por ejemplo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git log contrib --not master
	commit 5b6235bd297351589efc4d73316f0a68d484f118
	Author: Scott Chacon &lt;schacon@gmail.com&gt;
	Date:   Fri Oct 24 09:53:59 2008 -0700</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git log contrib --not master
	commit 5b6235bd297351589efc4d73316f0a68d484f118
	Author: Scott Chacon &lt;schacon@gmail.com&gt;
	Date:   Fri Oct 24 09:53:59 2008 -0700</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This makes merging a heck of a lot easier in Git than in these other systems.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto hace que en Git sea mucho más facil el realizar fusiones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can also use Git attributes to tell Git to use different merge strategies for specific files in your project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>También puedes utilizar los atributos Git para indicar distintas estrategias de fusión para archivos específicos de tu proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>added a submodule reference I will never make public.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T110916Z" changeid="juan">
        <seg>added a submodule reference I will never make public.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git remote add rack_remote git@github.com:schacon/rack.git
	$ git fetch rack_remote
	warning: no common commits
	remote: Counting objects: 3184, done.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T142011Z" changeid="juan">
        <seg>$ git remote add rack_remote git@github.com:schacon/rack.git
	$ git fetch rack_remote
	warning: no common commits
	remote: Counting objects: 3184, done.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For instance, if you want to show the last commit object on a branch, the following commands are equivalent, assuming that the `topic1` branch points to `ca82a6d`:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T100854Z" changeid="juan">
        <seg>Por ejemplo, si se desea mostrar la última confirmación de cambios en una rama, y suponiendo que la rama 'topic1' apunta a 'ca82a6d', los tres comandos siguientes son equivalentes: </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git show master@{yesterday}</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T102459Z" changeid="juan">
        <seg>$ git show master@{yesterday}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Jessica wants to sync up with John, so she fetches:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Jessica desea sincronizarse con John, para lo cual:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>We’ll use the normal path here because doing so is almost always faster.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Habitualmente, usaremos el camino (path) normal por ser casi siempre más rápido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Next, you have to manually set the execute bit on the `post-update` script for your new control repository.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>A continuanción, has de ajustar manualmente el bit de ejecución en el script 'post-update' de tu nuevo repositorio de contrrol:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>remote: Total 3184 (delta 1952), reused 2770 (delta 1675)
	Receiving objects: 100% (3184/3184), 677.42 KiB | 88 KiB/s, done.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T135850Z" changeid="juan">
        <seg>remote: Total 3184 (delta 1952), reused 2770 (delta 1675)
	Receiving objects: 100% (3184/3184), 677.42 KiB | 88 KiB/s, done.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0330.png
Figure 3-30.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0330.png
Figura 3-30.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This way, it’s easy to tweak a patch individually and leave it if it’s not working until you have time to come back to it.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>De esta forma, es sencillo tratar cada parche de forma individualizada y poder &quot;aparcar&quot; uno concreto cuando no trabajamos en él, hasta cuando volvamos a tener tiempo para retomarlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The other way you can do this is via server-side receive hooks, which I’ll cover in a bit.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Otra manera de obtener el mismo resultado, es a través de los enganches (hooks) en el lado servidor. Enganches de los que hablaremos en breve.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>These days, you have a huge number of hosting options to choose from, each with different advantages and disadvantages.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Actualmente tienes un gran número de opciones del alojamiento, cada una con sus ventajas y desventajas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If `master` is a direct ancestor of your topic branch, this isn’t a problem; but if the two histories have diverged, the diff will look like you’re adding all the new stuff in your topic branch and removing everything unique to the `master` branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si 'master' es un ancestro directo de tu rama puntual, no tendrás problemas. Pero si los historiales de las dos ramas son divergentes, la comparación directa de diferencias dará la apariencia de estar añadiendo todo el material nuevo en la rama puntual y de estar borrando todo el material nuevo en la rama 'master'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You’ll learn how to be a benevolent dictator or integration manager.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Vas a aprender cómo ser un dictador benevolente o un gestor de integración.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>#!</seg>
      </tuv>
      <tuv lang="ES">
        <seg>#!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This means you can have several branches that are always open and that you use for different stages of your development cycle; you can merge regularly from some of them into others.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto te posibilita tener varias ramas siempre abiertas, e irlas usando en diferentes etapas del ciclo de desarrollo; realizando frecuentes fusiones entre ellas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>And you can specify older commits with this data, as well.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T085628Z" changeid="juan">
        <seg>Y esta información se puede utilizar para referirse a confirmaciones de cambio pasadas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In reality, we’re talking about pointers moving up the line of commits you’re making.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En realidad, en todo momento estamos hablando simplemente de apuntadores moviendose por la línea temporal de confirmaciones de cambio (commit history).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>We’ve covered basic branching and merging in Git.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Hemos visto los procedimientos básicos de ramificación (branching) y fusión (merging) en Git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You’ll see a remote rejected message for each reference that your hook declined, and it tells you that it was declined specifically because of a hook failure.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Un mensaje por cada referencia rechazada por el enganche (hook) de actualización, especificando que ha sido rechazada precisamente por un fallo en el enganche.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>More stable branches are generally farther down the commit history.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Las ramas más estables apuntan hacia posiciones más antiguas en el registro de cambios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>That approach lets you do more complex things like deny non-fast-forwards to a certain subset of users.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esta otra vía te permite realizar ajustes más finos, tales como denegar refencias de avance no directo, (non-fast-forwards), unicamente a un grupo de usuarios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>##</seg>
      </tuv>
      <tuv lang="ES">
        <seg>##</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Notice that you don’t need to specify the path (in fact, doing so won’t work), just a colon and then the name of the project — Gitosis finds it for you.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Ten en cuenta que no es necesario indicar expresamente un camino (path), --de hecho, si lo haces, no funcionará--. Simplemente, has de poner un punto y el nombre del proyecto, --Gitosis se encargará de encontrarlo--.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The `.pub` file is your public key, and the other file is your private key.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El archivo terminado en '.pub' es tu clave pública, y el otro archivo es tu clave privada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For more information about the differences in efficiency between the HTTP protocol and the other protocols, see Chapter 9.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para más información sobre diferencias de eficiencia entre el protocolo HTTP y los otros protocolos, ver el Capítulo 9.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>[repo iphone_project]
	daemon = yes</seg>
      </tuv>
      <tuv lang="ES">
        <seg>[repo iphone_project]
	daemon = yes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In this case, the company is using a type of integration-manager workflow where the work of the individual groups is integrated only by certain engineers, and the `master` branch of the main repo can be updated only by those engineers.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En este caso, la compañia está utilizando un flujo de trabajo del tipo gestor-de-integración, donde el trabajo de algunos grupos individuales es integrado por unos ingenieros concretos; siendo solamente estos últimos quienes pueden actualizar la rama 'master' del repositorio principal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>#### SSH Access ####</seg>
      </tuv>
      <tuv lang="ES">
        <seg>#### Acceso SSH ####</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The first thing you’ll do is write your ACL.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Como hemos dicho, el primer paso es escribir tu lista de control de accesos (ACL).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Then, you can use a branch name in any Git command that expects a commit object or SHA-1 value.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T100649Z" changeid="juan">
        <seg>De esta forma, se puede emplear el nombre de la rama en cualquier comando Git que espere un objeto de confirmación de cambios o un código SHA-1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now, John can test his code to make sure it still works properly, and then he can push his new merged work up to the server:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En este momento, John puede comprobar su código para verificar que sigue funcionando correctamente, y luego puede enviar su trabajo al servidor:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This also means the changes you make from this point forward will diverge from an older version of the project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto supone que los cambios que hagas desde este momento en adelante divergerán de la antigua versión del proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can set up an attribute like this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes ajustar un atributo tal como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>There are two ways to apply an e-mailed patch: with `git apply` or with `git am`.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tienes dos caminos para incorporar un parche recibido por correo-e: usando el comando 'git apply' o usando el comando 'git am'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git verify-pack -v \
	  .git/objects/pack/pack-7a16e4488ae40c7d2bc56ea2bd43e25212a66c45.idx
	0155eb4229851634a0f03eb265b69f5a2d56f341 tree   71 76 5400
	05408d195263d853f09dca71d55116663690c27c blob   12908 3478 874
	09f01cea547666f58d6a8d809583841a7c6f0130 tree   106 107 5086
	1a410efbd13591db07496601ebc7a059dd55cfe9 commit 225 151 322
	1f7a7a472abf3dd9643fd615f6da379c4acb3e3a blob   10 19 5381
	3c4e9cd789d88d8d89c1073707c3585e41b0e614 tree   101 105 5211
	484a59275031909e19aadb7c92262719cfcdf19a commit 226 153 169
	83baae61804e65cc73a7201a7252750c76066a30 blob   10 19 5362
	9585191f37f7b0fb9444f35a9bf50de191beadc2 tag    136 127 5476
	9bc1dc421dcd51b4ac296e3e5b6e2a99cf44391e blob   7 18 5193 1
	05408d195263d853f09dca71d55116663690c27c \
	  ab1afef80fac8e34258ff41fc1b867c702daa24b commit 232 157 12
	cac0cab538b970a37ea1e769cbbde608743bc96d commit 226 154 473
	d8329fc1cc938780ffdd9f94e0d364e0ea74f579 tree   36 46 5316
	e3f094f522629ae358806b17daf78246c27c007b blob   1486 734 4352
	f8f51d7d8a1760462eca26eebafde32087499533 tree   106 107 749
	fa49b077972391ad58037050f2a75f74e3671e92 blob   9 18 856
	fdf4fc3344e67ab068f836878b6c4951e3b15f3d commit 177 122 627
	chain length = 1: 1 object
	pack-7a16e4488ae40c7d2bc56ea2bd43e25212a66c45.pack: ok</seg>
      </tuv>
      <tuv lang="ES" changedate="20110815T212517Z" changeid="juan">
        <seg>$ git verify-pack -v \
	  .git/objects/pack/pack-7a16e4488ae40c7d2bc56ea2bd43e25212a66c45.idx
	0155eb4229851634a0f03eb265b69f5a2d56f341 tree   71 76 5400
	05408d195263d853f09dca71d55116663690c27c blob   12908 3478 874
	09f01cea547666f58d6a8d809583841a7c6f0130 tree   106 107 5086
	1a410efbd13591db07496601ebc7a059dd55cfe9 commit 225 151 322
	1f7a7a472abf3dd9643fd615f6da379c4acb3e3a blob   10 19 5381
	3c4e9cd789d88d8d89c1073707c3585e41b0e614 tree   101 105 5211
	484a59275031909e19aadb7c92262719cfcdf19a commit 226 153 169
	83baae61804e65cc73a7201a7252750c76066a30 blob   10 19 5362
	9585191f37f7b0fb9444f35a9bf50de191beadc2 tag    136 127 5476
	9bc1dc421dcd51b4ac296e3e5b6e2a99cf44391e blob   7 18 5193 1
	05408d195263d853f09dca71d55116663690c27c \
	  ab1afef80fac8e34258ff41fc1b867c702daa24b commit 232 157 12
	cac0cab538b970a37ea1e769cbbde608743bc96d commit 226 154 473
	d8329fc1cc938780ffdd9f94e0d364e0ea74f579 tree   36 46 5316
	e3f094f522629ae358806b17daf78246c27c007b blob   1486 734 4352
	f8f51d7d8a1760462eca26eebafde32087499533 tree   106 107 749
	fa49b077972391ad58037050f2a75f74e3671e92 blob   9 18 856
	fdf4fc3344e67ab068f836878b6c4951e3b15f3d commit 177 122 627
	chain length = 1: 1 object
	pack-7a16e4488ae40c7d2bc56ea2bd43e25212a66c45.pack: ok</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now, you can set up an empty repository for them by running `git init` with the `--bare` option, which initializes the repository without a working directory:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tras esto, puedes preparar un repositorio básico vacio para ellos, usando el comando 'git init' con la opción '--bare' para inicializar el repositorio sin carpeta de trabajo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Suffice it to say that this is rare.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Ni que decir tiene que esto solo lo necesitarás en contadas ocasiones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>But those are the only two differences — otherwise, the script works the same way.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Estas dos son las únicas diferencias; en todo lo demás, el script funciona de la misma manera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This makes for a very powerful revision query system that should help you figure out what is in your branches.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T201959Z" changeid="juan">
        <seg>Esto da una enorme versatilidad al sistema de consultas y permite revisar el contenido de todas las ramas  en el repositorio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git checkout iss53
	Switched to branch &quot;iss53&quot;
	$ vim index.html
	$ git commit -a -m 'finished the new footer [issue 53]'
	[iss53]: created ad82d7a: &quot;finished the new footer [issue 53]&quot;
	 1 files changed, 1 insertions(+), 0 deletions(-)</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git checkout iss53
	Switched to branch &quot;iss53&quot;
	$ vim index.html
	$ git commit -a -m 'finished the new footer [issue 53]'
	[iss53]: created ad82d7a: &quot;finished the new footer [issue 53]&quot;
	 1 files changed, 1 insertions(+), 0 deletions(-)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ find .git/refs -type f
	.git/refs/heads/experiment
	.git/refs/heads/master
	.git/refs/tags/v1.0
	.git/refs/tags/v1.1</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T092443Z" changeid="juan">
        <seg>$ find .git/refs -type f
	.git/refs/heads/experiment
	.git/refs/heads/master
	.git/refs/tags/v1.0
	.git/refs/tags/v1.1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>That shows you where the branch tip was yesterday.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T102554Z" changeid="juan">
        <seg>Este comando mostrará a dónde apuntaba ayer la rama.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Great.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Estupendo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>At this point, you should be able to go to your Drafts folder, change the To field to the mailing list you’re sending the patch to, possibly CC the maintainer or person responsible for that section, and send it off.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En estos momentos, deberías poder ir a tu carpeta de borradores (Drafts), cambiar el destinatario (To) para apuntar a la lista de correo donde estés enviando el parche, puede que poner en copia (CC) al gestor o persona responsable, y enviar el mensaje.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0701.png
Figure 7-1.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0701.png
Figura 7-1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git checkout master
	error: Untracked working tree file 'rack/AUTHORS' would be overwritten by merge.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T140016Z" changeid="juan">
        <seg>$ git checkout master
	error: Untracked working tree file 'rack/AUTHORS' would be overwritten by merge.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The latter wouldn’t be ideal, because all your code repository instances would reside on the same computer, making a catastrophic loss much more likely.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Aunque este último caso no es precisamente el ideal, ya que todas las instancias del repositorio estarían en la misma máquina; aumentando las posibilidades de una pérdida catastrófica.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The content-addressable filesystem layer is amazingly cool, so I’ll cover that first in this chapter; then, you’ll learn about the transport mechanisms and the repository maintenance tasks that you may eventually have to deal with.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110817T150102Z" changeid="juan">
        <seg>La capa del sistema de archivos que almacena el contenido es increiblemente interesante; por ello, es lo primero que voy a desarrollar en este capítulo. A continuación mostraré los mecanismos de transporte y las tareas de mantenimiento del repositorio que posiblemente necesites usar alguna vez.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>#### Diffing Binary Files ####</seg>
      </tuv>
      <tuv lang="ES">
        <seg>#### Comparando archivos binarios ####</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In Chapter 7, you’ll learn how to do more complicated manual project imports.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En el capítulo 7, aprenderás cómo realizar importaciones manuales de proyectos complejos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Gitosis requires some Python tools, so first you have to install the Python setuptools package, which Ubuntu provides as python-setuptools:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Gitosis necesita de ciertas herramientas Python, por lo que la  primera tarea será instalar el paquete de herramientas Pyton. En Ubuntu viene como el paquete python-stuptools:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg># on your local computer
	$ git clone git@gitserver:gitosis-admin.git</seg>
      </tuv>
      <tuv lang="ES">
        <seg>a tu ordenador personal--
	$ git clone git@gitserver:gitosis-admin.git</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git merge origin/featureBee
	Auto-merging lib/simplegit.rb
	Merge made by recursive.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git merge origin/featureBee
	Auto-merging lib/simplegit.rb
	Merge made by recursive.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can’t stop the patching process with this script.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>No puedes detener el proceso de parcheo con este script.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can keep doing this for several levels of stability.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Este sistema de trabajo se puede ampliar para diversos grados de estabilidad.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In this section, you’ll use what you’ve learned to establish a Git workflow that checks for a custom commit message format, enforces fast-forward-only pushes, and allows only certain users to modify certain subdirectories in a project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En esta sección, utilizarás lo aprendido para establecer un flujo de trabajo en Git que: compruebe si los mensajes de confirmación de cambios encajan en un determinado formato, obligue a realizar solo envios de avance directo, y permita solo a ciertos usuarios modificar ciertas carpetas del proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You want to see what is in your experiment branch that hasn’t yet been merged into your master branch.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T090345Z" changeid="juan">
        <seg>Si se desea ver qué partes de la rama experiment están sin fusionar aún con la rama master.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Another useful option to figure out what state your branches are in is to filter this list to branches that you have or have not yet merged into the branch you’re currently on.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Otra opción útil para averiguar el estado de las ramas, es filtrarlas y mostrar solo aquellas que han sido fusionadas (o que no lo han sido) con la rama actualmente activa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Here you must choose a username that isn’t yet taken in the system and enter an e-mail address that will be associated with the account and a password (see Figure 4-3).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En ella, has de elegir un nombre de usuario que esté libre, indicar una cuenta de correo electrónico y poner una contraseña.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In the Git source code, for example, the maintainer has added their GPG public key as a blob object and then tagged it.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T234751Z" changeid="juan">
        <seg>Por ejemplo, en el código fuente de Git los gestores han añadido su clave GPG pública como un objeto binario (blob) y lo han etiquetado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Wouldn’t it be nice if Git could store one of them in full but then the second object only as the delta between it and the first?</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T113917Z" changeid="juan">
        <seg>¿No seria práctico si Git pudiera almacenar uno de ellos completo y luego solo las diferencias del segundo con respecto al primero?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git stash
	Saved working directory and index state \
	  &quot;WIP on master: 049d078 added the index file&quot;
	HEAD is now at 049d078 added the index file
	(To restore them type &quot;git stash apply&quot;)</seg>
      </tuv>
      <tuv lang="ES" changedate="20120702T085257Z" changeid="juan">
        <seg>$ git stash
	Saved working directory and index state \
	  &quot;WIP on master: 049d078 added the index file&quot;
	HEAD is now at 049d078 added the index file
	(To restore them type &quot;git stash apply&quot;)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Figure 3-29 illustrates this process.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El proceso se muestra en la Figura 3-29.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now you have the root of the Rack project in your `rack_branch` branch and your own project in the `master` branch.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T173316Z" changeid="juan">
        <seg>En este punto, se tiene la raiz del proyecto Rack en la rama `rack_branch` y la del propio proyecto padre en la rama `master`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>That installs a couple of executables that Gitosis will use.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto instala un par de ejecutables, que serán los que Gitosis utilice.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The issue is that you generally don’t want to work in a detached head environment, because it’s easy to lose changes.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T172321Z" changeid="juan">
        <seg>Este método de trabajo suele tenderse a evitar, ya que trabajando en un entorno de cabecera desconectada es bastante facil despistarse y perder cambios ya realizados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you push commits somewhere and others pull them down and base work on them, and then you rewrite those commits with `git rebase` and push them up again, your collaborators will have to re-merge their work and things will get messy when you try to pull their work back into yours.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si envias (push) confirmaciones (commits) a alguna parte, y otros las recogen (pull) de allí. Y después vas tu y las reescribes con 'git rebase' y las vuelves a enviar (push) de nuevo. Tus colaboradores tendrán que refusionar (re-merge) su trabajo  y todo se volverá tremendamente complicado cuando intentes recoger (pull) su trabajo de vuelta sobre el tuyo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>All the changes from your Rack project are merged in and ready to be committed locally.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T163518Z" changeid="juan">
        <seg>Con esto, todos los cambios en el proyecto Rack se encontrarán fusionados y listos para ser confirmados localmente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is nice if you have a number of patches saved, because you can view the patch first if you don’t remember what it is, or not apply the patch if you’ve already done so.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Es una utilidad interesante si tienes tienes almacenados unos cuantos parches, porque puedes ir revisando previamente cada parche y aplicarlos selectivamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>#### help.autocorrect ####</seg>
      </tuv>
      <tuv lang="ES">
        <seg>#### help.autocorrect ####</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>As you’ll remember, you can create the branch based off your master branch like this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Como recordarás, la forma de crear una rama basandola en tu rama master es:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Next, you need to add some developer SSH public keys to the `authorized_keys` file for that user.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y a continuación añades las claves públicas de los desarrolladores al archivo 'autorized_keys' del usuario 'git' que has creado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git show 1c002dd4b536e7479fe34593e72e6c6c1819e53b
	$ git show 1c002dd4b536e7479f
	$ git show 1c002d</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T095203Z" changeid="juan">
        <seg>$ git show 1c002dd4b536e7479fe34593e72e6c6c1819e53b
	$ git show 1c002dd4b536e7479f
	$ git show 1c002d</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>But in Git it’s common to create, work on, merge, and delete branches several times a day.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Pero en Git, por el contrario, es muy habitual el crear, trabajar con, fusionar y borrar ramas varias veces al día.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You’ll also take this opportunity to move the work to be based off the project’s current `master` branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes aprovechar también esta oportunidad para mover el trabajo y actualizarlo sobre la actual rama 'master' del proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>From git@github.com:schacon/simplegit
	 * [new branch]      serverfix    -&gt; origin/serverfix</seg>
      </tuv>
      <tuv lang="ES">
        <seg>From git@github.com:schacon/simplegit
	 * [new branch]      serverfix    -&gt; origin/serverfix</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The cons of this method are that shared access is generally more difficult to set up and reach from multiple locations than basic network access.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La principal desventaja de los repositorios basados en carpetas y archivos es su dificultad de acceso desde distintas ubicaciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>There is a bit of a problem — she needs to push the merged work in her `featureB` branch to the `featureBee` branch on the server.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Pero hay un pequeño problema, necesita enviar el trabajo fusionado en su rama 'featureB' a la rama 'featureBee' del servidor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Because this is a pretty cool and not widely known feature, I’ll go over a few examples.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esta es una funcionalidad muy util, pero bastante desconocida. Por lo que la ilustraré con unos ejemplos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## Branching Workflows ##</seg>
      </tuv>
      <tuv lang="ES">
        <seg>## Flujos de trabajo ramificados ##</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>From that point forward, it should be called.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>A partir de ese momento, será automáticamente lanzado cuando se dé la acción correspondiente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git branch -v
	  iss53   93b412c fix javascript issue
	* master  7a98805 Merge branch 'iss53'
	  testing 782fd34 add scott to the author list in the readmes</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git branch -v
	  iss53   93b412c fix javascript issue
	* master  7a98805 Merge branch 'iss53'
	  testing 782fd34 add scott to the author list in the readmes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0302.png
Figure 3-2.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0302.png
Figura 3-2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is roughly equivalent to something like</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Siendo el proceso mas o menos equivalente a haber realizado:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You’ll rarely want `color.ui = always`.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Será muy raro ajustar 'color.ui = always'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can see that this command shows you a much different view of your staging area — basically the same information you get with `git status` but a bit more succinct and informative.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T211941Z" changeid="juan">
        <seg>Según se ve, este comando muestra una vista bastante diferente del área de preparación (staging area). Básicamente se trata de la misma información dada por el comando 'git status', pero mas sucinta e informativa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>[imap]
	  folder = &quot;[Gmail]/Drafts&quot;
	  host = imaps://imap.gmail.com
	  user = user@gmail.com
	  pass = p4ssw0rd
	  port = 993
	  sslverify = false</seg>
      </tuv>
      <tuv lang="ES">
        <seg>[imap]
	  folder = &quot;[Gmail]/Drafts&quot;
	  host = imaps://imap.gmail.com
	  user = user@gmail.com
	  pass = p4ssw0rd
	  port = 993
	  sslverify = false</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The GitWeb web-based user interface.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El interface web GitWeb.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>At that point, everyone will be able to access that machine via the 'git' user.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>De esta forma, todos pueden acceder a la máquina a través del usuario 'git'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you pass `--objects` to `rev-list`, it lists all the commit SHAs and also the blob SHAs with the file paths associated with them.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T110132Z" changeid="juan">
        <seg>Con la opción `--objects`, obtendrás la lista de todas las SHA de todas las confirmaciones de cambio, junto a las SHA de los objetos binarios y las ubicaciones (paths) de cada uno de ellos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>0088ca82a6dff817ec66f44342007202690a93763949 HEAD\0multi_ack thin-pack \
	  side-band side-band-64k ofs-delta shallow no-progress include-tag
	003fca82a6dff817ec66f44342007202690a93763949 refs/heads/master
	003e085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 refs/heads/topic
	0000</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T080105Z" changeid="juan">
        <seg>0088ca82a6dff817ec66f44342007202690a93763949 HEAD\0multi_ack thin-pack \
	  side-band side-band-64k ofs-delta shallow no-progress include-tag
	003fca82a6dff817ec66f44342007202690a93763949 refs/heads/master
	003e085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7 refs/heads/topic
	0000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It also requires firewall access to port 9418, which isn’t a standard port that corporate firewalls always allow.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Requiere además abrir expresamente acceso al puerto 9418 en el cortafuegos, ya que este no es uno de los puertos estandares que suelen estar habitualmente permitidos en los cortafuegos corporativos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>One way to do this is to run JPEG files through a filter that extracts their EXIF information — metadata that is recorded with most image formats.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Un camino puede ser pasar los archivos JPEG a través de un filtro para extraer su información EXIF --los metadatos que se graban dentro de la mayoria de formatos gráficos--.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0904.png
Figure 9-4.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T191524Z" changeid="juan">
        <seg>Insert 18333fig0904.png
Figura 9-4.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Suppose you’re developing a web site and creating Atom feeds.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T083946Z" changeid="juan">
        <seg>Supongamos que se está desarrollando un site web y creando feeds Atom.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When you run `git commit`, it creates the commit object, specifying the parent of that commit object to be whatever SHA-1 value the reference in HEAD points to.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T111553Z" changeid="juan">
        <seg>Cuando lanzas una orden `git commit`, se crea un nuevo objeto de confirmación de cambios teniendo como padre la confirmación con valor SHA-1 a la que en ese momento esté apuntando la referencia en HEAD.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ find .git/objects -type f
	.git/objects/01/55eb4229851634a0f03eb265b69f5a2d56f341 # tree 2
	.git/objects/1a/410efbd13591db07496601ebc7a059dd55cfe9 # commit 3
	.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a # test.txt v2
	.git/objects/3c/4e9cd789d88d8d89c1073707c3585e41b0e614 # tree 3
	.git/objects/83/baae61804e65cc73a7201a7252750c76066a30 # test.txt v1
	.git/objects/95/85191f37f7b0fb9444f35a9bf50de191beadc2 # tag
	.git/objects/ca/c0cab538b970a37ea1e769cbbde608743bc96d # commit 2
	.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4 # 'test content'
	.git/objects/d8/329fc1cc938780ffdd9f94e0d364e0ea74f579 # tree 1
	.git/objects/fa/49b077972391ad58037050f2a75f74e3671e92 # new.txt
	.git/objects/fd/f4fc3344e67ab068f836878b6c4951e3b15f3d # commit 1</seg>
      </tuv>
      <tuv lang="ES" changedate="20110810T225911Z" changeid="juan">
        <seg>$ find .git/objects -type f
	.git/objects/01/55eb4229851634a0f03eb265b69f5a2d56f341 # tree 2
	.git/objects/1a/410efbd13591db07496601ebc7a059dd55cfe9 # commit 3
	.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a # test.txt v2
	.git/objects/3c/4e9cd789d88d8d89c1073707c3585e41b0e614 # tree 3
	.git/objects/83/baae61804e65cc73a7201a7252750c76066a30 # test.txt v1
	.git/objects/95/85191f37f7b0fb9444f35a9bf50de191beadc2 # tag
	.git/objects/ca/c0cab538b970a37ea1e769cbbde608743bc96d # commit 2
	.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4 # 'test content'
	.git/objects/d8/329fc1cc938780ffdd9f94e0d364e0ea74f579 # tree 1
	.git/objects/fa/49b077972391ad58037050f2a75f74e3671e92 # new.txt
	.git/objects/fd/f4fc3344e67ab068f836878b6c4951e3b15f3d # commit 1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>At this point, you can easily switch branches and do work elsewhere; your changes are stored on your stack.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120712T202755Z" changeid="juan">
        <seg>Y se permite cambiar de rama para ponerse a trabajar en cualquier otra parte. Con la tranquilidad de que los cambios a medio completar están guardados a buen recaudo en la pila de guardado rápido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>README |    1 +
	 1 files changed, 1 insertions(+), 0 deletions(-)</seg>
      </tuv>
      <tuv lang="ES">
        <seg>README |    1 +
	 1 files changed, 1 insertions(+), 0 deletions(-)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ cat /usr/local/bin/extDiff
	#!/bin/sh
	[ $# -eq 7 ] &amp;&amp; /usr/local/bin/extMerge &quot;$2&quot; &quot;$5&quot;</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ cat /usr/local/bin/extDiff
	#!/bin/sh
	[ $# -eq 7 ] &amp;&amp; /usr/local/bin/extMerge &quot;$2&quot; &quot;$5&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>That is a very useful syntax to remember.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Es una sintaxis muy util, que merece recordar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git diff
	diff --git a/chapter1.doc b/chapter1.doc
	index 88839c4..4afcb7c 100644
	Binary files a/chapter1.doc and b/chapter1.doc differ</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git diff
	diff --git a/chapter1.doc b/chapter1.doc
	index 88839c4..4afcb7c 100644
	Binary files a/chapter1.doc and b/chapter1.doc differ</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You should feel fairly comfortable contributing to a project in Git as well as maintaining your own project or integrating other users’ contributions.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>A estas alturas, deberías sentirte confortable tanto contribuyendo a un proyecto, como manteniendo tu propio proyecto o integrando contribuciones de otras personas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The Commits tab shows a list of commits in reverse chronological order, similar to the output of the `git log` command.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La pestaña &quot;Commits&quot; muestra una lista de confirmaciones de cambio, en orden cronológico inverso, de forma similar a la salida del comando 'git log'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### The Perils of Rebasing ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Los peligros de la reorganización ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>test/ export-ignore</seg>
      </tuv>
      <tuv lang="ES">
        <seg>test/ export-ignore</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Doing so automatically runs `test-error.sh` on each checked-out commit until Git finds the first broken commit.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T073622Z" changeid="juan">
        <seg>De esta forma, se irá ejecutando automáticamente `test-error.sh` en cada confirmación de cambios que se vaya extrayendo. Hasta que Git encuentre la primera donde se presenten problemas. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It turns out that you can write your own filters for doing substitutions in files on commit/checkout.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Auque resulta que también puedes escribir tus propios filtros para realizar sustituciones en los archivos al guardar o recuperar (commit/checkout).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0316.png
Figure 3-16.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0316.png
Figura 3-16.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This option is available only in Git 1.6.1 and later.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Este parámetro solo está disponible a partir de la versión 1.6.1 de Git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can also leave off one side of the syntax to have Git assume HEAD.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T121311Z" changeid="juan">
        <seg>Es posible también omitir la parte final de la sentencia y dejar que Git asuma HEAD.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You should see something like this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y deberás ver algo así como esto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Figure 3-7 illustrates the result.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La Figura 3-7 ilustra el resultado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>As you may remember from Chapter 1, Git doesn’t store data as a series of changesets or deltas, but instead as a series of snapshots.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Recordando lo citado en el capítulo 1, Git no los almacena de forma incremental (guardando solo diferencias), sino que los almacena como una serie de instantáneas (copias puntuales de los archivos completos, tal y como se encuentran en ese momento). </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You must have around 7,000 loose objects or more than 50 packfiles for Git to fire up a real gc command.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T132659Z" changeid="juan">
        <seg>Ya que es necesaria la presencia de unos 7.000 objetos sueltos o más de 50 archivos empaquetadores para que Git termine lanzando realmente un comando &quot;gc&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>See Chapter 9 for a more detailed discussion of Git refspecs and different things you can do with them.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes ver el Capítulo 9 para una discusión más detallada acerca de los _refspecs_ de Git y los distintos usos que puedes darles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you have a complex workflow process that has a QA team pushing branches, developers pushing branches, and integration teams pushing and collaborating on remote branches, you can namespace them easily this way.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110815T222238Z" changeid="juan">
        <seg>De esta forma, puedes asignar facilmente espacios de nombres. Y resolver así complejos flujos de trabajo donde tengas simultáneamente , por ejemplo, un equipo QA enviando ramas, varios desarrolladores enviando ramas también y equipos integradores enviando y colaborando en ramas remotas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now, Jessica makes a couple of commits on the `featureB` branch:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y realiza un par de confirmaciones de cambios (commits) en la rama 'featureB':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Your public key has been saved in /Users/schacon/.ssh/id_rsa.pub.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Your public key has been saved in /Users/schacon/.ssh/id_rsa.pub.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Here I assume the connecting user is in the `$USER` environment variable, so your update script begins by gathering all the information you need:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Aqui, asumiremos que el usuario conectado queda reflejado en la variable de entorno '$USER', de tal forma que el script 'update' comienza recogiendo toda la información que necesitas:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you can, encourage your contributors to use `format-patch` instead of `diff` to generate patches for you.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si puedes, anima a tus colaboradoras a utilizar 'format-patch' en lugar de 'diff' cuando vayan a generar parches.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Server-Side Hook ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Punto de enganche en el lado servidor ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Then, you branched off that to make the client-side changes (`client`) and committed a few times.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Despues, vuelves a la rama original para hacer algunos cambios en la parte cliente (rama 'client'), y confirmas también esos cambios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You’ve learned about all sorts of configuration settings, file-based attributes, and event hooks, and you’ve built an example policy-enforcing server.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Has aprendido todo tipo de ajustes de configuración, atributos basados en archivos e incluso enganches (hooks). Y has preparado un ejemplo de servidor con mecanismos para asegurar políticas determinadas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You see how easy it is to take a Git repository, create a bare version, and place it on a server to which you and your collaborators have SSH access.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Como se vé, es sencillo crear un repositorio básico a partir de un repositorio Git, y ponerlo en un servidor donde tanto tú como tus colaboradores tengais acceso SSH.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg># Customizing Git #</seg>
      </tuv>
      <tuv lang="ES">
        <seg># Personalizando Git #</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Because Git is designed to work with nearly any type of project, these tools are pretty generic, but they can often help you hunt for a bug or culprit when things go wrong.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T164824Z" changeid="juan">
        <seg>Precisamente por estar Git diseñado para trabajar con casi cualquier tipo de proyecto, sus herramientas son bastante genéricas. Pero suelen ser de inestimable ayuda para cazar errores o las causas de los mismos cuando se detecta que algo va mal. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0522.png
Figure 5-22.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0522.png
Figura 5-22.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git checkout -b rack
	Switched to a new branch &quot;rack&quot;
	$ git submodule add git@github.com:schacon/rack.git rack
	Initialized empty Git repository in /opt/myproj/rack/.git/
	...
	Receiving objects: 100% (3184/3184), 677.42 KiB | 34 KiB/s, done.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T135316Z" changeid="juan">
        <seg>$ git checkout -b rack
	Switched to a new branch &quot;rack&quot;
	$ git submodule add git@github.com:schacon/rack.git rack
	Initialized empty Git repository in /opt/myproj/rack/.git/
	...
	Receiving objects: 100% (3184/3184), 677.42 KiB | 34 KiB/s, done.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It’s also probably the most difficult protocol to set up.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por otro lado, es también el protocolo más complicado de implementar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can override that by specifying the `+` in front of the refspec.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110815T221119Z" changeid="juan">
        <seg>Puedes forzarlo indicando el signo `+` delante de la referencia. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Total 3 (delta 1), reused 0 (delta 0)
	To git@gitserver:/opt/git/gitosis-admin.git
	   fb27aec..8962da8  master -&gt; master</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Total 3 (delta 1), reused 0 (delta 0)
	To git@gitserver:/opt/git/gitosis-admin.git
	   fb27aec..8962da8  master -&gt; master</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git update-index --add --cacheinfo 100644 \
	  83baae61804e65cc73a7201a7252750c76066a30 test.txt</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T180308Z" changeid="juan">
        <seg>$ git update-index --add --cacheinfo 100644 \
	  83baae61804e65cc73a7201a7252750c76066a30 test.txt</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now you’ll learn a few of the more interesting options that you can set in this manner to customize your Git usage.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Ahora vas a aprender un puñado de nuevas e interesantes opciones que puedes utilizar para personalizar el uso de Git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you want John to have only read access to this project, you can do this instead:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por ejemplo, si quieres que John tenga únicamente acceso de lectura sobre el proyecto, puedes hacer:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Figure 3-11 illustrates the result.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Figura 3-11 muestra el resultado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you’re a Windows programmer doing a Windows-only project, then you can turn off this functionality, recording the carriage returns in the repository by setting the config value to `false`:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si eres un programador Windows, trabajando en un entorno donde solo haya máquinas Windows, puedes desconectar esta funcionalidad. Para almacenar CRLFs en el repositorio. Ajustando el parámero a 'false':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This basically asks Git to resolve a range of commits that are reachable from one commit but aren’t reachable from another.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T090251Z" changeid="juan">
        <seg>Básicamente, se trata de pedir a Git que resuelva un rango de confirmaciones de cambio alcanzables desde una confirmación determinada, pero no desde otra.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git config --global merge.tool kdiff3</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git config --global merge.tool kdiff3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To pull in the changes and prepopulate the commit message, use the `--squash` and `--no-commit` options as well as the `-s subtree` strategy option:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T163422Z" changeid="juan">
        <seg>Para recuperar los cambios y rellenar el mensaje de la confirmación, se pueden emplear las opciones `--squash` y `--no-commit`, junto con la opción de estrategia `-s subtree`: </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Enter file in which to save the key (/Users/schacon/.ssh/id_rsa):
	Enter passphrase (empty for no passphrase):
	Enter same passphrase again:
	Your identification has been saved in /Users/schacon/.ssh/id_rsa.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Enter file in which to save the key (/Users/schacon/.ssh/id_rsa):
	Enter passphrase (empty for no passphrase):
	Enter same passphrase again:
	Your identification has been saved in /Users/schacon/.ssh/id_rsa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Therefore, the preferred method for collaborating with someone is to set up an intermediate repository that you both have access to, and push to and pull from that.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En este sentido, el método más recomendable para colaborar con otra persona es preparar un repositorio intermedio donde ambos tengais acceso, enviando (push) y recibiendo (pull) a o desde allí.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>But enforcing this with a hook will work in older versions of Git, and you can modify it to do so only for certain users or whatever else you come up with later.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Pero haciendolo a través de un enganche (hook), podrá funcionar también en versiones anteriores de Git, podrás modificarlo para que actue únicamente sobre ciertos usuarios, o podrás realizar cualquier otra acción que estimes oportuna.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you want to see the fifth prior value of the HEAD of your repository, you can use the `@{n}` reference that you see in the reflog output:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T102343Z" changeid="juan">
        <seg>Por ejemplo, si se desea ver el quinto anterior valor de HEAD en el repositorio, se puede emplear la referencia '@{n}' mostrada por la salida de reflog:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If the book spontaneously
	+Let's see if this works.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>If the book spontaneously
	+Let's see if this works.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Then you can add the submodule:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T172739Z" changeid="juan">
        <seg>Después, Git permitirá la adicción del submódulo sin problemas:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Contributors don’t have to wait for the project to incorporate their changes — each party can work at their own pace.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Las personas colaboradoras no tienen por qué esperar a que sus cambios sean incorporados al proyecto, --cada cual puede trabajar a su propio ritmo--.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In Git, this is called _rebasing_.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto es lo que en Git llamamos _reorganizar_.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git tells you the original commit where you wrote those lines, even if it was in another file.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T165345Z" changeid="juan">
        <seg>Git suele indicar la confirmación de cambios original donde se escribieron las líneas, incluso si estas fueron escritas originalmente en otro archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## Packfiles ##</seg>
      </tuv>
      <tuv lang="ES" changedate="20110810T225803Z" changeid="juan">
        <seg>## Archivos empaquetadores ##</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>=&gt; GET objects/info/http-alternates
	(empty file)</seg>
      </tuv>
      <tuv lang="ES" changedate="20110817T223607Z" changeid="juan">
        <seg>=&gt; GET objects/info/http-alternates
	(empty file)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Because a branch in Git is in actuality a simple file that contains the 40 character SHA-1 checksum of the commit it points to, branches are cheap to create and destroy.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Debido a que una rama Git es realmente un simple archivo que contiene los 40 caracteres de una suma de control SHA-1, (representando la confirmación de cambios a la que apunta), no cuesta nada el crear y destruir ramas en Git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Some of these settings can also be specified for a path, so that Git applies those settings only for a subdirectory or subset of files.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Algunos de los ajustes que hemos vistos, pueden ser especificados para un camino (path) concreto, de tal forma que Git los aplicará unicamente para una carpeta o para un grupo de archivos determinado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>There is no canonical version of any project, which allows a project to move from one user to another seamlessly if the first author abandons the project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>No existe una versión canónica de ningún proyecto, lo que permite a cualquiera de ellos ser movido facilmente de un usuario a otro en el caso de que el primer autor lo abandone.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>GitHub is also a commercial company that charges for accounts that maintain private repositories, but anyone can quickly get a free account to host as many open source projects as they want.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>GitHub es también una compañia comercial, que cobra por las cuentas que tienen repositorios privados. Pero, para albergar proyectos públicos de código abierto, cualquiera puede crear una cuenta gratuita.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Working locally and having someone push to your remote server makes each history move forward differently.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Trabajando localmente y que otra persona esté llevando (push) algo al servidor remoto, hace que cada registro avance de forma distinta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can throw away the original `iss91` branch (losing commits C5 and C6) and merge in the other two.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes descartar la rama 'iss91' (perdiendo las confirmaciones C5 y C6), y fusionar las otras dos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For public, unauthenticated read access to your projects, you’ll want to move past the HTTP protocol and start using the Git protocol.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para dar a tus proyectos un acceso público, sin autentificar, de solo lectura, querrás ir más allá del protocolo HTTP y comenzar a utilizar el protocolo Git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The pros of file-based repositories are that they’re simple and they use existing file permissions and network access.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Las ventajas de los repositorios basados en carpetas y archivos, son su simplicicidad y el aprovechamiento de los permisos preexistentes de acceso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>[group mobile]
	writable = iphone_project
	members = scott</seg>
      </tuv>
      <tuv lang="ES">
        <seg>[group mobile]
	writable = iphone_project
	members = scott</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You have to do this every time you pull down a submodule change in the main project.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T171743Z" changeid="juan">
        <seg>Se necesita realizar este paso cada vez que se recupere (pull) un cambio del submódulo en el proyecto padre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You may want to dog-ear this page, because you’ll need that command, and you’ll likely forget the syntax.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes grabarte a fuego esta página, porque necesitarás ese comando y, lo más probable es que hayas olvidado su sintaxis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The manual page for `git config` lists all the available options in quite a bit of detail.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La página de manual sobre 'git config' contiene una lista bastante detallada de todas las opciones disponibles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you change pick to edit on more lines, you can repeat these steps for each commit you change to edit.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120728T090152Z" changeid="juan">
        <seg>Si se ha cambiado 'pick' por 'edit' en más de una línea, estos pasos se habrán de repetir por cada una de las confirmaciones de cambios a modificar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>With the interactive rebase tool, you can then stop after each commit you want to modify and change the message, add files, or do whatever you wish.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120728T082524Z" changeid="juan">
        <seg>Dentro de la herramienta de reorganización interactiva, es posible detenerse justo tras cada confirmación de cambios a modificar. Para cambiar su mensaje, añadir archivos, o cualquier otra modificación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can reapply the one you just stashed by using the command shown in the help output of the original stash command: `git stash apply`.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120702T085834Z" changeid="juan">
        <seg>Con el comando 'git stash apply', tal y como se indica en la salida del comando stash original, se pueden volver a aplicar los últimos cambios recien guardados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Because the server-side method looks at the log of commits, and, at this point, the commit hasn’t been recorded yet, you must get your file listing from the staging area instead.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Debido a que el metodo del lado servidor utiliza el registro de confirmaciones de cambio, pero, sin embargo, aquí la confirmación no se ha registrado aún, la lista de archivos se ha de obtener desde el área de preparación (staging area).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If everything is cool, it fires up the `upload-pack` process and hands off the request to it.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T132309Z" changeid="juan">
        <seg>Siendo todo correcto, el demonio lanzará el proceso `upload-pack` y procesara nuestra petición. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Next, you want to make sure you aren’t modifying files that are outside your ACL scope.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>A continuación, se necesita también asegurarse de no estar modificando archivos fuera del alcance de tus permisos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you receive a patch over e-mail that you need to integrate into your project, you need to apply the patch in your topic branch to evaluate it.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si vas a integrar en tu proyecto un parche recibido a través de un correo electrónico. Antes de poder evaluarlo, tendrás que incorporarlo a una de tus ramas puntuales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ find .git/objects -type f
	.git/objects/01/55eb4229851634a0f03eb265b69f5a2d56f341 # tree 2
	.git/objects/1a/410efbd13591db07496601ebc7a059dd55cfe9 # commit 3
	.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a # test.txt v2
	.git/objects/3c/4e9cd789d88d8d89c1073707c3585e41b0e614 # tree 3
	.git/objects/83/baae61804e65cc73a7201a7252750c76066a30 # test.txt v1
	.git/objects/ca/c0cab538b970a37ea1e769cbbde608743bc96d # commit 2
	.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4 # 'test content'
	.git/objects/d8/329fc1cc938780ffdd9f94e0d364e0ea74f579 # tree 1
	.git/objects/fa/49b077972391ad58037050f2a75f74e3671e92 # new.txt
	.git/objects/fd/f4fc3344e67ab068f836878b6c4951e3b15f3d # commit 1</seg>
      </tuv>
      <tuv lang="ES" changedate="20110807T153512Z" changeid="juan">
        <seg>$ find .git/objects -type f
	.git/objects/01/55eb4229851634a0f03eb265b69f5a2d56f341 # tree 2
	.git/objects/1a/410efbd13591db07496601ebc7a059dd55cfe9 # commit 3
	.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a # test.txt v2
	.git/objects/3c/4e9cd789d88d8d89c1073707c3585e41b0e614 # tree 3
	.git/objects/83/baae61804e65cc73a7201a7252750c76066a30 # test.txt v1
	.git/objects/ca/c0cab538b970a37ea1e769cbbde608743bc96d # commit 2
	.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4 # 'test content'
	.git/objects/d8/329fc1cc938780ffdd9f94e0d364e0ea74f579 # tree 1
	.git/objects/fa/49b077972391ad58037050f2a75f74e3671e92 # new.txt
	.git/objects/fd/f4fc3344e67ab068f836878b6c4951e3b15f3d # commit 1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Because you never added them to any commits, they’re considered dangling and aren’t packed up in your new packfile.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T114213Z" changeid="juan">
        <seg>Porque nunca los has llegado a incluir en ninguna confirmación de cambios, no se han considerado como objetos definitivos y, por tanto, no han sido empaquetados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git comes with a couple of scripts that make some command-line tasks easier.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T091354Z" changeid="juan">
        <seg>Git trae incluidos unos cuantos scripts para facilitar algunas de las tareas en la línea de comandos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>removed invalid default value</seg>
      </tuv>
      <tuv lang="ES">
        <seg>removed invalid default value</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Before you start looking at the specific use cases, here’s a quick note about commit messages.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Antes de comenzar a revisar casos de uso específicos, vamos a dar una pincelada sobre los mensajes en las confirmaciones de cambios (commits).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now you can set up your config file to use your custom merge resolution and diff tools.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Una vez preparado todo esto, puedes ajustar el archivo de configuración para utilizar tus herramientas personalizadas de comparación y resolución de conflictos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you’re serving a lot of traffic for a public project or serving a very large project that doesn’t require user authentication for read access, it’s likely that you’ll want to set up a Git daemon to serve your project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si has de servir mucho tráfico de un proyecto público o servir un proyecto muy grande, que no requiera autentificación para leer de él, un demonio Git es la respuesta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you do some work on your local master branch, and, in the meantime, someone else pushes to `git.ourcompany.com` and updates its master branch, then your histories move forward differently.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si haces algún trabajo en tu rama 'master' local. Y, al mismo tiempo, alguna otra persona lleva (push) su trabajo al servidor 'git.ourcompany.com', actualizando la rama 'master' de allí. Te encontrarás con que ambos registros avanzan de forma diferente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The dictator merges the lieutenants’ master branches into the dictator’s master branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El dictador fusiona las ramas master de los tenientes en su propia rama master.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you want Git to try a bit more intelligently to resolve the conflict, you can pass a `-3` option to it, which makes Git attempt a three-way merge.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si deseas más inteligencia por parte de Git al resolver conflictos, puedes pasarle la opción '-3', para que intente una fusión a tres bandas (three-way merge).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You’re also unlikely to want to have hundreds of remotes, each for someone who contributes only a patch or two.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>También es muy posible que no quieras tener cientos de remotos, cada uno contribuyendo tan solo con un parche o dos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>back to this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>de vuelta a:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now you can stage and commit files until you have several commits, and run `git rebase --continue` when you’re done:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T190445Z" changeid="juan">
        <seg>Para, seguidamente, elaborar tantas confirmaciones de cambios como se desee, a base de pasar archivos al área de preparación y confirmarlos. Y, finalmente, teclear el comando `git rebase --continue` para completar la tarea. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The `--index-filter` option is similar to the `--tree-filter` option used in Chapter 6, except that instead of passing a command that modifies files checked out on disk, you’re modifying your staging area or index each time.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T135149Z" changeid="juan">
        <seg>La opción `--index-filter` es similar a la `--tree-filter` vista en el capítulo 6. Se diferencia porque, en lugar de modificar archivos activados (checked out) en el disco, se modifica el área de preparación (staging area) o índice.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Gitosis has simple access controls as well.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Gitosis permite también sencillos controles de acceso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Writing objects: 100% (21/21), done.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T104825Z" changeid="juan">
        <seg>Writing objects: 100% (21/21), done.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0323.png
Figure 3-23.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0323.png
Figura 3-23.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>HEAD@{1}: merge phedders/rdocs: Merge made by recursive.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T102022Z" changeid="juan">
        <seg>HEAD@{1}: merge phedders/rdocs: Merge made by recursive.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you create a new branch, add a submodule there, and then switch back to a branch without that submodule, you still have the submodule directory as an untracked directory:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T172523Z" changeid="juan">
        <seg>Si se crea una rama, se añade un submódulo en ella y luego se retorna a una rama donde dicho submódulo no exista. La carpeta del submódulo sigue existiendo, solo que ahora queda como una carpeta sin seguimiento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When all the work in your topic branch is ready to be integrated into a more mainline branch, the question is how to do it.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cuando todo el trabajo presente en tu rama puntual esté listo para ser integrado en una rama de mayor rango, la cuestión es cómo hacerlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>fetch = +refs/heads/master:refs/remotes/origin/master</seg>
      </tuv>
      <tuv lang="ES" changedate="20110815T220553Z" changeid="juan">
        <seg>fetch = +refs/heads/master:refs/remotes/origin/master</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git apply --whitespace=fix &lt;patch&gt;</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git apply --whitespace=fix &lt;patch&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>initctl start local-git-daemon</seg>
      </tuv>
      <tuv lang="ES">
        <seg>initctl start local-git-daemon</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0402.png
Figure 4-2.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0402.png
Figura 4-2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Staging and Unstaging Files ###</seg>
      </tuv>
      <tuv lang="ES" changedate="20120712T201450Z" changeid="juan">
        <seg>### Introduciendo archivos en el area de preparación y sacandolos de ella ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0318.png
Figure 3-18.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0318.png
Figura 3-18.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Regular developers work on their topic branch and rebase their work on top of master.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Los desarrolladores habituales trabajan cada uno en su rama puntual y reorganizan (rebase) su trabajo sobre la rama master.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>These tools are very helpful if you modify a bunch of files and then decide that you want those changes to be in several focused commits rather than one big messy commit.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T091856Z" changeid="juan">
        <seg>Estas herramientas son útiles, por ejemplo, cuando se modifican unos cuantos archivos y luego se decide almacenar esos cambios en una serie de confirmaciones de cambio focalizadas en lugar de en una sola confirmación de cambio entremezclada.   </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Name this remote `teamone`, which will be your shortname for that whole URL (see Figure 3-25).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes denominar 'teamone' a este remoto, poniendo este nombre abreviado para la URL (ver Figura 3-25)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git log master..experiment
	D
	C</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T120455Z" changeid="juan">
        <seg>$ git log master..experiment
	D
	C</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When new work is introduced by contributors, it’s collected into topic branches in the maintainer’s repository in a manner similar to what I’ve described (see Figure 5-24).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>A medida que vamos introduciendo nuevos trabajos de las personas colaboradoras, estos se van recolectando en ramas puntuales en el repositorio de una persona gestora; de forma similar a como se ha ido describiendo (ver Figura 5-24).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you leave off the `[localbranch]` portion, then you’re basically saying, “Take nothing on my side and make it be `[remotebranch]`.”</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si omites la parte '[ramalocal]', lo que estás diciendo es: &quot;no cojas nada de mi lado y haz con ello [ramaremota]&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you rebase commits that you’ve already pushed and then try to push again, or otherwise try to push a commit to a remote branch that doesn’t contain the commit that the remote branch currently points to, you’ll be denied.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si reorganizas (rebase) confirmaciones de cambio (commit) que ya habias enviado y tratas de enviarlas (push) de nuevo. O si intentas enviar una confirmación a una rama remota que no contiene la confirmación actualmente apuntada por la rama. Normalmente, la operación te será denegada por la rama remota sobre la que pretendias realizarla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This can consist of accepting and applying patches generated via `format-patch` and e-mailed to you, or integrating changes in remote branches for repositories you’ve added as remotes to your project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Lo cual implicará saber aceptar y aplicar parches generados vía `format-patch`, enviados a tí a través de correo-e; o saber integrar cambios realizados en ramas de repositorios que añadirás como remotos a tu proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git sends a line for each reference you’re updating with the old SHA, the new SHA, and the reference that is being updated.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T132050Z" changeid="juan">
        <seg>Git envia una linea por cada referencia a actualizar, indicando el viejo SHA, el nuevo SHA y la referencia a actualizar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you want to be more specific about which commands are colored and how, or you have an older version, Git provides verb-specific coloring settings.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cuando quieras ajustar específicamente, comando a comando, donde colorear y cómo colorear, (o cuando tengas una versión antigua de Git), puedes emplear los ajustes particulares de color.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you were deleting a reference, you would see the opposite: all '0's on the right side.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T074642Z" changeid="juan">
        <seg>Si estuvieras borrando una referencia existente, verias lo contrario: una clave todo '0's en el lado derecho.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>At this point, you should be able to do most of the things in Git that you’ll need on the command line day to day and feel comfortable doing so.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T164511Z" changeid="juan">
        <seg>En este punto, deberiamos ser capaces de realizar la mayoria de las acciones necesarias en el día a día con Git; realizandolas de manera confortable y segura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>added cat-file</seg>
      </tuv>
      <tuv lang="ES" changedate="20120728T092016Z" changeid="juan">
        <seg>added cat-file</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can create as many of these groups as you want, each containing different users and projects.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes crear tantos grupos como desees, para diferentes usuarios y proyectos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In the last few years, the UI has been refined until it’s as clean and easy to use as any system out there; but often, the stereotype lingers about the early Git UI that was complex and difficult to learn.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En los últimos años, el IU se ha refinado hasta llegar a ser tan limpio y sencillo de usar como el de cualquier otro sistema; pero frecuentemente, el estereotipo sigue mostrando a Git como complejo y dificil de aprender. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you changed the same part of the same file differently in the two branches you’re merging together, Git won’t be able to merge them cleanly.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si hay modificaciones dispares en una misma porción de un mismo archivo en las dos ramas distintas que pretendes fusionar, Git no será capaz de fusionarlas directamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Suppose you want to add the Rack library (a Ruby web server gateway interface) to your project, possibly maintain your own changes to it, but continue to merge in upstream changes.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T170608Z" changeid="juan">
        <seg>Suponiendo, por ejemplo, que se desea añadir la biblioteca Rack (un interface Ruby de pasarela de servidor web) al proyecto en que se está trabajando. Posiblemente con algunas personalizaciones, pero sin perder la capacidad de fusionar nuestros cambios con la evolución de la biblioteca original.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git am 0001-seeing-if-this-helps-the-gem.patch
	Applying: seeing if this helps the gem
	error: patch failed: ticgit.gemspec:1
	error: ticgit.gemspec: patch does not apply
	Patch failed at 0001.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git am 0001-seeing-if-this-helps-the-gem.patch
	Applying: seeing if this helps the gem
	error: patch failed: ticgit.gemspec:1
	error: ticgit.gemspec: patch does not apply
	Patch failed at 0001.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The maintainer adds the contributor’s repo as a remote and merges locally.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La gestora añade como remoto el repositorio de la colaboradora y fusiona (merge) los cambios localmente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0518.png
Figure 5-18.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0518.png
Figura 5-18.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ sudo adduser git
	$ su git
	$ cd
	$ mkdir .ssh</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ sudo adduser git
	$ su git
	$ cd
	$ mkdir .ssh</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>4.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>4.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can also use git apply to see if a patch applies cleanly before you try actually applying it — you can run `git apply --check` with the patch:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tambien puedes utilizar 'git apply' para comprobar si un parche se puede incorporar limpiamente; antes de intentar incorporarlo. Puedes lanzar el comando 'git apply --check':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You branched a topic branch (`server`) to add some server-side functionality to your project, and made a commit.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Has ramificado a una rama puntual ('server') para añadir algunas funcionalidades al proyecto, y luego has confirmado los cambios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg># Jessica's Machine
	$ git clone jessica@githost:simplegit.git
	Initialized empty Git repository in /home/jessica/simplegit/.git/
	...
	$ cd simplegit/
	$ vim TODO
	$ git commit -am 'add reset task'
	[master fbff5bc] add reset task
	 1 files changed, 1 insertions(+), 0 deletions(-)</seg>
      </tuv>
      <tuv lang="ES">
        <seg># Jessica's Machine
	$ git clone jessica@githost:simplegit.git
	Initialized empty Git repository in /home/jessica/simplegit/.git/
	...
	$ cd simplegit/
	$ vim TODO
	$ git commit -am 'add reset task'
	[master fbff5bc] add reset task
	 1 files changed, 1 insertions(+), 0 deletions(-)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To see which branches are already merged into the branch you’re on, you can run `git branch –merged`:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si deseas ver las ramas que han sido fusionadas en la rama activa, puedes lanzar el comando 'git branch --merged':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The status of the simplegit.rb file is interesting.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T214527Z" changeid="juan">
        <seg>La línea correspondiente al estado del archivo simplegit.rb es bastante interesante.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You have to shell onto the server each time, and there is no access control — everyone in the file has read and write access to every project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tienes que iniciar sesión en el servidor cada vez. Y, ademas, no tienes control de acceso --todo el mundo presente en el archivo tiene permisos de lectura y escritura a todos y cada uno de los proyectos--.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>First, you’ll use this technique to solve one of the most annoying problems known to humanity: version-controlling Word documents.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En el primero de ellos, utilizarás esta técnica para resolver uno de los problemas más engorrosos conocidos por la humanidad: el control de versiones en documentos Word.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>def log(treeish = 'master')
	-    command(&quot;git log -n 25 #{treeish}&quot;)
	+    command(&quot;git log -n 30 #{treeish}&quot;)
	   end</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T214044Z" changeid="juan">
        <seg>def log(treeish = 'master')
	-    command(&quot;git log -n 25 #{treeish}&quot;)
	+    command(&quot;git log -n 30 #{treeish}&quot;)
	   end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>3.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>GitHub project header information.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Información de cabecera de un proyecto GitHub.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is basically the `git log` command, but by default it prints out only the SHA-1 values and no other information.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Este comando es básicamente el mismo que 'git log', pero por defecto, imprime solo los valores SHA-1 y nada más.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Basic Merge Conflicts ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Principales conflictos que pueden surgir en las fusiones ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To get a reference that isn’t a fast-forward, you either have to rebase past a commit you’ve already pushed up or try pushing a different local branch up to the same remote branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para tener una referencia que no sea de avance-rápido, tienes que haber reorganizado (rebase) una confirmación de cambios (commit) ya enviada anteriormente, o tienes que estar tratando de enviar una rama local distinta sobre la misma rama remota.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Check the tree created by that commit, and you see something interesting:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110810T230607Z" changeid="juan">
        <seg>Revisando el árbol creado por esta última confirmación de cambios, verás algo interesante:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## Remote Branches ##</seg>
      </tuv>
      <tuv lang="ES">
        <seg>## Ramas Remotas ## </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>`experiment..master` shows you everything in `master` not reachable from `experiment`:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T120641Z" changeid="juan">
        <seg>`experiment..master` muestra todo lo que haya en 'master' pero que no es alcanzable desde 'experiment':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Centralized workflow.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Flujo de trabajo centralizado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git clone git://github.com/schacon/myproject.git
	Initialized empty Git repository in /opt/myproject/.git/
	remote: Counting objects: 6, done.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T105618Z" changeid="juan">
        <seg>$ git clone git://github.com/schacon/myproject.git
	Initialized empty Git repository in /opt/myproject/.git/
	remote: Counting objects: 6, done.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>All the examples are written as shell scripts, with some Perl thrown in, but any properly named executable scripts will work fine — you can write them in Ruby or Python or what have you.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Todos los ejemplos se han escrito como scripts de shell, con algo de código Perl embebido en ellos. Pero cualquier tipo de script ejecutable que tenga el nombre adecuado puede servir igual de bien --los puedes escribir en Ruby o en Python o en cualquier lenguaje de scripting con el que trabajes--.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To switch to an existing branch, you run the `git checkout` command.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para saltar de una rama a otra, tienes que utilizar el comando 'git checkout'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Because the commit pointed to by the branch you merged in was directly upstream of the commit you’re on, Git moves the pointer forward.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Git ha movido el apuntador hacia adelante, ya que la confirmación apuntada en la rama donde has fusionado estaba directamente &quot;aguas arriba&quot; respecto de la confirmación actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Clone a repository, and base some work on it.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Clonar un repositorio y trabajar sobre él.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You’ll likely need to change that to whatever your stable, published branch is.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si lo vas a utilizar, tendrás que modificarlo para que se ajuste al nombre que tenga tu rama publicada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>2.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In this case, you had a clean working directory when you tried to apply the stash, and you tried to apply it on the same branch you saved it from; but having a clean working directory and applying it on the same branch aren’t necessary to successfully apply a stash.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120712T205350Z" changeid="juan">
        <seg>En este ejemplo se han aplicado los cambios de vuelta sobre un espacio de trabajo limpio, en la misma rama. Pero no es esta la única situación en la que se pueden reaplicar cambios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The contributor sends the maintainer an e-mail asking them to pull changes.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esta persona colaboradora envia a la gestora un correo-e solicitándole recupere e integre los cambios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git reset --hard 1a410efbd13591db07496601ebc7a059dd55cfe9
	HEAD is now at 1a410ef third commit
	$ git log --pretty=oneline
	1a410efbd13591db07496601ebc7a059dd55cfe9 third commit
	cac0cab538b970a37ea1e769cbbde608743bc96d second commit
	fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T141630Z" changeid="juan">
        <seg>$ git reset --hard 1a410efbd13591db07496601ebc7a059dd55cfe9
	HEAD is now at 1a410ef third commit
	$ git log --pretty=oneline
	1a410efbd13591db07496601ebc7a059dd55cfe9 third commit
	cac0cab538b970a37ea1e769cbbde608743bc96d second commit
	fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It’s used to pull in topic branches (short-lived branches, like your earlier `iss53` branch) when they’re ready, to make sure they pass all the tests and don’t introduce bugs.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>También es habitual el incorporarle (pull) ramas puntuales (ramas temporales, como la rama 'iss53' del anterior ejemplo) cuando las completamos y estamos seguros de que no van a introducir errores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Notice the 160000 mode for the rack entry.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T105021Z" changeid="juan">
        <seg>Notese el modo 160000 para la entrada `rack`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Writing objects: 100% (3/3), 272 bytes, done.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Writing objects: 100% (3/3), 272 bytes, done.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>[master*]$ git status
	index.html: needs merge
	# On branch master
	# Changed but not updated:
	#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
	#   (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)
	#
	#	unmerged:   index.html
	#</seg>
      </tuv>
      <tuv lang="ES">
        <seg>[master*]$ git status
	index.html: needs merge
	# On branch master
	# Changed but not updated:
	#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
	#   (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)
	#
	#	unmerged:   index.html
	#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The output for this command is a little confusing.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El resultado de este comando es un poco confuso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To restore the original branch and stop patching run &quot;git am --abort&quot;.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>To restore the original branch and stop patching run &quot;git am --abort&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ curl http://github.com/mojombo/grit/raw/master/lib/grit/repo.rb &gt; repo.rb
	$ git add repo.rb
	$ git commit -m 'added repo.rb'
	[master 484a592] added repo.rb
	 3 files changed, 459 insertions(+), 2 deletions(-)
	 delete mode 100644 bak/test.txt
	 create mode 100644 repo.rb
	 rewrite test.txt (100%)</seg>
      </tuv>
      <tuv lang="ES" changedate="20110810T230215Z" changeid="juan">
        <seg>$ curl http://github.com/mojombo/grit/raw/master/lib/grit/repo.rb &gt; repo.rb
	$ git add repo.rb
	$ git commit -m 'added repo.rb'
	[master 484a592] added repo.rb
	 3 files changed, 459 insertions(+), 2 deletions(-)
	 delete mode 100644 bak/test.txt
	 create mode 100644 repo.rb
	 rewrite test.txt (100%)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Topic branches, however, are useful in projects of any size.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Las ramas puntuales, en cambio, son útiles en proyectos de cualquier tamaño.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>That is probably the simplest workflow, but it’s problematic if you’re dealing with larger repositories or projects.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Este es probablemente el flujo de trabajo más sencillo. Pero puede dar problemas cuando estás tratando con grandes repositorios o grandes proyectos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>As discussed in Chapter 2, there are two types of tags: annotated and lightweight.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T233921Z" changeid="juan">
        <seg>Tal y como se ha comentado en el capítulo 2, hay dos tipos de etiquetas: las anotativas y las ligeras.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>diff --git a/image.png b/image.png
	index 88839c4..4afcb7c 100644
	--- a/image.png
	+++ b/image.png
	@@ -1,12 +1,12 @@
	 ExifTool Version Number         : 7.74
	-File Size                       : 70 kB
	-File Modification Date/Time     : 2009:04:21 07:02:45-07:00
	+File Size                       : 94 kB
	+File Modification Date/Time     : 2009:04:21 07:02:43-07:00
	 File Type                       : PNG
	 MIME Type                       : image/png
	-Image Width                     : 1058
	-Image Height                    : 889
	+Image Width                     : 1056
	+Image Height                    : 827
	 Bit Depth                       : 8
	 Color Type                      : RGB with Alpha</seg>
      </tuv>
      <tuv lang="ES">
        <seg>diff --git a/image.png b/image.png
	index 88839c4..4afcb7c 100644
	--- a/image.png
	+++ b/image.png
	@@ -1,12 +1,12 @@
	 ExifTool Version Number         : 7.74
	-File Size                       : 70 kB
	-File Modification Date/Time     : 2009:04:21 07:02:45-07:00
	+File Size                       : 94 kB
	+File Modification Date/Time     : 2009:04:21 07:02:43-07:00
	 File Type                       : PNG
	 MIME Type                       : image/png
	-Image Width                     : 1058
	-Image Height                    : 889
	+Image Width                     : 1056
	+Image Height                    : 827
	 Bit Depth                       : 8
	 Color Type                      : RGB with Alpha</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>However, it’s an interesting exercise and can in theory help you avoid a rebase that you might later have to go back and fix.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>De todas formas, es un ejercicio interesante. Y, en teoria al menos, pude ayudarte a evitar reorganizaciones que luego tengas de hechar para atras y arreglarlas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>1.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The sequence for the workflow you saw here is something like Figure 5-15.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La secuencia del flujo de trabajo que hemos visto es algo así como lo mostrado en la Figura 5-15.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git config --help</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git config --help</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Oops — you didn’t want to add a huge tarball to your project.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T134712Z" changeid="juan">
        <seg>!Ouch!, --no querias añadir un archivo tan grande a tu proyecto--.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ cp /tmp/id_rsa.john.pub keydir/john.pub
	$ cp /tmp/id_rsa.josie.pub keydir/josie.pub
	$ cp /tmp/id_rsa.jessica.pub keydir/jessica.pub</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ cp /tmp/id_rsa.john.pub keydir/john.pub
	$ cp /tmp/id_rsa.josie.pub keydir/josie.pub
	$ cp /tmp/id_rsa.jessica.pub keydir/jessica.pub</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Although tons of options are available, I’ll only cover the few that either are commonly used or can significantly affect your workflow.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Aunque hay multitud de ellas, aquí vamos a ver solamente unas pocas. Las mas comunmente utilizadas o las que afectan significativamente a tu forma de trabajar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>But it’s possible that the patch won’t apply cleanly.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Pero también podría suceder que el parche no se pudiera incorporar limpiamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0601.png
Figure 6-1.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T115755Z" changeid="juan">
        <seg>Insert 18333fig0601.png
Figura 6-1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If the QA team wants to push their `master` branch to `qa/master` on the remote server, they can run</seg>
      </tuv>
      <tuv lang="ES" changedate="20110817T153803Z" changeid="juan">
        <seg>Si alguien del equipo QA quiere enviar su rama  `master` a la ubicación `qa/master` en el servidor remoto, puede lanzar algo asi como: </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Because it generally uses a static HTTP server to serve all the data, a normal Apache server can serve thousands of files per second on average — it’s difficult to overload even a small server.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por utilizar normalmente un servidor HTTP estático, un servidor Apache estandar puede con un tráfico de miles de archivos por segundo; siendo dificil de sobrecargar incluso con el más pequeño de los servidores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Let’s make a few changes and commit again:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Haz algunos cambios más y confirmalos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If your contribution came from a Git user who set up their own repository, pushed a number of changes into it, and then sent you the URL to the repository and the name of the remote branch the changes are in, you can add them as a remote and do merges locally.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si recibes una contribución de un usuario que ha preparado su propio repositorio, ha guardado unos cuantos cambios en este, y luego te ha enviado la URL del repositorio y el nombre de la rama remota donde se encuentran los cambios. Puedes añadir dicho repositorio como un remoto y fusionar los cambios localmente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0322.png
Figure 3-22.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0322.png
Figura 3-22.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>A number of options can help you set the coloring to your preference.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Hay unos cuantos parámetros que te pueden ayudar a configurar tus colores favoritos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The blob is now a different blob, which means that although you added only a single line to the end of a 400-line file, Git stored that new content as a completely new object:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T113246Z" changeid="juan">
        <seg>El objeto binario es ahora un binario completamente diferente. Aunque solo has añadido una única línea al final de un archivo que ya contenia 400 líneas, Git ha almacenado el resultado como un objeto completamente nuevo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The number of randomly hashed objects needed to ensure a 50% probability of a single collision is about 2^80 (the formula for determining collision probability is `p = (n(n-1)/2) * (1/2^160))`.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T185748Z" changeid="juan">
        <seg>El número de objetos, codificados aleatóriamente, necesarios para asegurar un 50% de probabilidad de darse una sola colisión es cercano a 2^80 (la fórmula para determinar la probabilidad de colisión es `p = (n(n-1)/2) * (1/2^160))`).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You’ll also need to set the Unix user group of the `/opt/git` directories to `www-data` so your web server can read-access the repositories, because the Apache instance running the CGI script will (by default) be running as that user:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Asimismo, has de ajustar el grupo Unix de las carpetas bajo '/opt/git' a 'www-data', para que tu servidor web tenga acceso de lectura a los repositorios contenidos en ellas; porque la instancia de Apache que maneja los scripts CGI trabaja bajo dicho usuario:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The benevolent dictator’s repository serves as the reference repository from which all the collaborators need to pull.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El repositorio del dictador benevolente es el repositorio de referencia, del que recuperan (pull) todos los colaboradores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can enforce policy on the server side to reject pushes of commits that don’t conform to some policy, but it’s entirely up to the developer to use these scripts on the client side.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes implantar reglas en el lado servidor para rechazar envios (push) que no cumplan ciertos estandares, pero es completamente voluntario para los desarroladores el utilizar scripts en el lado cliente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Let’s look at an example of how rebasing work that you’ve made public can cause problems.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Vamos a verlo con un ejemplo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Let’s say you’ve set up a server called `git.example.com` that you have SSH access to, and you want to store all your Git repositories under the `/opt/git` directory.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Supongamos que has preparado un servidor denominado 'git.example.com', con acceso SSH. Y que quieres guardar todos los repositorios Git bajo la carpeta '/opt/git'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>commit</seg>
      </tuv>
      <tuv lang="ES">
        <seg>commit</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For example, in the history listed earlier, `HEAD~3` would be</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T114621Z" changeid="juan">
        <seg>Por ejemplo, en la historia de proyecto citada anteriormente, `HEAD~3` sería: </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Log says:
	Sendmail: /usr/sbin/sendmail -i jessica@example.com
	From: Jessica Smith &lt;jessica@example.com&gt;
	To: jessica@example.com
	Subject: [PATCH 1/2] added limit to log function
	Date: Sat, 30 May 2009 13:29:15 -0700
	Message-Id: &lt;1243715356-61726-1-git-send-email-jessica@example.com&gt;
	X-Mailer: git-send-email 1.6.2.rc1.20.g8c5b.dirty
	In-Reply-To: &lt;y&gt;
	References: &lt;y&gt;</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Log says:
	Sendmail: /usr/sbin/sendmail -i jessica@example.com
	From: Jessica Smith &lt;jessica@example.com&gt;
	To: jessica@example.com
	Subject: [PATCH 1/2] added limit to log function
	Date: Sat, 30 May 2009 13:29:15 -0700
	Message-Id: &lt;1243715356-61726-1-git-send-email-jessica@example.com&gt;
	X-Mailer: git-send-email 1.6.2.rc1.20.g8c5b.dirty
	In-Reply-To: &lt;y&gt;
	References: &lt;y&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It shows you that the 'scott' user — the user with whose public key you initialized Gitosis — is the only one who has access to the `gitosis-admin` project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Indicando que el usuario 'scott' --el usuario con cuya clave pública se ha inicializado Gitosis-- es el único con acceso al proyecto 'gitosis-admin'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If there are none, then it was a fast-forward push; otherwise, you deny it:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si hay alguna, entonces es un envio de avance-rápido (fast-forward push); sino hay ninguna, es un envio a prohibir:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In this case, you have a couple of administrators, some documentation writers with access to the `doc` directory, and one developer who only has access to the `lib` and `tests` directories, and your ACL file looks like this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por ejemplo, si tienes un par de administradores, algunos redactores técnicos con acceso a la carpeta 'doc', y un desarrollador que únicamente accede a las carpetas 'lib' y 'test', el archivo ACL resultante seria:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg># [ insert acl_access_data method from above ]</seg>
      </tuv>
      <tuv lang="ES">
        <seg># [ insert acl_access_data method from above ]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You did a few commits on them and deleted them directly after merging them into your main branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Has hecho unas pocas confirmaciones de cambio en ellas, y luego las has borrado tras fusionarlas con la rama principal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In this section, you’ll cover how to accomplish these very useful tasks so that you can make your commit history look the way you want before you share it with others.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120728T075909Z" changeid="juan">
        <seg>En esta sección, se verá cómo realizar todas esas útiles tareas. De tal forma que se pueda dejar el historial de cambios exactamente tal y como se desee. Eso sí, siempre antes de compartirlo con otros desarrolladores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For now, you’ve committed all your changes, so you can switch back to your master branch:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por ahora, como tenemos confirmados todos los cambios, podemos saltar a la rama 'master' sin problemas:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Let’s see what it might look like when two developers start to work together with a shared repository.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Vamos a ver como actuarian dos desarrolladores trabajando conjuntamente en un repositorio compartido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You just switched back to your `master` branch, and you pull the `rack` branch into the `rack` subdirectory of your `master` branch of your main project:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T173445Z" changeid="juan">
        <seg>Con ello, se retorna sobre la rama `master` y se recupera (pull) la rama `rack_branch` en la subcarpeta `rack` de la rama `master` del proyecto principal: </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git diff-tree -p rack_branch</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T164023Z" changeid="juan">
        <seg>$ git diff-tree -p rack_branch</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>fixed refs handling, added gc auto, updated tests</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T095037Z" changeid="juan">
        <seg>fixed refs handling, added gc auto, updated tests</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### The Git Protocol ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### El Protocolo Git ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html
	&lt;div id=&quot;footer&quot;&gt;contact : email.support@github.com&lt;/div&gt;
	=======
	&lt;div id=&quot;footer&quot;&gt;
	  please contact us at support@github.com
	&lt;/div&gt;
	&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html</seg>
      </tuv>
      <tuv lang="ES">
        <seg>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html
	&lt;div id=&quot;footer&quot;&gt;contact : email.support@github.com&lt;/div&gt;
	=======
	&lt;div id=&quot;footer&quot;&gt;
	  please contact us at support@github.com
	&lt;/div&gt;
	&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You’ve partially staged this file.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T214655Z" changeid="juan">
        <seg>Es decir, se ha pasado parcialmente ese archivo al área de preparación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In either case, after `fetch-pack` connects, `upload-pack` sends back something like this:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T080102Z" changeid="juan">
        <seg>En cualquier caso, después de establecer conexión, `upload-pack` responderá: </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>After that come the line number and the content of the file.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120827T144235Z" changeid="juan">
        <seg>Detras, vienen el número de línea y el contendido de la línea propiamente dicha.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Total 19 (delta 3), reused 16 (delta 1)</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T134708Z" changeid="juan">
        <seg>Total 19 (delta 3), reused 16 (delta 1)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0404.png
Figure 4-4.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0404.png
Figura 4-4.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If a user SSHs into a server and has write access to the `/opt/git/my_project.git` directory, they will also automatically have push access.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y cualquier usuario SSH que tenga acceso de escritura a la carpeta '/opt/git/my_project.git', tendrá también automáticamente acceso de volcado (push).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you want to check out what GitWeb would look like for your project, Git comes with a command to fire up a temporary instance if you have a lightweight server on your system like `lighttpd` or `webrick`.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si quieres comprobar cómo podría quedar GitWeb con tu proyecto, Git dispone de un comando para activar una instancia temporal, si en tu sistema tienes un servidor web ligero, como por ejemplo 'lighttup' o 'webrick'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ find .git/refs
	.git/refs
	.git/refs/heads
	.git/refs/tags
	$ find .git/refs -type f
	$</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T190913Z" changeid="juan">
        <seg>$ find .git/refs
	.git/refs
	.git/refs/heads
	.git/refs/tags
	$ find .git/refs -type f
	$</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For instance, if you want to see all commits that are reachable from `refA` or `refB` but not from `refC`, you can type one of these:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T201845Z" changeid="juan">
        <seg>Por ejemplo, si se deseean ver todas las confirmaciones de cambio alcanzables desde la 'refA' o la 'refB', pero no desde la 'refC', se puede teclear algo como esto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Instead of writing your own Atom-generating code, you decide to use a library.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T170300Z" changeid="juan">
        <seg>En lugar de escribir código propio para generar los feeds Atom, se decide emplear una biblioteca ya existente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>first commit</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T180347Z" changeid="juan">
        <seg>first commit</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>[rejected]        master     -&gt; origin/mymaster  (non fast forward)
	 * [new branch]      topic      -&gt; origin/topic</seg>
      </tuv>
      <tuv lang="ES" changedate="20110815T221002Z" changeid="juan">
        <seg>[rejected]        master     -&gt; origin/mymaster  (non fast forward)
	 * [new branch]      topic      -&gt; origin/topic</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>However, in order to do any collaboration in Git, you’ll need to have a remote Git repository.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Pero, para poder colaborar, necesitarás tener un repositorio remoto de Git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git am -3 0001-seeing-if-this-helps-the-gem.patch
	Applying: seeing if this helps the gem
	error: patch failed: ticgit.gemspec:1
	error: ticgit.gemspec: patch does not apply
	Using index info to reconstruct a base tree...
	Falling back to patching base and 3-way merge...
	No changes -- Patch already applied.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git am -3 0001-seeing-if-this-helps-the-gem.patch
	Applying: seeing if this helps the gem
	error: patch failed: ticgit.gemspec:1
	error: ticgit.gemspec: patch does not apply
	Using index info to reconstruct a base tree...
	Falling back to patching base and 3-way merge...
	No changes -- Patch already applied.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>in the Git source code.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T234840Z" changeid="juan">
        <seg>lanzado sobre el código fuente de Git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0311.png
Figure 3-11.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0311.png
Figura 3-11.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## Generating Your SSH Public Key ##</seg>
      </tuv>
      <tuv lang="ES">
        <seg>## Generando tu clave pública SSH ##</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>With Git, you don’t have to deploy your fix along with the `iss53` changes you’ve made, and you don’t have to put a lot of effort into reverting those changes before you can work on applying your fix to what is in production.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Usando Git, no necesitas mezclar el nuevo problema con los cambios que ya habias realizado sobre el problema #53; ni tampoco perder tiempo revirtiendo esos cambios para poder trabajar sobre el contenido que está en producción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git moves them around as bookmarks to the last known state of where those branches were on those servers.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110810T225312Z" changeid="juan">
        <seg>Git las utiliza solamente como marcadores al último estado conocido de cada rama en cada servidor remoto declarado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>6.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>6.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git comes with a CGI script called GitWeb that is commonly used for this.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Git trae un script CGI, denominado GitWeb, que es el que usaremos para este propósito.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>[y]es/[n]o/[e]dit/[v]iew patch/[a]ccept all</seg>
      </tuv>
      <tuv lang="ES">
        <seg>[y]es/[n]o/[e]dit/[v]iew patch/[a]ccept all</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In order to initially set up any Git server, you have to export an existing repository into a new bare repository — a repository that doesn’t contain a working directory.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El primer paso para preparar un servidor Git, es exportar un repositorio existente a un nuevo repositorio básico, a un repositorio sin carpeta de trabajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now that your filter is ready, you can test it by setting up a file with your `$Date$` keyword and then setting up a Git attribute for that file that engages the new filter:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Una vez preparado el filtro, puedes comprobar su funcionamiento preparando un archivo que contenga la clave '$Date$' e indicando a Git cual es el atributo para reconocer ese tipo de archivo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Data Recovery ###</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T093106Z" changeid="juan">
        <seg>### Recuperación de datos ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In this case, two stashes were done previously, so you have access to three different stashed works.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120702T085603Z" changeid="juan">
        <seg>En este ejemplo, se habian realizado dos guardados rápidos anteriores, por lo que se ven tres grupos de cambios guardados en la pila.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In this case, when you commit files that match `*.c`, Git will run them through the indent program before it commits them and then run them through the `cat` program before it checks them back out onto disk.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En este ejemplo, cuando confirmes cambios (commit) en archivos con extensión '*.c', Git los pasará previamente a través del programa 'indent' antes de confirmarlos, y los pasará a través del programa 'cat' antes de extraerlos de vuelta al disco.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Furthermore, you want your collaborators to be able to access the repository even if your computer is offline — having a more reliable common repository is often useful.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Es más, si deseas que tus colaboradores puedan acceder a tu repositorio, incluso cuando tu ordenador este apagado, puede ser de gran utilidad disponer de un repositorio común fiable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It generally takes a lot longer to clone or fetch from the repository, and you often have a lot more network overhead and transfer volume over HTTP than with any of the other network protocols.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Suele requerir mucho más tiempo el clonar o el recuperar (fetch), debido a la mayor carga de procesamiento y  al mayor volumen de transferencia que se da sobre HTTP respecto de otros protocolos de red.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To get a diff between what you have in your `rack` subdirectory and the code in your `rack_branch` branch — to see if you need to merge them — you can’t use the normal `diff` command.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T173701Z" changeid="juan">
        <seg>Para ver las diferencias entre el contenido de la subcarpeta `rack` y el código en la rama `rack_branch` --para comprobar si es necesario fusionarlas--, no se puede emplear el comando `diff` habitual. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git cat-file -s 9bc1dc421dcd51b4ac296e3e5b6e2a99cf44391e
	12898</seg>
      </tuv>
      <tuv lang="ES" changedate="20110810T230342Z" changeid="juan">
        <seg>$ git cat-file -s 9bc1dc421dcd51b4ac296e3e5b6e2a99cf44391e
	12898</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If someone opens that tarball, they get the latest snapshot of your project under a project directory.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Quien abra ese archivo tarball, obtendrá la más reciente imagen de tu proyecto; puesta bajo una carpeta de proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can run the `count-objects` command to quickly see how much space you’re using:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T134744Z" changeid="juan">
        <seg>Puedes utilizar el comando `count-objects` para revisar rápidamente el espacio utilizado:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When you notice issues, you should be able to easily figure out what commit introduced them, when, and by whom.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T173835Z" changeid="juan">
        <seg>Cuando se detectan problemas, se necesita tener la capacidad de localizar facilmente la confirmación de cambios en que fueron introducidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>So, let’s change this line in your `/etc/passwd` file</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Así pues, cambia esta línea en tu archivo '/etc/passwd':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>5.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>5.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The original commit message for this functionality gives a simple example of running all your C source code through the `indent` program before committing.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El mensaje de confirmación para esta funcionalidad nos da un ejemplo simple: el de pasar todo tu código fuente C por el programa'indent' antes de almacenarlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>No more branch on your server.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La rama en el servidor ha desaparecido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>One way is to use the `git fsck` utility, which checks your database for integrity.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T133820Z" changeid="juan">
        <seg>Un camino es utilizando el comando de chequeo de integridad de la base de datos: `git fsck`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You’ll see how to store a blob object — in this case, the string &quot;what is up, doc?&quot; — interactively in the Ruby scripting language.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T181038Z" changeid="juan">
        <seg>Te mostraré el proceso de guardar un objeto binario grande (blob), --en este caso la cadena de texto &quot;what is up, doc?&quot; (¿qué hay de nuevo, viejo?)--, interactivamente, en el lenguaje de script Ruby.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Technically, you can do that by explicitly figuring out the common ancestor and then running your diff on it:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Técnicamente, lo puedes hacer descubriendo tu mismo dicho ancestro común y lanzando la comprobación de diferencias respecto de él:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0325.png
Figure 3-25.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0325.png
Figura 3-25.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you want to push from your laptop when you’re at home, you have to mount the remote disk, which can be difficult and slow compared to network-based access.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por ejemplo, si quieres enviar (push) desde tu portátil cuando estás en casa, primero tienes que montar el disco remoto; lo cual puede ser dificil y lento, en comparación con un acceso basado en red.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The next hook to run when applying patches via `git am` is `pre-applypatch`.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El siguiente punto de enganche que se activa al aplicar parches con 'git am' es el punto 'pre-applypatch'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git apply /tmp/patch-ruby-client.patch</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git apply /tmp/patch-ruby-client.patch</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>¿Porqué esto es tan importante?</seg>
      </tuv>
      <tuv lang="ES">
        <seg>¿Porqué esto es tan importante?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Final commit history.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Registro final de confirmaciones de cambio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The branch histories have diverged.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Los registros de las ramas divergen.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When you’re finished, you should run `git bisect reset` to reset your HEAD to where you were before you started, or you’ll end up in a weird state:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T165936Z" changeid="juan">
        <seg>Al terminar la revisión, es obligatorio teclear el comando `git bisect reset` para devolver HEAD al punto donde estaba antes de comenzar todo el proceso de búsqueda. So pena de dejar el sistema en un estado inconsistente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When you’re applying patches, you can ask Git to warn you if it’s applying patches with the specified whitespace issues:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Al incorporar parches, puedes pedirle a Git que te avise específicamente sobre determinados problemas de espaciado:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ gpg -a --export F721C45A | git hash-object -w --stdin
	659ef797d181633c87ec71ac3f9ba29fe5775b92</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ gpg -a --export F721C45A | git hash-object -w --stdin
	659ef797d181633c87ec71ac3f9ba29fe5775b92</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you run `chmod u+x .git/hooks/update`, which is the file you into which you should have put all this code, and then try to push a non-fast-forwarded reference, you get something like this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si lanzas el comando 'chmod u+x .git/hooks/update', siendo este el archivo donde has puesto todo este código; y luego intentas enviar una referencia que no sea de avance-rápido, obtendrás algo como esto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Tracking branches are local branches that have a direct relationship to a remote branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Las ramas de seguimiento son ramas locales que tienen una relación directa con alguna rama remota.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>After you exit the merge tool, Git asks you if the merge was successful.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tras salir de la herramienta de fusionado, Git preguntará a ver si hemos resuelto todos los conflictos y la fusión ha sido satisfactoria.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Let’s add the rest of the team.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Vamos a añadir al resto del equipo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Subversion importing interface.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El interface de importación desde Subversion.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>[remote &quot;origin&quot;]
	       url = git@github.com:schacon/simplegit-progit.git
	       fetch = +refs/heads/*:refs/remotes/origin/*
	       push = refs/heads/master:refs/heads/qa/master</seg>
      </tuv>
      <tuv lang="ES" changedate="20110817T153920Z" changeid="juan">
        <seg>[remote &quot;origin&quot;]
	       url = git@github.com:schacon/simplegit-progit.git
	       fetch = +refs/heads/*:refs/remotes/origin/*
	       push = refs/heads/master:refs/heads/qa/master</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can run via SSH in the same manner as the `receive-pack` process.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T132212Z" changeid="juan">
        <seg>Se puede lanzar a través de SSH, de la misma forma que se arrancaba el proceso `receive-pack`. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>There are different ways to initiate the `upload-pack` process on the remote repository.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T075325Z" changeid="juan">
        <seg>Hay varias maneras de iniciar un proceso `upload-pack` en el repositorio remoto. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The trick is finding that latest commit SHA — it’s not like you’ve memorized it, right?</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T142309Z" changeid="juan">
        <seg>El problema es cómo localizarla, --porque, ¿no te la sabrás de memoria, no?--.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>At this point, you can exit the interactive adding script and run `git commit` to commit the partially staged files.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120712T202129Z" changeid="juan">
        <seg>En este punto, es posible salir del script interactivo y lanzar el comando 'git commit' para almacenar esa confirmación de cambios parciales en los archivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Often, you’ll do this to make sure your commits apply cleanly on a remote branch — perhaps in a project to which you’re trying to contribute but that you don’t maintain.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Habitualmente, optarás por esta vía cuando quieras estar seguro de que tus confirmaciones de cambio (commits) se pueden aplicar limpiamente sobre una rama remota; posiblemente, en un proyecto donde estés intentando colaborar, pero lleves tu el mantenimiento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Here’s what it looks like:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110717T112345Z" changeid="juan">
        <seg>Tiene un aspecto como este:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The SHA-1 value of all '0's means that nothing was there before — because you’re adding the experiment reference.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T132017Z" changeid="juan">
        <seg>Una clave SHA-1 con todo '0's, nos indica que no habia nada anteriormente, y que, por tanto, estamos añadiendo una nueva referencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Small Setups ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Pequeños despliegues ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>There are ways to get around this (namely, stashing and commit amending) that we’ll cover later.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y, para ello, tenemos algunos procedimientos (stash y commit ammend), que vamos a ver más adelante.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git config --global merge.tool extMerge
	$ git config --global mergetool.extMerge.cmd \
	    'extMerge &quot;$BASE&quot; &quot;$LOCAL&quot; &quot;$REMOTE&quot; &quot;$MERGED&quot;'
	$ git config --global mergetool.trustExitCode false
	$ git config --global diff.external extDiff</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git config --global merge.tool extMerge
	$ git config --global mergetool.extMerge.cmd \
	    'extMerge &quot;$BASE&quot; &quot;$LOCAL&quot; &quot;$REMOTE&quot; &quot;$MERGED&quot;'
	$ git config --global mergetool.trustExitCode false
	$ git config --global diff.external extDiff</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It’s often helpful to get a review of all the commits that are in this branch but that aren’t in your master branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Suele ser util revisar todas las confirmaciones de cambios (commits) que esten es esta rama, pero no en tu rama principal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Branch pointing into the commit data’s history.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Apuntadores en el registro de confirmaciones de una rama.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Let’s say you have a Git server on your network at `git.ourcompany.com`.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Supongamos que tienes un sevidor Git en tu red, en 'git.ourcompany.com'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>John has a reference to the changes Jessica pushed up, but he has to merge them into his own work before he is allowed to push:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>John tiene una referencia a los cambios enviados por Jessica, pero ha de fusionarlos en su propio trabajo antes de que se le permita enviar:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The issue with including the library is that it’s difficult to customize the library in any way and often more difficult to deploy it, because you need to make sure every client has that library available.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T084814Z" changeid="juan">
        <seg>La problemática en el primer caso radica en la dificultad de personalizar la biblioteca compartida. Y en la dificultal para su despliegue; ya que es necesario que todos y cada uno de los clientes dispongan de ella. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>#### color.ui ####</seg>
      </tuv>
      <tuv lang="ES">
        <seg>#### color.ui ####</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>At the end of this list, it writes &quot;done&quot; to initiate the `upload-pack` process to begin sending the packfile of the data it needs:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T132404Z" changeid="juan">
        <seg>Llegando al final de la lista, escribe &quot;done&quot; (hecho). Para indicar al proceso `upload-pack` que ya puede comenzar a enviar el archivo empaquetado con los datos requeridos: </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The `prepare-commit-msg` hook is run before the commit message editor is fired up but after the default message is created.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El punto de enganche 'prepare-commit-msg' se activa antes de arrancar el editor del mensaje de confirmación de cambios, pero después de crearse el mensaje por defecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you do an initial `submodule update`, commit in that submodule directory without creating a branch to work in, and then run `git submodule update` again from the superproject without committing in the meantime, Git will overwrite your changes without telling you.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T172336Z" changeid="juan">
        <seg>Si se realiza un `submodule update` inicial, se hacen cambios y se confirman en esa carpeta de submódulo sin haber creado antes una rama en la que trabajar. Y si, tras esto, se realiza de nuevo un `git submodule update` desde el proyecto padre, sin haber confirmado cambios en este, Git sobreescribirá cambios sin aviso previo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>GitHub administration page.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Página de administración GitHub.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You add external projects as submodules with the `git submodule add` command:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T103329Z" changeid="juan">
        <seg>Los proyectos externos se pueden incluir como submódulos mediante el comando `git submodule add`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>+    def command(git_cmd)XXXX</seg>
      </tuv>
      <tuv lang="ES">
        <seg>+    def command(git_cmd)XXXX</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg># Jessica's Machine
	$ git fetch origin
	$ git checkout -b featureB origin/master
	Switched to a new branch &quot;featureB&quot;</seg>
      </tuv>
      <tuv lang="ES">
        <seg># Jessica's Machine
	$ git fetch origin
	$ git checkout -b featureB origin/master
	Switched to a new branch &quot;featureB&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git gives you the name of the nearest tag with the number of commits on top of that tag and a partial SHA-1 value of the commit you’re describing:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Git te dará el nombre de la etiqueta más cercana, mas el número de confirmaciones de cambios entre dicha etiqueta y la confirmación que estas describiendo, más una parte de la firma SHA-1 de la confirmación:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You’ll determine the path of the object you want to write out (the first two characters of the SHA-1 value being the subdirectory name, and the last 38 characters being the filename within that directory).</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T145802Z" changeid="juan">
        <seg>Para fijar el lugar donde almacenarlo, utilizaremos como nombre de carpeta los dos primeros caracteres del valor SHA-1 y como nombre de archivo los restantes 38 caracteres de dicho valor SHA-1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0502.png
Figure 5-2.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0502.png
Figura 5-2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>updated README formatting and added blame</seg>
      </tuv>
      <tuv lang="ES" changedate="20120728T092013Z" changeid="juan">
        <seg>updated README formatting and added blame</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Then, it adds a space followed by the size of the content and finally a null byte:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T200505Z" changeid="juan">
        <seg>Después añade un espacio, seguido del tamaño del contenido y termina con un byte nulo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It’s pushed and pulled with the rest of your project.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T170753Z" changeid="juan">
        <seg>Y será enviado (push) y recibido (pull) junto con el resto del proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is especially important to understand if you’re used to Subversion, because you’ll notice that the two developers didn’t edit the same file.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Entender bien esto es especialmente importante, sobre todo si estás acostumbrado a utilizar Subversion; porque habrás notado que ambos desarrolladores han editado archivos distintos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Another very frequent use of this syntax is to see what you’re about to push to a remote:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T120814Z" changeid="juan">
        <seg>Otra utilidad habitual de estas sentencias es la de ver lo que se está a punto de enviar a un repositorio remoto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>At this point, you can go back to the master branch and do a fast-forward merge (see Figure 3-30).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En este momento, puedes volver a la rama 'master' y hacer una fusión con avance rápido (fast-forward merge). (ver Figura 3-30)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git clone https://github.com/tv42/gitosis.git
	$ cd gitosis
	$ sudo python setup.py install</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git clone https://github.com/tv42/gitosis.git
	$ cd gitosis
	$ sudo python setup.py install</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>A cherry-pick in Git is like a rebase for a single commit.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Entresacar (cherry-pick) en Git es como reorganizar (rebase) una sola confirmación de cambios (commit).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When you do the submodule update a second time, it will still revert your work, but at least you have a pointer to get back to.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T172504Z" changeid="juan">
        <seg>Cuando se realice una actualización (update) del submódulo por segunda vez, se seguirá sobreescribiendo el trabajo; pero al menos se tendrá un apuntador para volver hasta los cambios realizados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you’re interested in using the HTTP-push protocols, you can read about preparing a repository for this purpose at `http://www.kernel.org/pub/software/scm/git/docs/howto/setup-git-server-over-http.txt`.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si estás interesado en utilizar los protocolos HTTP-push, puedes encotrar más información en  `http://www.kernel.org/pub/software/scm/git/docs/howto/setup-git-server-over-http.txt`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you run `git gc`, all the objects are in a packfile; you can identify the big objects by running another plumbing command called `git verify-pack` and sorting on the third field in the output, which is file size.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T105642Z" changeid="juan">
        <seg>Tras lanzar el comando `git gc`, todos los objetos estarán guardados en un archivo empaquetador. Puedes identifcar los objetos enormes en su interior, utilizando otro comando de fontanería denominado `git verify-pack` y ordenando su salida por su tercera columna, la que nos informa de los tamaños de cada objeto. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you don’t have these files (or you don’t even have a `.ssh` directory), you can create them by running a program called `ssh-keygen`, which is provided with the SSH package on Linux/Mac systems and comes with the MSysGit package on Windows:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si no tienes esos archivos (o no tienes ni siquiera la carpeta '.ssh'), has de crearlos; utilizando un programa llamado 'ssh-keygen', que viene incluido en el paquete SSH de los sistemas Linux/Mac o en el paquete MSysGit en los sistemas Windows:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Let’s follow Jessica’s workflow as she works on her two features, collaborating in parallel with two different developers in this environment.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Vamos a seguir el trabajo de Jessica, a medida que trabaja en sus dos funcionalidade; colaborando en paralelo con dos desarrolladores distintos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is nice because with this syntax you can specify more than two references in your query, which you cannot do with the double-dot syntax.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T091110Z" changeid="juan">
        <seg>Esto nos permite indicar más de dos referencias en una misma consulta. Algo imposible con la sintaxis dos-puntos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This occurs fairly commonly.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T191751Z" changeid="juan">
        <seg>Es algo que frecuentemente suele ser necesario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git checkout master
	$ git merge hotfix
	Updating f42c576..3a0874c
	Fast forward
	 README |    1 -
	 1 files changed, 0 insertions(+), 1 deletions(-)</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git checkout master
	$ git merge hotfix
	Updating f42c576..3a0874c
	Fast forward
	 README |    1 -
	 1 files changed, 0 insertions(+), 1 deletions(-)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You need to be careful to change only the e-mail addresses that are yours, so you use `--commit-filter`:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T200109Z" changeid="juan">
        <seg>Aunque es necesario ser cuidadoso para actuar solo sobre aquellas direcciones que se deseen cambiar, utilizando para ello la opción `--commit-filter`: </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To demonstrate, you can use the plumbing command `hash-object`, which takes some data, stores it in your `.git` directory, and gives you back the key the data is stored as.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para verlo en acción, puedes utilizar el comando de fontanería 'hash-object'. Este comando coge ciertos datos, los guarda en la carpeta '.git.' y te devuelve la clave bajo la cual se han guardado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The iss53 branch has moved forward with your work.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La rama 'iss53' ha avanzado con tu trabajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you’re on a Linux or Mac system that uses LF line endings, then you don’t want Git to automatically convert them when you check out files; however, if a file with CRLF endings accidentally gets introduced, then you may want Git to fix it.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si estás trabajando en una máquina Linux o Mac, entonces no te interesa convertir automáticamente los finales de línea al extraer código. Sino que te interesa arreglar los posibles CRLF que pudieran aparecer accidentalmente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>=&gt; GET objects/info/packs
	P pack-816a9b2334da9953e530f27bcac22082a9f5b835.pack</seg>
      </tuv>
      <tuv lang="ES" changedate="20110817T224006Z" changeid="juan">
        <seg>=&gt; GET objects/info/packs
	P pack-816a9b2334da9953e530f27bcac22082a9f5b835.pack</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ cd myproject
	$ ls -l
	total 8
	-rw-r--r--  1 schacon  admin   3 Apr  9 09:11 README
	drwxr-xr-x  2 schacon  admin  68 Apr  9 09:11 rack
	$ ls rack/
	$</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T105626Z" changeid="juan">
        <seg>$ cd myproject
	$ ls -l
	total 8
	-rw-r--r--  1 schacon  admin   3 Apr  9 09:11 README
	drwxr-xr-x  2 schacon  admin  68 Apr  9 09:11 rack
	$ ls rack/
	$</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0338.png
Figure 3-38.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0338.png
Figura 3-38.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>[POLICY] Cannot push a non fast-forward reference
	error: hooks/update exited with error code 1
	error: hook declined to update refs/heads/master</seg>
      </tuv>
      <tuv lang="ES">
        <seg>[POLICY] Cannot push a non fast-forward reference
	error: hooks/update exited with error code 1
	error: hook declined to update refs/heads/master</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you stash some work, leave it there for a while, and continue on the branch from which you stashed the work, you may have a problem reapplying the work.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T094105Z" changeid="juan">
        <seg>Si se almacena rápidamente (stash) un cierto trabajo, se deja en la pila durante bastante tiempo, y se continua mientras tanto con otros trabajos sobre la misma rama. Es muy posible que se presenten problemas al tratar de reaplicar los cambios guardados tiempo atrás.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For instance, if you’re updating the `master` branch and adding an `experiment` branch, the `send-pack` response may look something like this:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T074444Z" changeid="juan">
        <seg>Por ejemplo, si estás actualizando la rama `master` y añadiendo otra rama `experiment`, la respuesta del proceso `send-pack` será algo así como: </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To find out what file it is, you’ll use the `rev-list` command, which you used briefly in Chapter 7.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T110015Z" changeid="juan">
        <seg>Para concretar cual es el archivo, puedes utilizar el comando `rev-list` que ya vimos brevemente en el capítulo 7. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The fetch process is a series of GET requests, where the client can assume the layout of the Git repository on the server.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T130339Z" changeid="juan">
        <seg>El proceso de recuperación (fetch) de datos se limita a una serie de peticiones GET, siendo el cliente quien ha de conocer la estructura del repositorio Git en el servidor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you try to merge two branches and subsequently have merge conflicts, you can run the command `git mergetool`; it starts P4Merge to let you resolve the conflicts through that GUI tool.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si intentas fusionar (merge) dos ramas y tienes los consabidos conflictos de integración, puedes lanzar el comando 'git mergetool'; lanzará P4Merge para ayudarte a resolver los conflictos por medio de su interfaz gráfica.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>At some point in your Git journey, you may accidentally lose a commit.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T093714Z" changeid="juan">
        <seg>En algún momento de tu trabajo con Git, perderás por error una confirmación de cambios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git log --pretty=fuller -1
	commit 6c5e70b984a60b3cecd395edd5b48a7575bf58e0
	Author:     Jessica Smith &lt;jessica@example.com&gt;
	AuthorDate: Sun Apr 6 10:17:23 2008 -0700
	Commit:     Scott Chacon &lt;schacon@gmail.com&gt;
	CommitDate: Thu Apr 9 09:19:06 2009 -0700</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git log --pretty=fuller -1
	commit 6c5e70b984a60b3cecd395edd5b48a7575bf58e0
	Author:     Jessica Smith &lt;jessica@example.com&gt;
	AuthorDate: Sun Apr 6 10:17:23 2008 -0700
	Commit:     Scott Chacon &lt;schacon@gmail.com&gt;
	CommitDate: Thu Apr 9 09:19:06 2009 -0700</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You want to work on this project with your friends, so you’ll have to re-add their public keys.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si deseas compartir el proyecto con tus compañeros, tienes que añadir de nuevo sus claves públicas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You effectively change the order of those commits and remove the &quot;added cat-file&quot; commit completely.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120728T091210Z" changeid="juan">
        <seg>De esta forma se habrá cambiado el orden de las dos confirmaciones de cambio, y se habrá eliminado completamente la de &quot;added cat-file&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>&lt;p id=&quot;out&quot;&gt;...&lt;/p&gt;</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T213312Z" changeid="juan">
        <seg>&lt;p id=&quot;out&quot;&gt;...&lt;/p&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>add limit to log function</seg>
      </tuv>
      <tuv lang="ES">
        <seg>add limit to log function</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It essentially rewinds the work you’ve done in your testing branch temporarily so you can go in a different direction.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Básicamente, lo que se está haciendo es rebobinar el trabajo que habias hecho temporalmente en la rama 'testing'; de tal forma que puedas avanzar en otra dirección diferente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Occasionally, Git automatically runs a command called &quot;auto gc&quot;.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T132535Z" changeid="juan">
        <seg>De cuando en cuando, Git lanza automáticamente un comando llamado &quot;auto gc&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you specify `file://`, Git fires up the processes that it normally uses to transfer data over a network which is generally a lot less efficient method of transferring the data.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si escribes con el prefijo 'file://', Git lanza el proceso que usa habitualmente para transferir datos sobre una red; proceso que suele ser mucho menos eficiente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>One nice thing about making Git push over HTTP is that you can use any WebDAV server, without specific Git features; so, you can use this functionality if your web-hosting provider supports WebDAV for writing updates to your web site.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La utilidad de habilitar Git para enviar (push) a través de HTTP es la posibilidad de utilizar cualquier servidor WebDAV para ello, sin necesidad de requerimientos específicos para Git. De tal forma que puedes hacerlo incluso a través de tu proveedor de albergue web, si este soporta WebDAV para escribir actualizaciones en tu sitio web.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git show d921970^2
	commit 35cfb2b795a55793d7cc56a6cc2060b4bb732548
	Author: Paul Hedderly &lt;paul+git@mjr.org&gt;
	Date:   Wed Dec 10 22:22:03 2008 +0000</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T114314Z" changeid="juan">
        <seg>$ git show d921970^2
	commit 35cfb2b795a55793d7cc56a6cc2060b4bb732548
	Author: Paul Hedderly &lt;paul+git@mjr.org&gt;
	Date:   Wed Dec 10 22:22:03 2008 +0000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Remotes ###</seg>
      </tuv>
      <tuv lang="ES" changedate="20110810T224520Z" changeid="juan">
        <seg>### Remotos ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Jessica wants to tweak something, so she commits again and then pushes this back up to the server:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Jessica realiza algunos ajustes, los confirma (commit) y los envia (push) de vuelta al servidor:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Notice that the object entry points to the commit SHA-1 value that you tagged.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T112645Z" changeid="juan">
        <seg>Merece destacar que el inicio del objeto apunta al SHA-1 de la confirmación de cambios recién etiquetada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In Git, these are called &quot;references&quot; or &quot;refs&quot;; you can find the files that contain the SHA-1 values in the `.git/refs` directory.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T150012Z" changeid="juan">
        <seg>En Git, estp es lo que se conoce como &quot;referencias&quot; o &quot;refs&quot;. En la carpeta `.git/refs` puedes encontrar esos archivos con valores SHA-1 y nombres .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>All the Git commands work independently in the two directories:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T105432Z" changeid="juan">
        <seg>Todos los comandos Git actuan independientemente en ambas carpetas:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git push origin master
	...
	To john@githost:simplegit.git
	   fbff5bc..72bbc59  master -&gt; master</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git push origin master
	...
	To john@githost:simplegit.git
	   fbff5bc..72bbc59  master -&gt; master</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0328.png
Figure 3-28.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0328.png
Figura 3-28.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git commit -m 'first commit with submodule rack'
	[master 0550271] first commit with submodule rack
	 2 files changed, 4 insertions(+), 0 deletions(-)
	 create mode 100644 .gitmodules
	 create mode 160000 rack</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T104901Z" changeid="juan">
        <seg>$ git commit -m 'first commit with submodule rack'
	[master 0550271] first commit with submodule rack
	 2 files changed, 4 insertions(+), 0 deletions(-)
	 create mode 100644 .gitmodules
	 create mode 160000 rack</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>A nice way of quickly getting a sort of changelog of what has been added to your project since your last release or e-mail is to use the `git shortlog` command.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Una manera elegante de generar rápidamente una lista con los principales cambios añadidos a tu proyecto desde la anterior versión, es utilizando el comando 'git shortlog'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If this comes back with a list of alternate URLs, Git checks for loose files and packfiles there — this is a nice mechanism for projects that are forks of one another to share objects on disk.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T131021Z" changeid="juan">
        <seg>En el caso de que esto devolviera una lista de ubicaciones (URL) alternativas, Git busca en ellas. (Es un mecanismo muy adecuado en aquellos proyectos donde hay segmentos derivados uno de otro compartiendo objetos en disco.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Running the handful of required commands gives you a simple way to give the world read access to your Git repository.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Simplemente lanzando unos cuantos comandos, dispones de un método sencillo de dar al mundo entero acceso a tu repositorio Git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg># enforced custom commit message format
	def check_message_format
	  missed_revs = `git rev-list #{$oldrev}..#{$newrev}`.split(&quot;\n&quot;)
	  missed_revs.each do |rev|
	    message = `git cat-file commit #{rev} | sed '1,/^$/d'`
	    if !$regex.match(message)
	      puts &quot;[POLICY] Your message is not formatted correctly&quot;
	      exit 1
	    end
	  end
	end
	check_message_format</seg>
      </tuv>
      <tuv lang="ES">
        <seg># enforced custom commit message format
	def check_message_format
	  missed_revs = `git rev-list #{$oldrev}..#{$newrev}`.split(&quot;\n&quot;)
	  missed_revs.each do |rev|
	    message = `git cat-file commit #{rev} | sed '1,/^$/d'`
	    if !$regex.match(message)
	      puts &quot;[POLICY] Your message is not formatted correctly&quot;
	      exit 1
	    end
	  end
	end
	check_message_format</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>[remote rejected] master -&gt; master (hook declined)
	error: failed to push some refs to 'git@gitserver:project.git'</seg>
      </tuv>
      <tuv lang="ES">
        <seg>[remote rejected] master -&gt; master (hook declined)
	error: failed to push some refs to 'git@gitserver:project.git'[remote rejected] master -&gt; master (hook declined)
	error: failed to push some refs to 'git@gitserver:project.git'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>As you briefly saw in the Chapter 1, you can specify Git configuration settings with the `git config` command.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Como se ha visto brevemente en el capítulo 1, podemos acceder a los ajustes de configuración de Git a través del comando 'git config'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now that you have a remote Git repository set up as a point for all the developers to share their code, and you’re familiar with basic Git commands in a local workflow, you’ll look at how to utilize some of the distributed workflows that Git affords you.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Ahora que ya tienes un repositorio Git, configurado como punto de trabajo para compartir código entre desarrolladores. Y ahora que ya conoces los comandos básicos de Git para flujos de trabajo locales. Puedes hechar un vistazo a algunos de los flujos de trabajo distribuidos que Git permite.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Before the last commit, you were using closer to 2K — clearly, removing the file from the previous commit didn’t remove it from your history.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T134840Z" changeid="juan">
        <seg>Antes de la última confirmación de cambios, estabas usando algo así como 2 KB. Resulta claro que esa última confirmación de cambios no ha borrado el archivo enorme del historial.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Maintenance ###</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T090809Z" changeid="juan">
        <seg>### Mantenimiento ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>1c36188...</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T102033Z" changeid="juan">
        <seg>1c36188...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ sudo chmod +x /usr/local/bin/extMerge
	$ sudo chmod +x /usr/local/bin/extDiff</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ sudo chmod +x /usr/local/bin/extMerge
	$ sudo chmod +x /usr/local/bin/extDiff</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>That is one of the simplest workflows.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Este es uno de los flujos de trabajo más simples.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ gpg --list-keys
	/Users/schacon/.gnupg/pubring.gpg
	---------------------------------
	pub   1024D/F721C45A 2009-02-09 [expires: 2010-02-09]
	uid                  Scott Chacon &lt;schacon@gmail.com&gt;
	sub   2048g/45D02282 2009-02-09 [expires: 2010-02-09]</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ gpg --list-keys
	/Users/schacon/.gnupg/pubring.gpg
	---------------------------------
	pub   1024D/F721C45A 2009-02-09 [expires: 2010-02-09]
	uid                  Scott Chacon &lt;schacon@gmail.com&gt;
	sub   2048g/45D02282 2009-02-09 [expires: 2010-02-09]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is much like specifying `git diff --cached` on the command line:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T213305Z" changeid="juan">
        <seg>Es muy parecido a lanzar el comando 'git diff --cached' directamente en la línea de comandos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can obviously refer to a commit by the SHA-1 hash that it’s given, but there are more human-friendly ways to refer to commits as well.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120712T195104Z" changeid="juan">
        <seg>La forma canónica de referirse a una confirmación de cambios es indicando su código-resumen criptográfico SHA-1. Pero también existen otras maneras más sencillas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git bisect reset</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T072908Z" changeid="juan">
        <seg>$ git bisect reset</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Merging a branch to integrate the diverged work history.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Fusionando una rama para integrar el registro de trabajos divergentes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To see which stashes you’ve stored, you can use `git stash list`:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120702T085432Z" changeid="juan">
        <seg>Para ver el contenido de dicha pila, se emplea el comando 'git stash list':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you want to contribute to an existing project to which you don’t have push access, GitHub encourages forking the project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si deseas contribuir a un proyecto ya existente, en el que no tengas permisos de envio (push). GitHub recomienda bifurcar el proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You’ll now create a new tree with the second version of test.txt and a new file as well:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T144526Z" changeid="juan">
        <seg>Vamos a crear un nuevo árbol con la segunda versión del archivo test.txt y con un nuevo archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You saw this in the last section with the `iss53` and `hotfix` branches you created.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tal y como has visto con las ramas 'iss53' y 'hotfix' que has creado en la sección anterior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>That gives you your next commit object.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110817T223215Z" changeid="juan">
        <seg>El siguiente objeto confirmación de cambio (commit).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you want more complex access control type permissions on your repositories, you can handle them with the normal filesystem permissions of the operating system your server runs.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En caso de que necesites un control más complejo y fino sobre cada repositorio, puedes manejarlos a través de los permisos estandar del sistema de archivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ echo '*.png diff=exif' &gt;&gt; .gitattributes
	$ git config diff.exif.textconv exiftool</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ echo '*.png diff=exif' &gt;&gt; .gitattributes
	$ git config diff.exif.textconv exiftool</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can also edit these patch files to add more information for the e-mail list that you don’t want to show up in the commit message.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes incluso editar esos archivos de parche, para añadirles más información , específica para la lista de correo, y que no desees mostrar en el propio mensaje de la confirmación de cambios. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>start on startup
	stop on shutdown
	exec /usr/bin/git daemon \
	    --user=git --group=git \
	    --reuseaddr \
	    --base-path=/opt/git/ \
	    /opt/git/
	respawn</seg>
      </tuv>
      <tuv lang="ES">
        <seg>start on startup
	stop on shutdown
	exec /usr/bin/git daemon \
	    --user=git --group=git \
	    --reuseaddr \
	    --base-path=/opt/git/ \
	    /opt/git/
	respawn</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Assuming she already has her repository cloned, she decides to work on `featureA` first.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Suponiendo que tiene su repositorio ya clonado, ella decide trabajar primero en la funcionalidad A (featureA).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Then, your editor will open to something like this for your placeholder commit message when you commit:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>A partir de entonces, cada vez que confirmes cambios (commit), tu editor se abrirá con algo como esto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## Interactive Staging ##</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T211015Z" changeid="juan">
        <seg>## Preparación interactiva ##</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>*.pbxproj -crlf -diff</seg>
      </tuv>
      <tuv lang="ES">
        <seg>*.pbxproj -crlf -diff</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To disable the ability to force-update remote branches to non-fast-forward references, set `receive.denyNonFastForwards`:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para impedir estos envios forzados de referencias de avance no directo (no fast-forward) a ramas remotas, es para lo que se emplea el parámetro 'receive.denyNonFastForwards':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>target_shas = `git rev-list #{base_branch}..#{topic_branch}`.split(&quot;\n&quot;)
	remote_refs = `git branch -r`.split(&quot;\n&quot;).map { |r| r.strip }</seg>
      </tuv>
      <tuv lang="ES">
        <seg>target_shas = `git rev-list #{base_branch}..#{topic_branch}`.split(&quot;\n&quot;)
	remote_refs = `git branch -r`.split(&quot;\n&quot;).map { |r| r.strip }</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>to this:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120728T090957Z" changeid="juan">
        <seg>a quedar en algo como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This technique allows you to context-switch quickly and completely — because your work is separated into silos where all the changes in that branch have to do with that topic, it’s easier to see what has happened during code review and such.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esta técnica te posibilita realizar rápidos y completos saltos de contexto. Y, debido a que el trabajo está claramente separado en silos, con todos los cambios de cada tema en su propia rama, te será mucho más sencillo revisar el código y seguir su evolución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Better get rid of it:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T104716Z" changeid="juan">
        <seg>Mejor si lo quitas:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Let’s say the project maintainer has pulled in a bunch of other patches and tried your first branch, but it no longer cleanly merges.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Supongamos que el gestor del proyecto ha recuperado e integrado un grupo de otros parches y después lo intenta con tu primer parche, viendo que no se integra limpiamente. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When you find the correct user, click the Add button to add that user as a collaborator on your project (see Figure 4-11).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cuando localices al usuario deseado, clica sobre el botón &quot;Add&quot; para añadirlo como colaborador en tu proyecto (ver Figura 4-11).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>changed log output to 30 from 25</seg>
      </tuv>
      <tuv lang="ES">
        <seg>changed log output to 30 from 25</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>First, you need to set up the imap section in your `~/.gitconfig` file.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Lo primero es configurar correctamente el apartado imap de tu archivo `~/.gitconfig`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>See the `git config` manpage for all the subsettings you can configure, if you want to do that.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Mira en la página man de 'git config' si deseas tener explicaciones más detalladas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This means that when you push to the server via SSH, Git will run this command to update the files needed for HTTP fetching.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Lo que significa que cada vez que envias (push) algo al servidor vía SSH, Git lanzará este comando y actualizará así los archivos necesarios para HTTP fetching. (_i_pendientedetraducir) </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>third commit</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T180400Z" changeid="juan">
        <seg>third commit</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## Transfer Protocols ##</seg>
      </tuv>
      <tuv lang="ES" changedate="20110817T154736Z" changeid="juan">
        <seg>## Protocolos de transferencia ##</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now, the 'git' user can only use the SSH connection to push and pull Git repositories and can’t shell onto the machine.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>De esta forma dejamos al usuario 'git' limitado a utilizar la conexión SSH solamente para enviar (push) y recibir (pull) repositorios, sin posibilidad de iniciar una sesión normal en el servidor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can make your first push to the new `iphone_project` project by adding your server as a remote to your local version of the project and pushing.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes crear tu nuevo proyecto 'iphone_project' simplemente añadiendo tu servidor como un remoto a tu versión local del proyecto de control y enviando (push).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you set this attribute on a file or set of files, then the next time you check out that branch, Git will replace that field with the SHA-1 of the blob.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si colocas este attributo en un archivo o conjunto de archivos, Git lo sustituirá por la suma de comprobación SHA-1 la próxima vez que lo/s extraiga/s.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>However, if someone uploaded a patch file generated via `format-patch` to a ticketing system or something similar, you can save the file locally and then pass that file saved on your disk to `git am` to apply it:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Sin embargo, si alguien sube su archivo de parche a un sistema de gestión de peticiones de servicio o similar; tendrás que descargartelo a un archivo local en tu disco y luego indicar ese archivo local al comando 'git am':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git log --pretty=oneline -- git.tbz2
	da3f30d019005479c99eb4c3406225613985a1db oops - removed large tarball
	6df764092f3e7c8f5f94cbe08ee5cf42e92a0289 added git tarball</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T110311Z" changeid="juan">
        <seg>$ git log --pretty=oneline -- git.tbz2
	da3f30d019005479c99eb4c3406225613985a1db oops - removed large tarball
	6df764092f3e7c8f5f94cbe08ee5cf42e92a0289 added git tarball</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git also gives you your own `master` branch starting at the same place as origin’s `master` branch, so you have something to work from (see Figure 3-22).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Git te proporcionará también tu propia rama 'master', apuntando al mismo lugar que la rama 'master' de 'origin'; siendo en esta última donde podrás trabajar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Initial commit history with featureB work.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Historial inicial con el trabajo de la funcionalidad B.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>First, let’s say you’re working on your project and have a couple of commits already (see Figure 3-10).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Imagina que estas trabajando en un proyecto, y tienes un par de confirmaciones (commit) ya realizadas. (ver Figura 3-10)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git rm git.tbz2
	rm 'git.tbz2'
	$ git commit -m 'oops - removed large tarball'
	[master da3f30d] oops - removed large tarball
	 1 files changed, 0 insertions(+), 0 deletions(-)
	 delete mode 100644 git.tbz2</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T104718Z" changeid="juan">
        <seg>$ git rm git.tbz2
	rm 'git.tbz2'
	$ git commit -m 'oops - removed large tarball'
	[master da3f30d] oops - removed large tarball
	 1 files changed, 0 insertions(+), 0 deletions(-)
	 delete mode 100644 git.tbz2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git directory objects with branch head references included.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T191553Z" changeid="juan">
        <seg>Objetos en la carpeta Git, con referencias a las cabeceras de las ramas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is a variant of a multiple-repository workflow.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Es una variante del flujo de trabajo con multiples repositorios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The Git project provides a document that lays out a number of good tips for creating commits from which to submit patches — you can read it in the Git source code in the `Documentation/SubmittingPatches` file.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El propio proyecto Git suministra un documento con un gran número de buenas sugerencias sobre la creación de confirmaciones de cambio destinadas a enviar parches --puedes leerlo en el código fuente de Git, en el archivo 'Documentation/SubmittingPatches'--.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You may think to run this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes pensar en lanzar esto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git rev-list --objects --all | grep 7a9eb2fb
	7a9eb2fba2b1811321254ac360970fc169ba2330 git.tbz2</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T110200Z" changeid="juan">
        <seg>$ git rev-list --objects --all | grep 7a9eb2fb
	7a9eb2fba2b1811321254ac360970fc169ba2330 git.tbz2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>#!/usr/bin/env ruby</seg>
      </tuv>
      <tuv lang="ES">
        <seg>#!/usr/bin/env ruby#!/usr/bin/env ruby#!/usr/bin/env ruby</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To see all the branches that contain work you haven’t yet merged in, you can run `git branch --no-merged`:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para mostrar todas las ramas que contienen trabajos sin fusionar aún, puedes utilizar el comando 'git branch --no-merged':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Writing objects: 100% (7/7), 716 bytes, done.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110810T224917Z" changeid="juan">
        <seg>Writing objects: 100% (7/7), 716 bytes, done.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To fix this, you must run `git submodule update` again:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T110256Z" changeid="juan">
        <seg>Para arreglarlo, es necesario lanzar de nuevo el comando `git submodule update`: </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now that you can (I hope) determine which workflow combination may work for you, I’ll cover some more specific examples of how to accomplish the main roles that make up the different flows.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Espero que a estas alturas estés en condiciones de reconocer la combinación de flujos de trabajo que puede serte util. Vamos a ver algunos ejemplos más específicos, ilustrativos de los roles principales que se presentan en las distintas maneras de trabajar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Generally, this happens because you force-delete a branch that had work on it, and it turns out you wanted the branch after all; or you hard-reset a branch, thus abandoning commits that you wanted something from.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T133006Z" changeid="juan">
        <seg>Normalmente, esto suele suceder porque has forzado el borrado de una rama con trabajos no confirmados en ella, y luego te has dado cuenta de que realmente necesitabas dicha rama; o porque has reculado (hard-reset) una rama, abandonando todas sus confirmaciones de cambio, y luego te has dado cuenta que necesitabas alguna de ellas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>check_directory_perms</seg>
      </tuv>
      <tuv lang="ES">
        <seg>check_directory_permscheck_directory_perms</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Suppose you want to add a mechanism that uses an access control list (ACL) that specifies which users are allowed to push changes to which parts of your projects.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Imaginemos que deseas implementar un sistema de control de accesos (Access Control List, ACL). Para vigilar qué usuarios pueden enviar (push) cambios a qué partes de tus proyectos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now you can add them all to your 'mobile' team so they have read and write access to `iphone_project`:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y para añadirlos al equipo 'mobile', dándoles permisos de lectura y escritura sobre el proyecto 'phone_project':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This section splits them into committing-workflow hooks, e-mail–workflow scripts, and the rest of the client-side scripts.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En esta sección los dividiremos en puntos de enganche en el flujo de trabajo de confirmación de cambios, puntos en el flujo de trabajo de correo electrónico y resto de puntos de enganche del lado servidor. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Revert back to your production branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Vuelves a la rama de producción original.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This means that there is generally no pushing over this protocol.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Lo cual significa que, normalmente, no se podrá enviar (push) a través de este protocolo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now, move the `master` branch back to the middle commit:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T142103Z" changeid="juan">
        <seg>Después, al mover la rama  `master` de vuelta a la confirmación de cambios intermedia:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you run `git push --tags`, the `maintainer-pgp-pub` tag will be shared with everyone.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si lanzas el comando 'git push --tags', la etiqueta 'maintainer-pgp-pub' será compartida por todos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>John’s history after pushing to the origin server.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El historial de John tras enviar al servidor origen.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git commit -am 'added rack submodule'
	[rack cc49a69] added rack submodule
	 2 files changed, 4 insertions(+), 0 deletions(-)
	 create mode 100644 .gitmodules
	 create mode 160000 rack
	$ git checkout master
	Switched to branch &quot;master&quot;
	$ git status
	# On branch master
	# Untracked files:
	#   (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)
	#
	#      rack/</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T135318Z" changeid="juan">
        <seg>$ git commit -am 'added rack submodule'
	[rack cc49a69] added rack submodule
	 2 files changed, 4 insertions(+), 0 deletions(-)
	 create mode 100644 .gitmodules
	 create mode 160000 rack
	$ git checkout master
	Switched to branch &quot;master&quot;
	$ git status
	# On branch master
	# Untracked files:
	#   (use &quot;git add &lt;file&gt;...&quot; to include in what will be committed)
	#
	#      rack/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0414.png
Figure 4-14.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0414.png
Figura 4-14.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Then, for each of those, you find which files are modified and make sure the user who’s pushing has access to all the paths being modified.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Luego, para cada una de ellas, localizas los archivos modificados y te aseguras de que el usuario que las envia tiene realmente acceso a todas las ubicaciones que pretende modificar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Assuming this happens, how can you get your commits back?</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T133034Z" changeid="juan">
        <seg>Asumiendo que estas cosas pasan, ¿cómo podrías recuperar tus confirmaciones de cambio perdidas?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This book covers how to use Git with 30 or so verbs such as `checkout`, `branch`, `remote`, and so on.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Este libro habla acerca de como utilizar Git con más o menos 30 verbos, tales como 'checkout', 'branch', 'remote', etc.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git commit -am 'add iphone_project and mobile group'
	[master]: created 8962da8: &quot;changed name&quot;
	 1 files changed, 4 insertions(+), 0 deletions(-)
	$ git push
	Counting objects: 5, done.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git commit -am 'add iphone_project and mobile group'
	[master]: created 8962da8: &quot;changed name&quot;
	 1 files changed, 4 insertions(+), 0 deletions(-)
	$ git push
	Counting objects: 5, done.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Well, let’s do another commit:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Bueno.... lo veremos tras realizar otra confirmación de cambios:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ echo 'version 1' &gt; test.txt
	$ git hash-object -w test.txt
	83baae61804e65cc73a7201a7252750c76066a30</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ echo 'version 1' &gt; test.txt
	$ git hash-object -w test.txt
	83baae61804e65cc73a7201a7252750c76066a30</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>commit d921970aadf03b3cf0e71becdaab3147ba71cdef
	Merge: 1c002dd... 35cfb2b...
	Author: Scott Chacon &lt;schacon@gmail.com&gt;
	Date:   Thu Dec 11 15:08:43 2008 -0800</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T095047Z" changeid="juan">
        <seg>commit d921970aadf03b3cf0e71becdaab3147ba71cdef
	Merge: 1c002dd... 35cfb2b...
	Author: Scott Chacon &lt;schacon@gmail.com&gt;
	Date:   Thu Dec 11 15:08:43 2008 -0800</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You need to get rid of anything that has a pointer to those old commits before you repack:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T135355Z" changeid="juan">
        <seg>Antes de reempaquetar, asegurate de acabar completamente con cualquier elemento que apunte a las viejas confirmaciones de cambios:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Conceptually, the data in your Git repository looks something like Figure 3-1.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Conceptualmente, el contenido del repositorio Git será algo parecido a la Figura 3-1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Does the project have a maintainer or integration manager who checks all the patches?</seg>
      </tuv>
      <tuv lang="ES">
        <seg>¿Tiene un gestor de integraciones que comprueba todos los parches?.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>A topic branch is a short-lived branch that you create and use for a single particular feature or related work.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Una rama puntual es aquella de corta duración que abres para un tema o para una funcionalidad muy concretos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>- Bullet points are okay, too</seg>
      </tuv>
      <tuv lang="ES">
        <seg>- Los puntos con bolo también están permitidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>On the command line, you can pull down several branches like so:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T115457Z" changeid="juan">
        <seg>Escribiendo algo asi como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>One of the most complicated aspects of setting up a Git server is user management.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Porque la gestión de usuarios es precisamente uno de los aspectos más complicados de preparar un servidor Git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ cd /var/www/htdocs/
	$ git clone --bare /path/to/git_project gitproject.git
	$ cd gitproject.git
	$ mv hooks/post-update.sample hooks/post-update
	$ chmod a+x hooks/post-update</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ cd /var/www/htdocs/
	$ git clone --bare /path/to/git_project gitproject.git
	$ cd gitproject.git
	$ mv hooks/post-update.sample hooks/post-update
	$ chmod a+x hooks/post-update</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git tag -a v1.1 1a410efbd13591db07496601ebc7a059dd55cfe9 –m 'test tag'</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T234243Z" changeid="juan">
        <seg>$ git tag -a v1.1 1a410efbd13591db07496601ebc7a059dd55cfe9 –m 'test tag'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Because you already merged in `iss53` earlier, you see it in your list.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Aparece la rama 'iss53' porque ya ha sido fusionada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0314.png
Figure 3-14.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0314.png
Figura 3-14.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>#### Applying a Patch with am ####</seg>
      </tuv>
      <tuv lang="ES">
        <seg>#### Incorporando un parche con am ####</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Amazing.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110807T152507Z" changeid="juan">
        <seg>¡Sorprendente!.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This server is at `git.team1.ourcompany.com`.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Un servidor en 'git.team1.ourcompany.com'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Each developer has committed a few times and merged each other’s work successfully; see Figure 5-10.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cada desarrollador ha confirmado algunos cambios y ambos han fusionado sus trabajos correctamente; ver Figura 5-10.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Jessica Smith (2):
	      add limit to log function
	      change log output to 30 from 25</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Jessica Smith (2):
	      add limit to log function
	      change log output to 30 from 25</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can also continue this concept, having an integrate branch where all the work is merged together.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes continuar ampliando este concepto, disponiendo de una rama 'integrate' donde ir fusionando todo el trabajo entre sí.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0512.png
Figure 5-12.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0512.png
Figura 5-12.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Integration-manager workflow.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Flujo de trabajo Gestor-de-Integración.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now that you have the permissions sorted out, you need to determine what paths the commits being pushed have modified, so you can make sure the user who’s pushing has access to all of them.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Una vez tienes los permisos en orden, necesitas averiguar las ubicaciones modificadas por las confirmaciones de cambios enviadas; de tal forma que puedas asegurarte de que el usuario que las está enviando tiene realmente permiso para modificarlas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you have a QA team that pushes a series of branches, and you want to get the master branch and any of the QA team’s branches but nothing else, you can use a config section like this:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T120434Z" changeid="juan">
        <seg>Si tienes un equipo QA que envia al servidor una serie de ramas. Y deseas recuperar la rama master y cualquiera otra de las ramas del equipo; pero no recuperar ninguna rama de otro equipo. Puedes utilizar una sección de configuración como esta:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you don’t know what is breaking, and there have been dozens or hundreds of commits since the last state where you know the code worked, you’ll likely turn to `git bisect` for help.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T074611Z" changeid="juan">
        <seg>Pero no siendo ese el caso, y habiendose realizado docenas o cientos de confirmaciones de cambio desde el último estado estable conocido, puede ser de utilidad el comando `git bisect`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you’re a small outfit or are just trying out Git in your organization and have only a few developers, things can be simple for you.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si tienes un proyecto reducido o estás simplemente probando Git en tu empresa y sois unos pocos desarrolladores, el despliegue será sencillo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git am -3 -i mbox
	Commit Body is:
	--------------------------
	seeing if this helps the gem
	--------------------------
	Apply?</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git am -3 -i mbox
	Commit Body is:
	--------------------------
	seeing if this helps the gem
	--------------------------
	Apply?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Instead of reading from stdin, this script takes three arguments: the name of the reference (branch), the SHA-1 that reference pointed to before the push, and the SHA-1 the user is trying to push.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El lugar de recibir datos desde la entrada estandar (stdin), este script recibe tres argumentos: el nombre de la rama, la clave SHA-1 a la que esta apuntada antes del envio, y la clave SHA-1 que el usuario está intentando enviar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It looks something like this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Es algo parecido a esto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The Git protocol is the fastest transfer protocol available.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El protocolo Git es el más rápido de todos los disponibles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In centralized systems, every developer is a node working more or less equally on a central hub.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En los sistemas centralizados, cada desarrollador es un nodo de trabajo; trabajando todos ellos, en pie de igualdad, sobre un mismo repositorio central.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In Ruby, you can use the `FileUtils.mkdir_p()` function to create the subdirectory if it doesn’t exist.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T145826Z" changeid="juan">
        <seg>En Ruby, puedes utilizar la función `FileUtils.mkdir_p()` para crear una carpeta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## GitWeb ##</seg>
      </tuv>
      <tuv lang="ES">
        <seg>## GitWeb ##</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Note that this is a lot different than the concept of HEAD in other VCSs you may be used to, such as Subversion or CVS.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Aunque es preciso comentar que este HEAD es totalmente distinto al concepto de HEAD en otros sistemas de control de cambios como Subversion o CVS.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Although it’s technically a text file, because it’s all ASCII, you don’t want to treat it as such because it’s really a lightweight database — you can’t merge the contents if two people changed it, and diffs generally aren’t helpful.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Aunque técnicamente es un archivo de texto, porque su contenido son caracteres ASCII. Realmente nunca lo tratarás como tal, porque en realidad es una base de datos ligera --y no puedes fusionar sus contenidos si dos personas lo cambian, porque las comparaciones no son de utilidad--.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When it’s determined that they’re totally stable, the topics are re-merged into `master` and are then rebuilt from the topics that were in `next` but didn’t yet graduate to `master`.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y cuando las funcionalidades permanecen totalmente estables, se refusionan en la rama 'master'; componiendolas desde las funcionalidades en la rama 'next' aún sin   promocionar a 'master'. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>A Git clone gives you your own master branch and origin/master pointing to origin’s master branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Un clón Git te proporciona tu propia rama 'master' y otra rama 'origin/master' apuntando a la rama 'master' original.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>new.txt  |    1 +
	 test.txt |    2 +-
	 2 files changed, 2 insertions(+), 1 deletions(-)</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T180411Z" changeid="juan">
        <seg>new.txt  |    1 +
	 test.txt |    2 +-
	 2 files changed, 2 insertions(+), 1 deletions(-)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg># However, if you remove everything, the rebase will be aborted.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T122351Z" changeid="juan">
        <seg># However, if you remove everything, the rebase will be aborted.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ cat .git/hooks/post-update
	#!/bin/sh
	exec git-update-server-info</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ cat .git/hooks/post-update
	#!/bin/sh
	exec git-update-server-info</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Second, SSH is relatively easy to set up — SSH daemons are commonplace, many network admins have experience with them, and many OS distributions are set up with them or have tools to manage them.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En segundo lugar, SSH es sencillo de habilitar. Los demonios (daemons) SSH son de uso común, muchos administradores de red tienen experiencia con ellos y muchas distribuciones del SO los traen predefinidos o tienen herramientas para gestionarlos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0327.png
Figure 3-27.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0327.png
Figura 3-27.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The `hooks` directory contains your client- or server-side hook scripts, which are discussed in detail in Chapter 6.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110717T113022Z" changeid="juan">
        <seg>La carpeta 'hooks' contiene tus scripts, tanto de la parte cliente como de la parte servidor, tal y como se ha visto a detalle en el capítulo 6.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The Public Clone URL is a public, read-only Git URL over which anyone can clone the project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El enlace &quot;Public Clone URL&quot;, es un enlace público, de solo lectura; a través del cual cualquiera puede clonar el proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It takes a list of references that are being pushed from stdin; if it exits non-zero, none of them are accepted.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Recibe una lista de referencias que se están enviando (push) desde la entrada estandar (stdin); y, si termina con un codigo de salida distinto de cero, ninguna de ellas será aceptada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Last, we’ll go over a few hosted options, if you don’t mind hosting your code on someone else’s server and don’t want to go through the hassle of setting up and maintaining your own server.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por último, repasaremos algunas opciones albergadas on-line; por si no te preocupa guardar tu código en servidores de terceros y no deseas enredarte preparando y manteniendo tu propio servidor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git stash apply
	# On branch master
	# Changed but not updated:
	#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
	#
	#      modified:   index.html
	#      modified:   lib/simplegit.rb
	#</seg>
      </tuv>
      <tuv lang="ES" changedate="20120702T085948Z" changeid="juan">
        <seg>$ git stash apply
	# On branch master
	# Changed but not updated:
	#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
	#
	#      modified:   index.html
	#      modified:   lib/simplegit.rb
	#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Unlike Centralized Version Control Systems (CVCSs), the distributed nature of Git allows you to be far more flexible in how developers collaborate on projects.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Al contrario de otros Sistemas Centralizados de Control de Versiones, (CVCSs, Centralized Version Control Systems), la naturaleza distribuida de Git permite mucha más flexibilidad en la manera de colaborar en proyectos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If there is no output, then the patch should apply cleanly.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si obtienes una salida vacia, el parche se podrá incorporar limpiamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git checkout -b iss53
	Switched to a new branch &quot;iss53&quot;</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git checkout -b iss53
	Switched to a new branch &quot;iss53&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The `*` next to each file means the file is selected to be staged.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T212640Z" changeid="juan">
        <seg>El asterisco '*' al lado de cada archivo indica que dicho archivo ha sido seleccionado para ser preparado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Then, you can see the previous commit by specifying `HEAD^`, which means &quot;the parent of HEAD&quot;:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T191546Z" changeid="juan">
        <seg>Se puede visualizar la anteúltima confirmación de cambios indicando 'HEAD^', que significa &quot;el padre de HEAD&quot;:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To see what happens, you can manually ask Git to pack up the objects by calling the `git gc` command:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T114044Z" changeid="juan">
        <seg>Puedes comprobar el proceso pidiendole expresamente a Git que empaquete objetos, utilizando el comando `git gc`: </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The initial format in which Git saves objects on disk is called a loose object format.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T113941Z" changeid="juan">
        <seg>El formato inicial como Git guarda sus objetos en disco es el formato conocido como &quot;relajado&quot; (loose).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git branch
	  iss53
	* master
	  testing</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git branch
	  iss53
	* master
	  testing</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you stage one part of the file and leave another part unstaged, your status output will look like this:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120712T202057Z" changeid="juan">
        <seg>Si se decide pasar solo una parte de un archivo y dejar sin pasar otra parte, la salida de estado mostrará algo así como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Write out that tree (recording the state of the staging area or index to a tree object) and see what it looks like:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T144555Z" changeid="juan">
        <seg>Escribiendo este árbol, (guardando el estado del área de preparación o índice), podrás ver que aparece algo así como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>`filter-branch` is the tool you probably want to use to scrub your entire history.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T173517Z" changeid="juan">
        <seg>En estos casos, la mejor opción es utilizar la herramienta `filter-branch` para limpiar todo el historial. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Because it’s not as intelligent about transferring only the data you need — there is no dynamic work on the part of the server in these transactions — the HTTP protocol is often referred to as a _dumb_ protocol.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y precisamente por esto, porque no es tan inteligente y no transfiere solamente los datos imprescindibles, (no hay un trabajo dinámico por parte del servidor), el protocolo HTTP suele ser conocido como el protocolo _estúpido_.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now, you can sign tags without having to specify your key every time with the `git tag` command:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes firmar etiquetas sin necesidad de indicar tu clave cada vez en el comando 'git tag'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git config --global core.whitespace \
	    trailing-space,space-before-tab,indent-with-non-tab</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git config --global core.whitespace \
	    trailing-space,space-before-tab,indent-with-non-tab</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Each of these can be set to `true`, `false`, or `always`:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cada uno de ellos puede fijarse a 'true' (verdadero), 'false' (falso) o 'always' (siempre):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git checkout -b topicA
	$ (work)
	$ git commit
	$ (work)
	$ git commit</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git checkout -b topicA
	$ (work)
	$ git commit
	$ (work)
	$ git commit</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You add the Rack project as a remote reference in your own project and then check it out into its own branch:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T142004Z" changeid="juan">
        <seg>Se añade como una referencia remota en el propio proyecto, y luego se extrae (checkout) en su propia rama:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git submodule update
	remote: Counting objects: 5, done.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T110258Z" changeid="juan">
        <seg>$ git submodule update
	remote: Counting objects: 5, done.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is a subtle but incredibly annoying fact of cross-platform work.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esta es una sutil, pero molesta, diferencia cuando se trabaja en entornos multi-plataforma.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is because Windows uses both a carriage-return character and a linefeed character for newlines in its files, whereas Mac and Linux systems use only the linefeed character.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto se debe a que Windows utiliza retorno-de-carro y salto-de-linea para marcar los finales de línea de sus archivos. Mientras que Mac y Linux utilizan solamente el caracter de salto-de-linea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>database.xml merge=ours</seg>
      </tuv>
      <tuv lang="ES">
        <seg>database.xml merge=ours</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### The Smart Protocol ###</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T071903Z" changeid="juan">
        <seg>### El protocolo inteligente (smart) ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Clicking the &quot;explain ssh keys&quot; link takes you to detailed instructions on how to do so on all major operating systems.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El enlace &quot;explicar claves ssh&quot; (&quot;explain ssh keys&quot;) te llevará a unas detalladas instrucciones de cómo generarlas en la mayor parte de los principales sistemas operativos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Tree Objects ###</seg>
      </tuv>
      <tuv lang="ES" changedate="20110801T120033Z" changeid="juan">
        <seg>### Objetos tipo arbol ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>A local repository is fast only if you have fast access to the data.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Un repositorio local es rápido solamente en aquellas ocasiones en que tienes un acceso rápido a él.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can use these hooks for all sorts of reasons, and you’ll learn about a few of them here.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Estos puntos de enganche pueden utilizarse para multitud de aplicaciones. Vamos a ver unas pocas de ellas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can control which projects GitWeb lets users browse by adding or removing a `gitweb` setting in the Gitosis configuration file.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Los proyectos a ser mostrados por GitWeb se controlarán añadiendo o quitando parámetros 'gitweb' en el archivo de configuración de Gitosis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>That’s 1,200 times the number of grains of sand on the earth.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T185825Z" changeid="juan">
        <seg>Es decir, unas 1.200 veces el número de granos de arena en la Tierra.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You have several options to get a remote Git repository up and running so that you can collaborate with others or share your work.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tienes varias maneras de preparar un repositorio remoto Git, de colaborar con otras personas o de compartir tu trabajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>#### Uploading Data ####</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T075034Z" changeid="juan">
        <seg>#### Enviando datos, (Uploading) ####</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The other advantage of this approach is that you get the history of the commits as well.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Otra ventaja de esta forma de trabajar es que recibes también el histórico de confirmaciones de cambio (commits).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Pasting the text often causes formatting issues, especially with &quot;smarter&quot; clients that don’t preserve newlines and other whitespace appropriately.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Pegar el texto directamente suele causar problemas de formato. Especialmente con los clientes de correo más &quot;inteligentes&quot;, que no preservan adecuadamente los saltos de línea y otros espaciados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can take the changes on client that aren’t on server (C8 and C9) and replay them on your master branch by using the `--onto` option of `git rebase`:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes coger los cambios del cliente que no estan en server (C8 y C9), y reaplicarlos sobre tu rama principal usando la opción '--onto' del comando 'git rebase':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Stashing takes the dirty state of your working directory — that is, your modified tracked files and staged changes — and saves it on a stack of unfinished changes that you can reapply at any time.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T093005Z" changeid="juan">
        <seg>Este comando de guardado rápido (stashing) toma el estado del espacio de trabajo, con todas las modificaciones en los archivos bajo control de cambios, y lo guarda en una pila provisional. Desde allí, se podrán recuperar posteriormente y volverlas a aplicar de nuevo sobre el espacio de trabajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In Git, this is a pointer to the local branch you’re currently on.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En Git, es simplemente el apuntador a la rama local en la que tú estés en ese momento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>color.branch
	color.diff
	color.interactive
	color.status</seg>
      </tuv>
      <tuv lang="ES">
        <seg>color.branch
	color.diff
	color.interactive
	color.status</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git config filter.dater.smudge expand_date
	$ git config filter.dater.clean 'perl -pe &quot;s/\\\$Date[^\\\$]*\\\$/\\\$Date\\\$/&quot;'</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git config filter.dater.smudge expand_date
	$ git config filter.dater.clean 'perl -pe &quot;s/\\\$Date[^\\\$]*\\\$/\\\$Date\\\$/&quot;'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now, Jessica pushes her work up to the server:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tras esto, Jessica envia (push) su trabajo al servidor:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>I’ll cover most of the major hook filenames here.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Vamos a ver la mayoría de nombres de puntos de enganche disponibles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Then, you specify the mode, SHA-1, and filename:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T194850Z" changeid="juan">
        <seg>Para terminar, has de indicar el modo, la clave SHA-1 y el nombre de archivo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git symbolic-ref HEAD refs/heads/test
	$ cat .git/HEAD
	ref: refs/heads/test</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T192927Z" changeid="juan">
        <seg>$ git symbolic-ref HEAD refs/heads/test
	$ cat .git/HEAD
	ref: refs/heads/test</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git compresses the new content with zlib, which you can do in Ruby with the zlib library.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T200734Z" changeid="juan">
        <seg>Git  comprime todo el contenido con zlib. Y tu puedes hacer lo mismo en Ruby con la libreria zlib.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In this section, you’ll learn about a few common patterns for contributing to a project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En esta sección, aprenderás acerca de las formas más habituales de contribuir a un proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now John can clone the project and get updates, but Gitosis won’t allow him to push back up to the project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Habilitandole así para clonar y recibir actualizaciónes desde el servidor; pero impidiendole enviar de vuelta cambios al proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When you clone a repository, it generally automatically creates a `master` branch that tracks `origin/master`.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cuando clonas un repositorio, este suele crear automáticamente una rama 'master' que hace seguimiento de 'origin/master'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>commit fdf4fc3344e67ab068f836878b6c4951e3b15f3d
	Author: Scott Chacon &lt;schacon@gmail.com&gt;
	Date:   Fri May 22 18:09:34 2009 -0700</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T180414Z" changeid="juan">
        <seg>commit fdf4fc3344e67ab068f836878b6c4951e3b15f3d
	Author: Scott Chacon &lt;schacon@gmail.com&gt;
	Date:   Fri May 22 18:09:34 2009 -0700</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git commit -am 'test'
	[POLICY] Your message is not formatted correctly</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git commit -am 'test'
	[POLICY] Your message is not formatted correctly</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now you have a list of the remote references and SHAs.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110817T221742Z" changeid="juan">
        <seg>A partir de ahi, ya tienes una lista de las referencias remotas y sus SHAs.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you create a simple branch name based on the theme of the work you’re going to try, such as `ruby_client` or something similarly descriptive, you can easily remember it if you have to abandon it for a while and come back later.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si creas los nombres de ramas basandolos en el tema sobre el que vas a trabajar, por ejemplo 'ruby client' o algo así de descriptivo, podrás recordar de qué iba cada rama en caso de que la abandones por un tiempo y la retomes más tarde.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If the update script exits non-zero, only that reference is rejected; other references can still be updated.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si el script 'update' termina con un código de salida distinto de cero, únicamente los cambios de esa rama son rechazados; el resto de ramas continuarán con sus actualizaciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If the server you’re running it on is inside your firewall, you might use it for projects that a large number of people or computers (continuous integration or build servers) have read-only access to, when you don’t want to have to add an SSH key for each.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si lo estás utilizando en un servidor dentro del perímetro de tu cortafuegos, puedes utilizarlo para proyectos donde un gran número de personas o de ordenadores (integración contínua o servidores de desarrollo) necesiten acceso de solo lectura. Y donde quieras evitar la gestión de claves SSH para cada una de ellas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git reset HEAD^
	$ git add README
	$ git commit -m 'updated README formatting'
	$ git add lib/simplegit.rb
	$ git commit -m 'added blame'
	$ git rebase --continue</seg>
      </tuv>
      <tuv lang="ES" changedate="20120728T093627Z" changeid="juan">
        <seg>$ git reset HEAD^
	$ git add README
	$ git commit -m 'updated README formatting'
	$ git add lib/simplegit.rb
	$ git commit -m 'added blame'
	$ git rebase --continue</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you want to delete your `serverfix` branch from the server, you run the following:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por ejemplo, si quieres borrar la rama 'serverfix' del servidor, puedes utilizar:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### A SHORT NOTE ABOUT SHA-1 ###</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T095212Z" changeid="juan">
        <seg>### Un breve comentario sobre los códigos SHA-1 ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Then, you can merge those changes back into your master branch.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T163145Z" changeid="juan">
        <seg>Tras lo cual, es posible fusionar esos cambios de vuelta a la rama 'master'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Enforcing Policies...
	(refs/heads/master) (8338c5) (c5b616)
	[POLICY] Cannot push a non-fast-forward reference
	error: hooks/update exited with error code 1
	error: hook declined to update refs/heads/master
	To git@gitserver:project.git
	 !</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Enforcing Policies...
	(refs/heads/master) (8338c5) (c5b616)
	[POLICY] Cannot push a non-fast-forward reference
	error: hooks/update exited with error code 1
	error: hook declined to update refs/heads/master
	To git@gitserver:project.git
	 !</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You’ll build client scripts that help the developer know if their push will be rejected and server scripts that actually enforce the policies.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para ello, has de preparar los correspondientes scripts de cliente (para ayudar a los desarrolladores a saber de antemano si sus envios van a ser rechazados o no), y los correspondientes scripts de servidor (para obligar a cumplir esas políticas).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The main difference is that a tag object points to a commit rather than a tree.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T112245Z" changeid="juan">
        <seg>Su principal diferencia reside en que apunta a una confirmación de cambios (commit) en lugar de a un árbol (tree).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You may use it in conjunction with a commit template to programmatically insert information.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Se puede utilizar combinandolo con una plantilla de confirmación, para poder insertar información automáticamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>I’ll use path names in the examples that work on Mac and Linux systems; for Windows, you’ll have to change `/usr/local/bin` to an executable path in your environment.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Los nombres de carpetas que utilizaré en los ejemplos funcionan en sistemas Mac y Linux; para Windows, tendrás que sustituir '/usr/local/bin' por el correspondiente camino al ejecutable en tu sistema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ mkdir test
	$ cd test
	$ git init
	Initialized empty Git repository in /tmp/test/.git/
	$ find .git/objects
	.git/objects
	.git/objects/info
	.git/objects/pack
	$ find .git/objects -type f
	$</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ mkdir test
	$ cd test
	$ git init
	Initialized empty Git repository in /tmp/test/.git/
	$ find .git/objects
	.git/objects
	.git/objects/info
	.git/objects/pack
	$ find .git/objects -type f
	$</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The workflow required in order to contribute to a project is much different if you have write access to the project than if you don’t.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La forma de trabajar y de contribuir a un proyecto es totalmente diferente dependiendo de si tienes o no acceso de escritura al proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you run `git add` with the `-i` or `--interactive` option, Git goes into an interactive shell mode, displaying something like this:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120712T201050Z" changeid="juan">
        <seg>Al lanzar el comando 'git add' con las opciones '-i' o '--interactive', Git entra en un modo interactivo y muestra algo así como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It also handles file adds, deletes, and renames if they’re described in the `git diff` format, which `patch` won’t do.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Además, es capaz de manejar adicciones, borrados o renombrados de archivos, si vienen en formato 'git diff'. Mientras que 'patch' no puede hacerlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>files_modified = `git log -1 --name-only --pretty=format:'' #{ref}`</seg>
      </tuv>
      <tuv lang="ES">
        <seg>files_modified = `git log -1 --name-only --pretty=format:'' #{ref}`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>However, that result is of limited use.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Pero esto tiene un uso bastante limitado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>As long as each user can get shell access on the machine, any SSH authentication mechanism you can think of should work.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tan solo con que cada usuario pueda tener acceso al shell de la máquina, es válido cualquier mecanismo de autentificación SSH que se emplee para ello.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Tags ###</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T233452Z" changeid="juan">
        <seg>### Etiquetas ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In some contexts, the first line is treated as the
	subject of an email and the rest of the text as the body.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En algunos contextos, la primera línea se tratará como si fuera el asundo de un correo electrónico y el resto del texto como si fuera el cuerpo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>At this point, other users who have SSH access to the same server which has read-access to the `/opt/git` directory can clone your repository by running</seg>
      </tuv>
      <tuv lang="ES">
        <seg>A partir de entonces, cualquier otro usuario con acceso de lectura SSH a la carpeta '/opt/git' del servidor, podrá clonar el repositorio con la orden:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To do this, you can add the `commit-msg` hook.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para ello, se añade el enganche 'commit-msg'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git init
	$ git add .</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git init
	$ git add .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git remote add jessica git://github.com/jessica/myproject.git
	$ git fetch jessica
	$ git checkout -b rubyclient jessica/ruby-client</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git remote add jessica git://github.com/jessica/myproject.git
	$ git fetch jessica
	$ git checkout -b rubyclient jessica/ruby-client</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can do so with the `sed` command on Unix systems:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En los sistemas Unix, lo puedes realizar con el comando 'sed':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can also set these values by manually editing the file and inserting the correct syntax, but it’s generally easier to run the `git config` command.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>También puedes ajustar estas configuraciones manualmente, editando directamente los archivos correspondientes y escribiendo en ellos con la sintaxis correspondiente; pero suele ser más sencillo hacerlo siempre a través del comando 'git config'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Assuming you saved the patch at `/tmp/patch-ruby-client.patch`, you can apply the patch like this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Suponiendo que has guardado el parche en '/tmp/patch-ruby-client.patch', puedes incorporarlo con una orden tal como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If your IMAP server doesn’t use SSL, the last two lines probably aren’t necessary, and the host value will be `imap://` instead of `imaps://`.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Las dos últimas líneas probablente no sean necesarias si tu servidor IMAP no utiliza SSL; y, en ese caso, el valor para `host` deberá de ser `imap://` en lugar de `imaps://`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In the default case that is automatically written by a `git remote add` command, Git fetches all the references under `refs/heads/` on the server and writes them to `refs/remotes/origin/` locally.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T115219Z" changeid="juan">
        <seg>En el caso por defecto en que es escrito por un comando `git remote add`, Git recupera del servidor todas las referencias bajo `refs/heads/`, y las escribe localmente en `refs/remotes/origin/`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you pass the option `--system` to `git config`, it reads and writes from this file specifically.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Con la opción '--system' del comando 'git config', puedes leer y escribir de/a este archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you mistype a command in Git 1.6, it shows you something like this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cada vez que tienes un error de tecleo en un comando, Git 1.6 te muestra algo como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You do this by running the `gitosis-init` command with your personal public key.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Lo puedes hacer lanzando el comando 'gitosis-init' con tu clave pública personal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Let’s see why you should do so.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y vamos a ver el por qué merece la pena hacerlo así.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>or you can edit your `~/.gitconfig` file to add these lines:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>o puedes editar tu archivo '~/.gitconfig' para añadirle las siguientes lineas:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>At this point, you have to merge this work in again, even though you’ve already done so.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En ese momento, tu te ves obligado a fusionar (merge) tu trabajo de nuevo, aunque creias que ya lo habias hecho antes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git checkout master
	$ git merge client</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git checkout master
	$ git merge client</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To begin, you’ll set up external wrapper scripts to run your commands.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para empezar, tienes que preparar los correspondientes scripts para lanzar tus comandos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>With these tools, you can much more easily let Git know what commit or commits you want to inspect.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T091233Z" changeid="juan">
        <seg>Con estas herramientas, es mucho más sencillo indicar con precisión cual o cuales son las confirmaciones de cambios que se desean revisar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>jessica@example.com
	Message-ID to be used as In-Reply-To for the first email?</seg>
      </tuv>
      <tuv lang="ES">
        <seg>jessica@example.com
	Message-ID to be used as In-Reply-To for the first email?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0517.png
Figure 5-17.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0517.png
Figura 5-17.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In newer versions of Git (beginning with version 1.6.1), you can set `receive.denyDeletes` to true:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En las últimas versiones de Git (a partir de la 1.6.1), se puede evitar poniendo a 'true' el parámetro 'receive.denyDeletes':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>remote: Total 3 (delta 1), reused 2 (delta 0)
	Unpacking objects: 100% (3/3), done.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T110300Z" changeid="juan">
        <seg>remote: Total 3 (delta 1), reused 2 (delta 0)
	Unpacking objects: 100% (3/3), done.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git checkout -b featureB origin/master
	$ (work)
	$ git commit
	$ git push myfork featureB
	$ (email maintainer)
	$ git fetch origin</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git checkout -b featureB origin/master
	$ (work)
	$ git commit
	$ git push myfork featureB
	$ (email maintainer)
	$ git fetch origin</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Conceptually, the data that Git is storing is something like Figure 9-1.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110801T121413Z" changeid="juan">
        <seg>Conceptualmente, la información almacenada por Git es algo similar a la Figura 9-1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When you run `git init` in a new or existing directory, Git creates the `.git` directory, which is where almost everything that Git stores and manipulates is located.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110717T112326Z" changeid="juan">
        <seg>Cuando lanzas 'git init' sobre una carpeta nueva o sobre una ya existente, Git crea la carpeta auxiliar '.git'; la carpeta  donde se ubica prácticamente todo lo almacenado y manipulado por Git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git config --global filter.indent.clean indent
	$ git config --global filter.indent.smudge cat</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git config --global filter.indent.clean indent
	$ git config --global filter.indent.smudge cat</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>That is a special mode in Git that basically means you’re recording a commit as a directory entry rather than a subdirectory or a file.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T105401Z" changeid="juan">
        <seg>Este es un modo especial de Git, un modo en el que la confirmación de cambio se almacena como una carpeta en lugar de como una subcarpeta o un archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You have three trees that specify the different snapshots of your project that you want to track, but the earlier problem remains: you must remember all three SHA-1 values in order to recall the snapshots.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T145118Z" changeid="juan">
        <seg>Tienes tres árboldes que representan diferentes momentos interesantes de tu proyecto, pero el problema principal sigue siendo el estar obligado a recordar los tres valores SHA-1 para poder recuperar cualquiera de esos momentos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you want Git instead to pull down only the `master` branch each time, and not every other branch on the remote server, you can change the fetch line to</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T115331Z" changeid="juan">
        <seg>Si, en cambio, quisieras hacer que Git recupere únicamente la rama `master` y no cualquier otra rama en el servidor remoto. Puedes cambiar la linea de recuperación a </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Ancestry References ###</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T191436Z" changeid="juan">
        <seg>### Referencias a ancestros ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0519.png
Figure 5-19.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0519.png
Figura 5-19.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In the next few sections, you’ll see how to expand to more sophisticated setups.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En los siguientes apartados, se mostrará como ir más allá y preparar disposiciones más sofisticadas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To see the last commit on each branch, you can run `git branch –v`:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para ver la última confirmación de cambios en cada rama, puedes usar el comando 'git branch -v':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Gitosis can also control which projects GitWeb shows.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>También podemos controlar a través de Gitosis los proyectos a ser mostrados por GitWeb.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The `Author` information is the individual who originally created the patch and when it was originally created.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El campo 'Author' muestra la persona que ha creado originalmente el parche y cuándo fue creado este.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In other words, in this case, you don’t have a new `serverfix` branch — you only have an `origin/serverfix` pointer that you can’t modify.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En otras palabras, en este caso, no tienes una nueva rama 'serverfix'. Sino que únicamente tienes un puntero no editable a 'origin/serverfix'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you clone from this, Git automatically names it `origin` for you, pulls down all its data, creates a pointer to where its `master` branch is, and names it `origin/master` locally; and you can’t move it.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si haces un clón desde ahí, Git automáticamente lo denominará 'origin', traerá (pull) sus datos, creará un apuntador hacia donde esté en ese momento su rama 'master', denominará la copia local 'origin/master'; y será inamovible para tí. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Server Configuration ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Configuración de Servidor ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Forking Projects ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Bifurcando proyectos ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>{&quot;defunkt&quot;=&gt;[nil],
	 &quot;tpw&quot;=&gt;[nil],
	 &quot;nickh&quot;=&gt;[nil],
	 &quot;pjhyett&quot;=&gt;[nil],
	 &quot;schacon&quot;=&gt;[&quot;lib&quot;, &quot;tests&quot;],
	 &quot;cdickens&quot;=&gt;[&quot;doc&quot;],
	 &quot;usinclair&quot;=&gt;[&quot;doc&quot;],
	 &quot;ebronte&quot;=&gt;[&quot;doc&quot;]}</seg>
      </tuv>
      <tuv lang="ES">
        <seg>{&quot;defunkt&quot;=&gt;[nil],
	 &quot;tpw&quot;=&gt;[nil],
	 &quot;nickh&quot;=&gt;[nil],
	 &quot;pjhyett&quot;=&gt;[nil],
	 &quot;schacon&quot;=&gt;[&quot;lib&quot;, &quot;tests&quot;],
	 &quot;cdickens&quot;=&gt;[&quot;doc&quot;],
	 &quot;usinclair&quot;=&gt;[&quot;doc&quot;],
	 &quot;ebronte&quot;=&gt;[&quot;doc&quot;]}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For example, suppose you have a project that looks like Figure 5-26.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por ejemplo, suponiendo que tienes un proyecto parecido al ilustrado en la Figura 5-26.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git bisect start HEAD v1.0
	$ git bisect run test-error.sh</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T073427Z" changeid="juan">
        <seg>$ git bisect start HEAD v1.0
	$ git bisect run test-error.sh</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Next you need to turn your shell back on for the 'git' user, if you changed it to the `git-shell` command.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>A continuación, restaura el inicio de sesión (shell) para el usuario 'git', (si es que lo habias cambiado al comando 'git-shell').</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can also use the refspec to delete references from the remote server by running something like this:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110817T154442Z" changeid="juan">
        <seg>Se pueden utilizar las referencias (refspec) para borrar en el servidor remoto. Por ejemplo, lanzando algo como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>She creates a new branch for the feature and does some work on it there:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Crea una nueva rama para dicha funcionalidad y trabaja en ella:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The Linux kernel also has a non-commit-pointing tag object — the first tag created points to the initial tree of the import of the source code.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T235059Z" changeid="juan">
        <seg>El kernel de Linux tiene también un objeto tipo etiqueta apuntando a un objeto que no es una confirmación de cambios (commit). La primera etiqueta que se creó es la que apunta al árbol (tree) inicial donde se importó el código fuente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>That drops you into your text editor, which has your last commit message in it, ready for you to modify the message.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120728T080849Z" changeid="juan">
        <seg>Mediante este comando, el editor de textos arranca con el mensaje escrito en la última confirmación de cambios; listo para ser modificado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git allows you to do this by using either the `^` character or `--not` before any reference from which you don’t want to see reachable commits.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T091037Z" changeid="juan">
        <seg>Git permite realizar esto utilizando o bien el caracter `^` o bien la opción `--not` por delante de aquellas referencias de las que se desea no ver las confirmaciones de cambio. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The other main ancestry specification is the `~`.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T114421Z" changeid="juan">
        <seg>Otra forma de referirse a los ancestros es la marca `~`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Let’s switch to the new testing branch:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Hagamos una prueba, saltando a la rama 'testing' recién creada:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The other important difference is the way you get a listing of the files that have been changed.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La segunda diferencia es la forma de listar los archivos modificados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The majority of the options are client side—configuring your personal working preferences.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La mayoria de las opciones están en el lado cliente, --configurando tus preferencias personales de trabajo--.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This can be a huge problem when you’re converting Subversion or Perforce repositories into Git.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T103753Z" changeid="juan">
        <seg>Esto suele dar bastantes problemas cuando estás convirtiendo repositorios de Subversion o de Perforce a Git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git submodule init
	Submodule 'rack' (git://github.com/chneukirchen/rack.git) registered for path 'rack'
	$ git submodule update
	Initialized empty Git repository in /opt/myproject/rack/.git/
	remote: Counting objects: 3181, done.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T105819Z" changeid="juan">
        <seg>$ git submodule init
	Submodule 'rack' (git://github.com/chneukirchen/rack.git) registered for path 'rack'
	$ git submodule update
	Initialized empty Git repository in /opt/myproject/rack/.git/
	remote: Counting objects: 3181, done.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you want to run the web interface on a server all the time for your team or for an open source project you’re hosting, you’ll need to set up the CGI script to be served by your normal web server.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si quieres disponer permanentemente de un interface web para tu equipo o para un proyecto de código abierto que alberges, necesitarás ajustar el script CGI para ser servido por tu servidor web habitual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you look at the `gitosis.conf` file, it should only specify information about the `gitosis-admin` project that you just cloned:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si miras dentro del archivo 'gitosis.conf', encontrarás únicamente información sobre el proyecto 'gitosis-admin' que acabas de clonar:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This opens a vast range of workflow possibilities for your project and/or your team, so I’ll cover a few common paradigms that take advantage of this flexibility.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto abre un enorme rango de posibles formas de trabajo en tu proyecto y/o en tu equipo. Aquí vamos a revisar algunos de los paradigmas más comunes diseñados para sacar ventaja a esta gran flexibilidad.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Figure 3-8 shows the result.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La Figura 3-8 muestra el resultado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git update-ref refs/tags/v1.0 cac0cab538b970a37ea1e769cbbde608743bc96d</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T234002Z" changeid="juan">
        <seg>$ git update-ref refs/tags/v1.0 cac0cab538b970a37ea1e769cbbde608743bc96d</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The Git protocol is far more efficient and thus faster than the HTTP protocol, so using it will save your users time.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El protocolo Git es mucho más eficiente y, por tanto, más rápido que el protocolo HTTP. Utilizándolo, ahorrarás mucho tiempo a tus usuarios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Last we have the HTTP protocol.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por último, tenemos el protocolo HTTP.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>All you have to do is switch back to your master branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Basta con saltar de nuevo a la rama 'master' y continuar trabajando a partir de ella.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To enable a hook script, put a file in the `hooks` subdirectory of your Git directory that is named appropriately and is executable.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para activar un punto de enganche para un script, pon el archivo correspondiente en la carpeta 'hooks'; con el nombre adecuado y con la marca de ejecutable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You should have a pretty good understanding of what Git does in the background and, to some degree, how it’s implemented.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T141016Z" changeid="juan">
        <seg>A estas alturas deberias tener una idea bastante clara de como trabaja Git entre bastidores. Y, hasta cierto punto, sobre cómo está implementado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In this case, your development history has diverged from some older point.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En este caso, el registro de desarrollo habia divergido en un punto anterior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git checkout master
	Switched to branch &quot;master&quot;</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git checkout master
	Switched to branch &quot;master&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Take the contents of the public key of that pair, and paste it into the SSH Public Key text box.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Pero, si ya tienes un par de claves SSH, puedes coger el contenido correspondiente a la clave pública y pegarlo en la caja de texto preparada para tal fin.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To set up a local branch with a different name than the remote branch, you can easily use the first version with a different local branch name:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para preparar una rama local con un nombre distinto a la del remoto, puedes utilizar:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Finally, the server responds with a success (or failure) indication:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T074909Z" changeid="juan">
        <seg>Y, por ultimo, el servidor responde con un indicador de éxito (o fracaso) de la operación:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ sudo -H -u git gitosis-init &lt; /tmp/id_dsa.pub
	Initialized empty Git repository in /opt/git/gitosis-admin.git/
	Reinitialized existing Git repository in /opt/git/gitosis-admin.git/</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ sudo -H -u git gitosis-init &lt; /tmp/id_dsa.pub
	Initialized empty Git repository in /opt/git/gitosis-admin.git/
	Reinitialized existing Git repository in /opt/git/gitosis-admin.git/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## Subtree Merging ##</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T140416Z" changeid="juan">
        <seg>## Fusión de subárboles ##</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Fetch more commits, and merge them into your work.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Traer (fetch) algunas confirmaciones de cambio (commits) y fusionarlas (merge) sobre tu trabajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ cd project.git
	$ mv hooks/post-update.sample hooks/post-update
	$ chmod a+x hooks/post-update</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ cd project.git
	$ mv hooks/post-update.sample hooks/post-update
	$ chmod a+x hooks/post-update</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now that you’re here, let’s get started.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y, ahora que estamos aquí, comencemos con el tema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git config --global user.name &quot;John Doe&quot;
	$ git config --global user.email johndoe@example.com</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git config --global user.name &quot;John Doe&quot;
	$ git config --global user.email johndoe@example.com</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This may be a bit confusing, so let’s look at an example.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto puede ser un tanto confuso, pero intentemos aclararlo con un ejemplo. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Your iss53 branch can move forward independently.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La rama 'iss53' puede avanzar independientemente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>However, there are other strategies you can choose as well.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T141203Z" changeid="juan">
        <seg>Pero existen también otras estratégias que se pueden escoger según se necesiten.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>#### update ####</seg>
      </tuv>
      <tuv lang="ES">
        <seg>#### update ####</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you go back to an earlier example from the Merge section (see Figure 3-27), you can see that you diverged your work and made commits on two different branches.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Volviendo al ejemplo anterior, en la sección sobre fusiones (ver Figura 3-27), puedes ver que has separado  tu trabajo y realizado confirmaciones (commit) en dos ramas diferentes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Total 7 (delta 2), reused 4 (delta 1)
	To git@github.com:schacon/simplegit-progit.git
	   a11bef0..ca82a6d  master -&gt; master</seg>
      </tuv>
      <tuv lang="ES" changedate="20110810T224918Z" changeid="juan">
        <seg>Total 7 (delta 2), reused 4 (delta 1)
	To git@github.com:schacon/simplegit-progit.git
	   a11bef0..ca82a6d  master -&gt; master</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Chapter 6 describes a number of useful Git tricks for rewriting history and interactively staging files — use these tools to help craft a clean and understandable history.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El Capítulo 6 contiene un gran número de trucos para reescribir el historial e ir preparando archivos interactivamente --utilizalos para ayudarte a crear un claro y comprensible historial--.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you don’t have write access, how does the project prefer to accept contributed work?</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si no tienes acceso de escritura, ¿cuál es el sistema preferido del proyecto para aceptar contribuciones?.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This hook takes a few options: the path to the file that holds the commit message so far, the type of commit, and the commit SHA-1 if this is an amended commit.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Este punto de enganche recibe varias entradas: la ubicación (path) del archivo temporal donde se almacena el mensaje de confirmación, el tipo de confirmación y la clave SHA-1 si estamos enmendando un commit existente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For now, move the `authorized_keys` file out of the way:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para empezar, mueve el archivo 'authorized_keys a otro lado:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git add date_test.txt .gitattributes
	$ git commit -m &quot;Testing date expansion in Git&quot;
	$ rm date_test.txt
	$ git checkout date_test.txt
	$ cat date_test.txt
	# $Date: Tue Apr 21 07:26:52 2009 -0700$</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git add date_test.txt .gitattributes
	$ git commit -m &quot;Testing date expansion in Git&quot;
	$ rm date_test.txt
	$ git checkout date_test.txt
	$ cat date_test.txt
	# $Date: Tue Apr 21 07:26:52 2009 -0700$</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>All the content is stored as tree and blob objects, with trees corresponding to UNIX directory entries and blobs corresponding more or less to inodes or file contents.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T143848Z" changeid="juan">
        <seg>Todo el contenido se guarda como objetos arbol (tree) u objetos binarios (blob). Correspondiendo los árboles a las entradas de carpetas; y correspondiendo los binarios, mas o menos, a los contenidos de los archivos (inodes).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You must indicate how far back you want to rewrite commits by telling the command which commit to rebase onto.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120728T083714Z" changeid="juan">
        <seg>La profundidad en la historia a modificar vendrá dada por la confirmación de cambios (commit) que se indique al comando.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg># Git Tools #</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T095002Z" changeid="juan">
        <seg># Las herramientas de Git #</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>#### Committing-Workflow Hooks ####</seg>
      </tuv>
      <tuv lang="ES">
        <seg>#### Puntos en el flujo de trabajo de confirmación de cambios ####</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>=&gt; GET HEAD
	ref: refs/heads/master</seg>
      </tuv>
      <tuv lang="ES" changedate="20110817T221841Z" changeid="juan">
        <seg>=&gt; GET HEAD
	ref: refs/heads/master</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The general sequence is something like that shown in Figure 5-11.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La secuencia general es algo así como la mostrada en la Figura 5-11.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you want to use subprojects in your project, you’ve learned a few ways to accommodate those needs.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T173926Z" changeid="juan">
        <seg>En caso de requerir tener subproyectos dentro de un proyecto principal, se han visto unos cuantos caminos para resolver este requerimiento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Your commit history with multiple topic branches.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El registro de confirmaciones con múltiples ramas puntuales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The downside of the Git protocol is the lack of authentication.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La pega del protocolo Git, es su falta de autentificación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Creating a new branch pointer.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Creación de un apuntador a la nueva rama.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>By convention, bare repository directories end in `.git`, like so:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por convenio, los nombres de los repositorios básicos suelen terminar en '.git', por lo que lanzaremos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Again, this will cause a `git push origin` to push the local `master` branch to the remote `qa/master` branch by default.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110817T154116Z" changeid="juan">
        <seg>Esto hará que un simple comando `git push origin` envie por defecto la rama local  `master` a la rama remota `qa/master`,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The main drawback to this approach is that it can be very slow and is often unnecessary — if you don’t try to force the push with `-f`, the server will warn you and not accept the push.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La mayor pega de este sistema es el que puede llegar a ser muy lento; y muchas veces es innecesario, ya que el propio servidor te va a avisar y te impedirá el envio, siempre y cuando no intentes forzar dicho envio con la opción '-f'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## Gitosis ##</seg>
      </tuv>
      <tuv lang="ES">
        <seg>## Gitosis ##</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>John’s initial repository.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El repositorio inicial de John.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ scp -r my_project.git user@git.example.com:/opt/git</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ scp -r my_project.git user@git.example.com:/opt/git</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The project maintainer pushes to their public repository.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La persona gestora del proyecto envia (push) a su repositorio público (repositorio principal).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This goes through and rewrites every commit to have your new address.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T200259Z" changeid="juan">
        <seg>Este comando pasa por todo el repositorio y reescribe cada confirmación de cambios donde detecte la dirección de correo indicada, para reemplazarla por la nueva.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>commit 7482e0d16d04bea79d0dba8988cc78df655f16a0
	Author: Scott Chacon &lt;schacon@gmail.com&gt;
	Date:   Mon Oct 22 19:38:36 2008 -0700</seg>
      </tuv>
      <tuv lang="ES">
        <seg>commit 7482e0d16d04bea79d0dba8988cc78df655f16a0
	Author: Scott Chacon &lt;schacon@gmail.com&gt;
	Date:   Mon Oct 22 19:38:36 2008 -0700</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The Git project has four long-running branches: `master`, `next`, and `pu` (proposed updates) for new work, and `maint` for maintenance backports.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El proyecto Git tiene cuatro ramas de largo recorrido: 'master', 'next', 'pu' (proposed updates) para el trabajo nuevo, y 'maint' (maintenance) para trabajos de mantenimiento de versiones previas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Compressing objects: 100% (16/16), done.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T104823Z" changeid="juan">
        <seg>Compressing objects: 100% (16/16), done.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you’re describing a commit that you have directly tagged, it gives you the tag name.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si solicitas descripción de una confirmación de cambios (commit) etiquetada directamente con su propia etiqueta particular, obtendrás dicha etiqueta como descripción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It’s time to e-mail your mailing list of people who want to know what’s happening in your project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Ya va siendo hora de enviar un mensaje a tu lista de correo, informando a las personas que desean conocer la marcha de tu proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Next you can create a new repository.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>A continuación, puedes crear nuevos repositorios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>After you do that, your commit history will contain both the C4 and C4' commits, which have different SHA-1 hashes but introduce the same work and have the same commit message.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tras todo esto, tu registro de confirmaciones de cambio (commit history) contendrá tanto la confirmación C4 como la C4'; teniendo ambas el mismo contenido y el mismo mensaje de confirmación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>[group gitosis-admin]
	writable = gitosis-admin
	members = scott</seg>
      </tuv>
      <tuv lang="ES">
        <seg>[group gitosis-admin]
	writable = gitosis-admin
	members = scott</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git archive master --prefix='project/' --format=zip &gt; `git describe master`.zip</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git archive master --prefix='project/' --format=zip &gt; `git describe master`.zip</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0501.png
Figure 5-1.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0501.png
Figura 5-1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Create a branch to add the hotfix.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Creas una nueva rama para el problema crítico y lo resuelves trabajando en ella.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>From git@github.com:schacon/rack
	   08d709f..6c5e70b  master     -&gt; origin/master
	Submodule path 'rack': checked out '6c5e70b984a60b3cecd395edd5b48a7575bf58e0'</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T110302Z" changeid="juan">
        <seg>From git@github.com:schacon/rack
	   08d709f..6c5e70b  master     -&gt; origin/master
	Submodule path 'rack': checked out '6c5e70b984a60b3cecd395edd5b48a7575bf58e0'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can also run `git stash pop` to apply the stash and then immediately drop it from your stack.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120712T210049Z" changeid="juan">
        <seg>También es posible utilizar el comando `git stash pop`,  que aplica cambios de un guardado y lo retira inmediatamente de la pila.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you run `git status`, you can see your dirty state:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120712T202538Z" changeid="juan">
        <seg>Al lanzar el comando 'git status', se podría observar un estado inconsistente tal como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Colors in Git ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Colores en Git ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Splitting a commit undoes a commit and then partially stages and commits as many times as commits you want to end up with.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T190224Z" changeid="juan">
        <seg>Dividir una confirmación de cambios (commit), implica deshacerla y luego volver a preparar y confirmar trozos de la misma tantas veces como nuevas confirmaciones se desean tener al final. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The command is `filter-branch`, and it can rewrite huge swaths of your history, so you probably shouldn’t use it unless your project isn’t yet public and other people haven’t based work off the commits you’re about to rewrite.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T190809Z" changeid="juan">
        <seg>El comando en cuestión es `filter-branch`, y permite reescribir automáticamente grandes porciones del historial. Precisamente por ello, no debería utilizarse a no ser que el proyecto aún no se haya hecho público (es decir, otras personas no han basado su trabajo en alguna de las confirmaciones de cambio que se van a modificar).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>(mbox) Adding cc: Jessica Smith &lt;jessica@example.com&gt; from
	  \line 'From: Jessica Smith &lt;jessica@example.com&gt;'
	OK.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>(mbox) Adding cc: Jessica Smith &lt;jessica@example.com&gt; from
	  \line 'From: Jessica Smith &lt;jessica@example.com&gt;'
	OK.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It takes the same stdin data as the `pre-receive` hook.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Recibe los mismos datos que 'pre-receive' desde la entrada estandar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git config --global core.autocrlf input</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git config --global core.autocrlf input</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In order for a repository to be served over the Git protocol, you must create the `git-export-daemon-ok` file — the daemon won’t serve a repository without that file in it — but other than that there is no security.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para que un repositorio pueda exponerse a través del protocolo Git, tienes que crear en él un archivo 'git-export-daemon-ok'; sin este archivo, el demonio no hará disponible el repositorio. Pero, aparte de esto, no hay ninguna otra medida de seguridad.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To see a full diff of what would happen if you were to merge this topic branch with another branch, you may have to use a weird trick to get the correct results.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para ver plenamente todas las diferencias y lo que sucederá realmente si fusionas esta rama puntual con otra rama, tendrás que utilizar un pequeño truco para obtener los resultados correctos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git blame -C -L 141,153 GITPackUpload.m
	f344f58d GITServerHandler.m (Scott 2009-01-04 141)
	f344f58d GITServerHandler.m (Scott 2009-01-04 142) - (void) gatherObjectShasFromC
	f344f58d GITServerHandler.m (Scott 2009-01-04 143) {
	70befddd GITServerHandler.m (Scott 2009-03-22 144)         //NSLog(@&quot;GATHER COMMI
	ad11ac80 GITPackUpload.m    (Scott 2009-03-24 145)
	ad11ac80 GITPackUpload.m    (Scott 2009-03-24 146)         NSString *parentSha;
	ad11ac80 GITPackUpload.m    (Scott 2009-03-24 147)         GITCommit *commit = [g
	ad11ac80 GITPackUpload.m    (Scott 2009-03-24 148)
	ad11ac80 GITPackUpload.m    (Scott 2009-03-24 149)         //NSLog(@&quot;GATHER COMMI
	ad11ac80 GITPackUpload.m    (Scott 2009-03-24 150)
	56ef2caf GITServerHandler.m (Scott 2009-01-05 151)         if(commit) {
	56ef2caf GITServerHandler.m (Scott 2009-01-05 152)                 [refDict setOb
	56ef2caf GITServerHandler.m (Scott 2009-01-05 153)</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T065945Z" changeid="juan">
        <seg>$ git blame -C -L 141,153 GITPackUpload.m
	f344f58d GITServerHandler.m (Scott 2009-01-04 141)
	f344f58d GITServerHandler.m (Scott 2009-01-04 142) - (void) gatherObjectShasFromC
	f344f58d GITServerHandler.m (Scott 2009-01-04 143) {
	70befddd GITServerHandler.m (Scott 2009-03-22 144)         //NSLog(@&quot;GATHER COMMI
	ad11ac80 GITPackUpload.m    (Scott 2009-03-24 145)
	ad11ac80 GITPackUpload.m    (Scott 2009-03-24 146)         NSString *parentSha;
	ad11ac80 GITPackUpload.m    (Scott 2009-03-24 147)         GITCommit *commit = [g
	ad11ac80 GITPackUpload.m    (Scott 2009-03-24 148)
	ad11ac80 GITPackUpload.m    (Scott 2009-03-24 149)         //NSLog(@&quot;GATHER COMMI
	ad11ac80 GITPackUpload.m    (Scott 2009-03-24 150)
	56ef2caf GITServerHandler.m (Scott 2009-01-05 151)         if(commit) {
	56ef2caf GITServerHandler.m (Scott 2009-01-05 152)                 [refDict setOb
	56ef2caf GITServerHandler.m (Scott 2009-01-05 153)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If, on the other hand, you want to see the opposite — all commits in `master` that aren’t in `experiment` — you can reverse the branch names.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T120605Z" changeid="juan">
        <seg>Si, por el contrario, se desea ver lo opuesto (todas las confirmaciones en 'master' que no están en 'experiment'). Simplemente hay que invertir los nombres de las ramas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This means the version in HEAD (your master branch, because that was what you had checked out when you ran your merge command) is the top part of that block (everything above the `=======`), while the version in your `iss53` branch looks like everything in the bottom part.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Donde nos dice que la versión en HEAD (la rama 'master', la que habias activado antes de lanzar el comando de fusión), contiene lo indicado en la parte superior del bloque (todo lo que está encima de '======='). Y que la versión en 'iss53' contiene el resto, lo indicado en la parte inferior del bloque.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git automatically identifies the best common-ancestor merge base for branch merging.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Git identifica automáticamente el mejor ancestro común para realizar la fusión de las ramas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It may be easier to remember the `~3` because you’re trying to edit the last three commits; but keep in mind that you’re actually designating four commits ago, the parent of the last commit you want to edit:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T122242Z" changeid="juan">
        <seg>La nomenclatura  `~3` es la mas sencilla de recordar, porque lo que se desea es modificar las tres últimas confirmaciones. Pero sin perder de vista que realmente se está señalando a cuatro confirmaciones de cambio más atras, al padre de la última de las confirmaciones de cambio a modificar. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>There are two groups of these hooks: client side and server side.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Hay dos grupos de esos puntos de lanzamiento: los del lado cliente y los del lado servidor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This will give you an idea of what is involved.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Así podrás hacerte una idea de cómo suelen funcionar estos alberges externos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Your first line starts with 005b, which is 91 in hex, meaning that 91 bytes remain on that line.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T074025Z" changeid="juan">
        <seg>La primera de las lineas comienza con 005b, 91 en decimal, indicandonos que hay 91 bytes más en esa línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You’ve accomplished the basic tasks of tracking and committing files, and you’ve harnessed the power of the staging area and lightweight topic branching and merging.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T183823Z" changeid="juan">
        <seg>Se han visto las tareas básicas de seguimiento y confirmación de cambios en archivos. Aprovechando las capacidades del área de preparación (staging area), de las ramas (branches) y de los mecanismos de fusión (merging).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Are all the patches peer-reviewed and approved?</seg>
      </tuv>
      <tuv lang="ES">
        <seg>¿Se revisan y aprueban los parches entre los propios desarrolladores?. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now that it knows the server’s state, your `send-pack` process determines what commits it has that the server doesn’t.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T131904Z" changeid="juan">
        <seg>Con esta información, el proceso `send-pack` ya puede determnar las confirmaciones de cambios (commits) presentes en el servidor. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you’re doing the fetch over SSH, `fetch-pack` instead runs something like this:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T075959Z" changeid="juan">
        <seg>Si en lugar de utilizar el demonio Git, estás utilizando el protocolo SSH. `fetch-pack` lanzará algo como esto: </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The name of the file in `keydir` (in the previous example, `scott.pub`) will be different for you — Gitosis takes that name from the description at the end of the public key that was imported with the `gitosis-init` script.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El nombre del archivo en la carpeta 'keydir' ('scott.pub' en el ejemplo), puede ser diferente en tu instalación, (Gitosis lo obtiene a partir de la descripción existente al final de la clave pública que haya sido importada con el script 'gitosis-init').</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Next, suppose your loss was for some reason not in the reflog — you can simulate that by removing `recover-branch` and deleting the reflog.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T143748Z" changeid="juan">
        <seg>A continuación, supongamos que la pérdida se ha producido por alguna razón que no se refleja en el registro (reflog). Puedes simularlo borrando la rama `recover-branch` y borrando asimismo el registro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now, you need to set up a filter in Git (call it `dater`) and tell it to use your `expand_date` filter to smudge the files on checkout.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tras ello, has de poner un filtro en Git (podemos llamarle 'dater'), e indicarle que use el filtro 'expand_date' para manchar (smudge) los archivos al extraerlos (checkout).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git show ca82a6dff817ec66f44342007202690a93763949
	$ git show topic1</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T190202Z" changeid="juan">
        <seg>$ git show ca82a6dff817ec66f44342007202690a93763949
	$ git show topic1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now that your work is merged in, you have no further need for the `iss53` branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Ahora que todo tu trabajo está ya fusionado con la rama principal, ya no tienes necesidad de la rama 'iss53'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>files_modified = `git diff-index --cached --name-only HEAD`.split(&quot;\n&quot;)
	  files_modified.each do |path|
	    next if path.size == 0
	    has_file_access = false
	    access[$user].each do |access_path|
	    if !access_path || (path.index(access_path) == 0)
	      has_file_access = true
	    end
	    if !has_file_access
	      puts &quot;[POLICY] You do not have access to push to #{path}&quot;
	      exit 1
	    end
	  end
	end</seg>
      </tuv>
      <tuv lang="ES">
        <seg>files_modified = `git diff-index --cached --name-only HEAD`.split(&quot;\n&quot;)
	  files_modified.each do |path|
	    next if path.size == 0
	    has_file_access = false
	    access[$user].each do |access_path|
	    if !access_path || (path.index(access_path) == 0)
	      has_file_access = true
	    end
	    if !has_file_access
	      puts &quot;[POLICY] You do not have access to push to #{path}&quot;
	      exit 1
	    end
	  end
	end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Occasionally, you may have to do some cleanup — make a repository more compact, clean up an imported repository, or recover lost work.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T090746Z" changeid="juan">
        <seg>De vez en cuando, es posible que necesites hacer algo de limpieza, (compactar un repositorio, adecuar un repositorio importado, recuperar trabajo perdido,...).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When you commit, it looks like you have all the Rack files under that subdirectory — as though you copied them in from a tarball.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T150035Z" changeid="juan">
        <seg>Cuando se confirman estos cambios, es como si se tuvieran todos los archivos Rack bajo esa carpeta --como si se hubieran copiado desde un archivo comprimido tarball--</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In other words, use commands.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Es decir, dá órdenes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git bisect good
	b047b02ea83310a70fd603dc8cd7a6cd13d15c04 is first bad commit
	commit b047b02ea83310a70fd603dc8cd7a6cd13d15c04
	Author: PJ Hyett &lt;pjhyett@example.com&gt;
	Date:   Tue Jan 27 14:48:32 2009 -0800</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T072726Z" changeid="juan">
        <seg>$ git bisect good
	b047b02ea83310a70fd603dc8cd7a6cd13d15c04 is first bad commit
	commit b047b02ea83310a70fd603dc8cd7a6cd13d15c04
	Author: PJ Hyett &lt;pjhyett@example.com&gt;
	Date:   Tue Jan 27 14:48:32 2009 -0800</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ ssh -x git@github.com &quot;git-receive-pack 'schacon/simplegit-progit.git'&quot;
	005bca82a6dff817ec66f4437202690a93763949 refs/heads/master report-status delete-refs
	003e085bb3bcb608e1e84b2432f8ecbe6306e7e7 refs/heads/topic
	0000</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T072929Z" changeid="juan">
        <seg>$ ssh -x git@github.com &quot;git-receive-pack 'schacon/simplegit-progit.git'&quot;
	005bca82a6dff817ec66f4437202690a93763949 refs/heads/master report-status delete-refs
	003e085bb3bcb608e1e84b2432f8ecbe6306e7e7 refs/heads/topic
	0000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>At this point, the topics are evaluated to determine whether they’re safe and ready for consumption or whether they need more work.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En un momento dado, las funcionalidades introducidas se evaluan; comprobando si son seguras y si están preparadas para los consumidores; o si, por el contrario, necesitan dedicarles más trabajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This setting was added in Git version 1.5.5; if you have an older version, you’ll have to specify all the color settings individually.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Este parámetro se añadió en la versión 1.5.5 de Git. Si tienes una versión más antigua, tendrás que indicar especificamente todos y cada uno de los colores individualmente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>y - stage this hunk
	n - do not stage this hunk
	a - stage this and all the remaining hunks in the file
	d - do not stage this hunk nor any of the remaining hunks in the file
	g - select a hunk to go to
	/ - search for a hunk matching the given regex
	j - leave this hunk undecided, see next undecided hunk
	J - leave this hunk undecided, see next hunk
	k - leave this hunk undecided, see previous undecided hunk
	K - leave this hunk undecided, see previous hunk
	s - split the current hunk into smaller hunks
	e - manually edit the current hunk
	?</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T214131Z" changeid="juan">
        <seg>y - stage this hunk
	n - do not stage this hunk
	a - stage this and all the remaining hunks in the file
	d - do not stage this hunk nor any of the remaining hunks in the file
	g - select a hunk to go to
	/ - search for a hunk matching the given regex
	j - leave this hunk undecided, see next undecided hunk
	J - leave this hunk undecided, see next hunk
	k - leave this hunk undecided, see previous undecided hunk
	K - leave this hunk undecided, see previous hunk
	s - split the current hunk into smaller hunks
	e - manually edit the current hunk
	?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The interactive rebase gives you a script that it’s going to run.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120728T085410Z" changeid="juan">
        <seg>La reorganización interactiva lanza un script.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To get it running without having to reboot, you can run this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para arrancarlo sin necesidad de reiniciar la máquina, puedes utilizar el comando:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When you make changes and commit in that subdirectory, the superproject notices that the HEAD there has changed and records the exact commit you’re currently working off of; that way, when others clone this project, they can re-create the environment exactly.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T171107Z" changeid="juan">
        <seg>Cuando se realizan y confirman cambios en esa subcarpeta, el proyecto padre detecta el cambio en HEAD y almacena la confirmación de cambios concreta en la que se esté trabajando en ese momento. De esta forma, cuando otras personas clonen este proyecto, sabrán cómo recrear exactamente el entorno.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can see how powerful this technique can be for customized applications.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esta es una muestra de lo poderosa que puede resultar esta técnica para aplicaciones personalizadas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For example, say you have some test files in a `test/` subdirectory, and it doesn’t make sense to include them in the tarball export of your project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por ejemplo, digamos que tienes algunos archivos de pruebas en la carpeta 'test/', y que no tiene sentido incluirlos en los archivos comprimidos (tarball) al exportar tu proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>remote: Compressing objects: 100% (1534/1534), done.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T105821Z" changeid="juan">
        <seg>remote: Compressing objects: 100% (1534/1534), done.remote: Compressing objects: 100% (1534/1534), done.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This section will cover some of these scenarios.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T090802Z" changeid="juan">
        <seg>En ese apartado vamos a ver algunos de esos escenarios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It should be fairly straightforward to determine which solution or combination of solutions is appropriate for you and your organization.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>No te será dificil el determinar cual de estas soluciones o combinación de soluciones es apropiada para tí y para tu organización.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The entire output of this process looks like this:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110817T224904Z" changeid="juan">
        <seg>La salida completa de todo el proceso es algo como esto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Another common case is that you forgot to run `git config` to set your name and e-mail address before you started working, or perhaps you want to open-source a project at work and change all your work e-mail addresses to your personal address.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T180723Z" changeid="juan">
        <seg>Otra utilidad típica para utilizar `filter-branch` es cuando alguien ha olvidado ejecutar `git config` para configurar su nombre y dirección de correo electrónico antes de comenzar a trabajar. O cuando se va a pasar a código abierto un proyecto, pero previamente se desea cambiar todas las direcciones de correo empresariales por direcciones personales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## Rewriting History ##</seg>
      </tuv>
      <tuv lang="ES" changedate="20120728T074720Z" changeid="juan">
        <seg>## Reescribiendo la historia ##</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>you have to use</seg>
      </tuv>
      <tuv lang="ES">
        <seg>tenemos que utilizar </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now, your Git database conceptually looks something like Figure 9-4.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T191519Z" changeid="juan">
        <seg>En estos momentos, tu base de datos Git se parecerá conceptualmente a la figura 9-4.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>#### receive.fsckObjects ####</seg>
      </tuv>
      <tuv lang="ES">
        <seg>#### receive.fsckObjects ####</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The easiest way to integrate the branches, as we’ve already covered, is the `merge` command.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La manera más sencilla de integrar ramas, tal y como hemos visto, es el comando 'git merge'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you examine the log of a rebased branch, it looks like a linear history: it appears that all the work happened in series, even when it originally happened in parallel.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si examinas el registro de una rama reorganizada, este aparece siempre como un registro lineal: como si todo el trabajo se hubiera realizado en series, aunque realmente se haya hecho en paralelo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>There are a couple of minor differences in the configuration file; but for your purpose, this is close to the same thing.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Realmente hay un par de pequeñas diferencias en el archivo de configuración; pero, a efectos prácticos es casi lo mismo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>A benefit of this approach is that you can more specifically define the relationships between the projects with tags and branches in the superprojects.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T132902Z" changeid="juan">
        <seg>Un beneficio que se obtiene de esta manera de trabajar es la mayor especificidad en las relaciones entre proyectos, definidas mediante etiquetas (tag) y ramas (branch) en el proyecto padre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now, let’s add a new project for you.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>A partir de ahora, puedes añadir nuevos proyectos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Then, you can directly import the key into the Git database by exporting it and piping that through `git hash-object`, which writes a new blob with those contents into Git and gives you back the SHA-1 of the blob:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tras esto, puedes importar directamente la clave en la base de datos Git, exportandola y redirigiendola a través del comando 'git hash-object'. Para, de esta forma, escribir un nuevo objeto dentro de Git y obtener de vuelta la firma SHA-1 de dicho objeto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you only want to modify your last commit message, it’s very simple:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T121658Z" changeid="juan">
        <seg>Cambiar el mensaje de la última confirmación de cambios, es muy sencillo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Again, this is for unauthenticated read-only access.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Aunque, sigue siendo solo para acceso unicamente de lectura y sin autentificar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Tagging Your Releases ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Marcando tus lanzamientos de versiones ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can insert any kind of content into it, and it will give you back a key that you can use to retrieve the content again at any time.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T142721Z" changeid="juan">
        <seg>Cuando insertas cualquier tipo de contenido, él te devuelve una clave que puedes utilizar para recuperar de nuevo dicho contenido en cualquier momento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When Git merges, it looks at what it has to merge together and then chooses an appropriate merging strategy to use.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T140556Z" changeid="juan">
        <seg>Cuando Git realiza una fusión, suele revisar lo que ha de fusiónar entre sí y, tras ese análisis, elige la estratégia mas adecuada para hacerlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When you run commands like `git branch (branchname)`, Git basically runs that `update-ref` command to add the SHA-1 of the last commit of the branch you’re on into whatever new reference you want to create.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T201744Z" changeid="juan">
        <seg>Cuando lanzas comandos como `git branch (nombrederama)`. Lo que hace Git es añadir, a cualquier nueva referencia que vayas a crear, el valor SHA-1 de la última confirmación de cambios en esa rama.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For example, if this patch was applied from the mbox example I just showed, the commit generated would look something like this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por ejemplo, si consideramos el parche incorporado desde el mbox del ejemplo que acabamos de mostrar; la confirmación de camios (commit) generada será algo como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git checkout -b 'hotfix'
	Switched to a new branch &quot;hotfix&quot;
	$ vim index.html
	$ git commit -a -m 'fixed the broken email address'
	[hotfix]: created 3a0874c: &quot;fixed the broken email address&quot;
	 1 files changed, 0 insertions(+), 1 deletions(-)</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git checkout -b 'hotfix'
	Switched to a new branch &quot;hotfix&quot;
	$ vim index.html
	$ git commit -a -m 'fixed the broken email address'
	[hotfix]: created 3a0874c: &quot;fixed the broken email address&quot;
	 1 files changed, 0 insertions(+), 1 deletions(-)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git adds standard conflict-resolution markers to the files that have conflicts, so you can open them manually and resolve those conflicts.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Git añade a los archivos conflictivos unos marcadores especiales de resolución de conflictos. Marcadores que te guiarán cuando abras manualmente los archivos implicados y los edites para corregirlos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git clone --bare my_project my_project.git
	Initialized empty Git repository in /opt/projects/my_project.git/</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git clone --bare my_project my_project.git
	Initialized empty Git repository in /opt/projects/my_project.git/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Your history after merging in dumbidea and iss91v2.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El registro tras fusionar 'dumbidea' e 'iss91v2'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This pulls the same change introduced in `e43a6`, but you get a new commit SHA-1 value, because the date applied is different.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto introduce exactamente el mismo cambio introducido por 'e43a6', pero con un nuevo valor SHA-1 de confirmación; ya que es diferente la fecha en que ha sido aplicado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>And you did all that with simple `branch` and `checkout` commands.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y todo ello simplemente con dos comandos:  'git branch' y 'git checkout'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>HEAD@{3}: rebase -i (squash): updating HEAD
	95df984...</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T102027Z" changeid="juan">
        <seg>HEAD@{3}: rebase -i (squash): updating HEAD
	95df984...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It shows you what commit was the last to modify each line of any file.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T164921Z" changeid="juan">
        <seg>Esta suele mostrar la confirmación de cambios (commit) que modificó por última vez cada una de las líneas en cualquiera de los archivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git then creates a commit object that has the metadata and a pointer to the root project tree so it can re-create that snapshot when needed.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Después, Git crea un objeto de confirmación con los metadatos pertinentes y un apuntador al nodo correspondiente del árbol de proyecto. Esto permitirá poder regenerar posteriormente dicha instantánea cuando sea necesario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>After a few seconds, you’re taken to your new project page, which indicates that this project is a fork of another one (see Figure 4-15).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tras unos segundos, serás redirigido a la página del nuevo proyecto; y en ella se verá que este proyecto es una bifuración (fork) de otro existente (ver Figura 4-15).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git provides a safer command to do this if you want to update a reference called `update-ref`:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T191254Z" changeid="juan">
        <seg>Git suministra un comando mucho más seguro para hacer esto. Si necesitas actualizar una referencia, puedes utilizar el comando `update-ref`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0410.png
Figure 4-10.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0410.png
Figura 4-10.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>SVN- or CVS-style keyword expansion is often requested by developers used to those systems.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Algunos usuarios de sistemas SVN o CVS, hechan de menos el disponer de expansiones de palabras clave al estilo de las que dichos sistemas tienen.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Whenever you make changes to the `gitosis-admin` project, you have to commit the changes and push them back up to the server in order for them to take effect:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cada cambio en el proyecto 'gitosis-admin', lo has de confirmar (commit) y enviar (push) de vuelta al servidor, para que tenga efecto sobre él:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In this case, you can see your missing commit after the dangling commit.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T134114Z" changeid="juan">
        <seg>En este caso, puedes ver la confirmación de cambios perdida en la línea 'dangling commit.....'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0407.png
Figure 4-7.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0407.png
Figura 4-7.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It won’t create a commit for you — after running it, you must stage and commit the changes introduced manually.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Nunca creará una confirmación de cambios (commit) por tí, --tras ejecutar el comando, tendrás que preparar (stage) y confirmar (commit) manualmente todos los cambios introducidos--.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you really wanted to, you could remove the object completely by running `git prune --expire`.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T135525Z" changeid="juan">
        <seg>Si realmente quieres acabar del todo, puedes lanzar la orden  `git prune --expire` para retirar incluso ese archivo suelto. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git diff master...contrib</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git diff master...contrib</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>John isn’t allowed to push because Jessica has pushed in the meantime.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>John no puede enviar porque Jessica ha enviado previamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>They take the form `(remote)/(branch)`.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Suelen referenciarse como '(remoto)/(rama)'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>I’ll go over the strengths and possible weaknesses of each design; you can choose a single one to use, or you can mix and match features from each.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Vamos a repasar las fortalezas y posibles debilidades de cada paradigma. En tu trabajo, podrás elegir solo uno concreto, o podrás mezclar escogiendo funcionalidades concretas de cada uno.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Here, we’re assuming that you have wildcard DNS set up to send `*.gitserver` to whatever box you’re using to run all this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Aquí, estamos asumiendo que tienes un DNS comodin para redirigir '*.gitserver' hacia cualquier máquina que estés utilizando para todo esto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You aren’t encouraged to directly edit the reference files.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T191155Z" changeid="juan">
        <seg>No es conveniente editar directamente los archivos de referencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git branch -d hotfix
	Deleted branch hotfix (3a0874c).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git branch -d hotfix
	Deleted branch hotfix (3a0874c).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you’re using it only within your corporate network, SSH may be the only protocol you need to deal with.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si lo usas únicamente dentro de tu red corporativa, posiblemente sea SSH el único procolo que tengas que emplear.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The last thing to keep in mind is the commit message.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y, por último, prestar atención al mensaje de confirmación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0309.png
Figure 3-9.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0309.png
Figura 3-9.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>0054want ca82a6dff817ec66f44342007202690a93763949 ofs-delta
	0032have 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
	0000
	0009done</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T085928Z" changeid="juan">
        <seg>0054want ca82a6dff817ec66f44342007202690a93763949 ofs-delta
	0032have 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
	0000
	0009done</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Next, you have two more objects to retrieve — `cfda3b`, which is the tree of content that the commit we just retrieved points to; and `085bb3`, which is the parent commit:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110817T223119Z" changeid="juan">
        <seg>Tras esto, ya tienes más objetos a recuperar --el árbol de contenido `cfda3b` al que apunta la confirmación de cambios; y la confirmación de cambios padre `085bb3`--. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now your `rack` subdirectory is at the exact state it was in when you committed earlier.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T171557Z" changeid="juan">
        <seg>Tras esto, la carpeta `rack` sí que está exactamente en el estado que le corresponde estar tras la última confirmación de cambios que se realizó sobre ella.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To merge this work into your current working branch, you can run `git merge origin/serverfix`.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para integrar (merge) esto en tu actual rama de trabajo, puedes usar el comando 'git merge origin/serverfix'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>&gt;&gt; store = header + content
	=&gt; &quot;blob 16\000what is up, doc?&quot;
	&gt;&gt; require 'digest/sha1'
	=&gt; true
	&gt;&gt; sha1 = Digest::SHA1.hexdigest(store)
	=&gt; &quot;bd9dbf5aae1a3862dd1526723246b20206e5fc37&quot;</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T181611Z" changeid="juan">
        <seg>&gt;&gt; store = header + content
	=&gt; &quot;blob 16\000what is up, doc?&quot;
	&gt;&gt; require 'digest/sha1'
	=&gt; true
	&gt;&gt; sha1 = Digest::SHA1.hexdigest(store)
	=&gt; &quot;bd9dbf5aae1a3862dd1526723246b20206e5fc37&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Stage this hunk [y,n,a,d,/,j,J,g,e,?]?</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T214127Z" changeid="juan">
        <seg>Stage this hunk [y,n,a,d,/,j,J,g,e,?]?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you did an import from another system or otherwise find that your repository is much larger than it should be, here is how you can find and remove large objects.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T134427Z" changeid="juan">
        <seg>Si, tras una importación de otro sistema, o por otras razones, descubres que tu repositorio es mucho mayor de lo que deberia ser. Es momento de buscar y borrar objetos enormes en él.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It lists the oldest at the top, rather than the newest, because that’s the first one it will replay.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120728T085620Z" changeid="juan">
        <seg>En la lista se ven las mas antiguas encima, en lugar de las más recientes, precisamente porque esas van a ser las primeras en reaplicarse.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To change that default to something else, you can use the `core.editor` setting:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para cambiar ese comportamiento, puedes utilizar el ajuste 'core.editor':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>what happened</seg>
      </tuv>
      <tuv lang="ES">
        <seg>what happened</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0324.png
Figure 3-24.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0324.png
Figura 3-24.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Squashing a Commit ###</seg>
      </tuv>
      <tuv lang="ES" changedate="20120728T091239Z" changeid="juan">
        <seg>### Combinar varias confirmaciones en una sola ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Here, the `9bc1d` blob, which if you remember was the first version of your repo.rb file, is referencing the `05408` blob, which was the second version of the file.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110815T212820Z" changeid="juan">
        <seg>Puedes observar que el objeto binario `9bc1d`, (correspondiente a la primera versión de tu archivo repo.rb), tiene una referencia al binario `05408` (la segunda versión de ese archivo).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For instance, the Linux kernel recently jumped from 8 to 10 characters to ensure SHA-1 object uniqueness, so older `git describe` output names were invalidated.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por ejemplo, el kernel de Linux ha saltado recientemente de 8 a 10 caracteres, para asegurar la unicidad de los objetos SHA-1; dando como resultado que los nombres antiguos de 'git describe' han dejado de ser válidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0505.png
Figure 5-5.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0505.png
Figura 5-5.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>remote: Total 3181 (delta 1951), reused 2623 (delta 1603)
	Receiving objects: 100% (3181/3181), 675.42 KiB | 173 KiB/s, done.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T105823Z" changeid="juan">
        <seg>remote: Total 3181 (delta 1951), reused 2623 (delta 1603)
	Receiving objects: 100% (3181/3181), 675.42 KiB | 173 KiB/s, done.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Installing a Hook ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Instalando un punto de enganche ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>However, occasionally Git packs up several of these objects into a single binary file called a packfile in order to save space and be more efficient.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110810T231359Z" changeid="juan">
        <seg>Pero, sin embargo, de vez en cuando, Git suele agrupar varios de esos objetos en un único binario denominado archivo &quot;empaquetador&quot;. Para ahorrar espacio y hacer así más eficiente su almacenamiento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git aborts the patch if this script exits non-zero.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Git abortará la aplicación del parche si este script termina con un código de salida distinto de cero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Instructions for a new repository.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Instrucciones para un nuevo repositorio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Perhaps you accidentally committed a file that contained a password, and you want to make your project open source.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T173352Z" changeid="juan">
        <seg>O podria suceder que se haya confirmado y almacenado accidentalmente un archivo que contiene una contraseña importante, Y el proyecto se va a hacer de código abierto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>`--stdin` tells the command to read the content from stdin; if you don’t specify this, `hash-object` expects the path to a file.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T142924Z" changeid="juan">
        <seg>La opción '--stdin' indica al comando de leer desde la entrada estandar stdin; si no lo indicas, 'hash-object' espera encontrar la ubicación de un archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This script can’t stop the push process, but the client doesn’t disconnect until it has completed; so, be careful when you try to do anything that may take a long time.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Este script no puede detener el proceso de envio, pero el cliente no se desconecta hasta que no se completa su ejecución; por tanto, has de ser cuidadoso cuando intentes realizar con él tareas que puedan requerir mucho tiempo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You know what the different workflows are, and you should have a pretty good grasp of fundamental Git usage.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En estos momentos conoces las diferentes formas de trabajar, y tienes ya un generoso conocimiento de los fundamentos de Git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git format-patch -M origin/master
	0001-add-limit-to-log-function.patch
	0002-changed-log-output-to-30-from-25.patch</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git format-patch -M origin/master
	0001-add-limit-to-log-function.patch
	0002-changed-log-output-to-30-from-25.patch</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you are sure you want to delete it, run 'git branch -D testing'.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>If you are sure you want to delete it, run 'git branch -D testing'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The first line also has the client’s capabilities.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T074741Z" changeid="juan">
        <seg>La primera linea indica también las capacidades disponibles en el cliente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you press Enter after typing nothing at the `Update&gt;&gt;` prompt, Git takes anything selected and stages it for you:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120712T201612Z" changeid="juan">
        <seg>Pulsando la tecla [Enter] tras el indicador 'Update&gt;&gt;', Git toma lo seleccionado y lo añade al área de preparación: </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For example, if you want all but `cr-at-eol` to be set, you can do this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por ejemplo, si deseas activar todos menos 'cr-at-eol' puedes lanzar:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In the current project, this directory contains no files, but it does contain a simple structure:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T150245Z" changeid="juan">
        <seg>En el proyecto actual, la carpeta aún no contiene archivos, pero sí contiene una estructura simple:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>#### Identifying Binary Files ####</seg>
      </tuv>
      <tuv lang="ES">
        <seg>#### Identificando archivos binarios ####</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>ignore *.gem</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T114625Z" changeid="juan">
        <seg>ignore *.gem</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git cat-file -p master^{tree}
	100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt
	100644 blob 05408d195263d853f09dca71d55116663690c27c      repo.rb
	100644 blob e3f094f522629ae358806b17daf78246c27c007b      test.txt</seg>
      </tuv>
      <tuv lang="ES" changedate="20110810T230609Z" changeid="juan">
        <seg>$ git cat-file -p master^{tree}
	100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt
	100644 blob 05408d195263d853f09dca71d55116663690c27c      repo.rb
	100644 blob e3f094f522629ae358806b17daf78246c27c007b      test.txt</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This first example describes contributing via forking on Git hosts that support easy forking.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En este primer ejemplo, veremos cómo contribuir a través de bifurcaciones (forks) en servidores Git que soporten dichas bifurcaciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git filter-branch --commit-filter '
	        if [ &quot;$GIT_AUTHOR_EMAIL&quot; = &quot;schacon@localhost&quot; ];
	        then
	                GIT_AUTHOR_NAME=&quot;Scott Chacon&quot;;
	                GIT_AUTHOR_EMAIL=&quot;schacon@example.com&quot;;
	                git commit-tree &quot;$@&quot;;
	        else
	                git commit-tree &quot;$@&quot;;
	        fi' HEAD</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T180939Z" changeid="juan">
        <seg>$ git filter-branch --commit-filter '
	        if [ &quot;$GIT_AUTHOR_EMAIL&quot; = &quot;schacon@localhost&quot; ];
	        then
	                GIT_AUTHOR_NAME=&quot;Scott Chacon&quot;;
	                GIT_AUTHOR_EMAIL=&quot;schacon@example.com&quot;;
	                git commit-tree &quot;$@&quot;;
	        else
	                git commit-tree &quot;$@&quot;;
	        fi' HEAD</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Are you involved in that process?</seg>
      </tuv>
      <tuv lang="ES">
        <seg>¿Participas en ese proceso de aprobación?.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The simple case is the example you just saw, running `git checkout -b [branch] [remotename]/[branch]`.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El ejemplo más simple, es el que acabas de ver al lanzar el comando 'git checkout -b [rama] [nombreremoto]/[rama]'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The most common range specification is the double-dot syntax.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T115638Z" changeid="juan">
        <seg>La especificación de rango más común es la sintaxis doble-punto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Instead, you must run `git diff-tree` with the branch you want to compare to:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T164021Z" changeid="juan">
        <seg>En su lugar, se ha de emplear el comando `git diff-tree` con la rama que se desea comparar: </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The `objects` directory stores all the content for your database, the `refs` directory stores pointers into commit objects in that data (branches), the `HEAD` file points to the branch you currently have checked out, and the `index` file is where Git stores your staging area information.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T142621Z" changeid="juan">
        <seg>La carpeta 'objects' guarda el contenido de tu base de datos, la carpeta 'refs' guarda los apuntadores a las confirmaciones de cambios (commits), el archivo 'HEAD' apunta a la rama que tengas activa (checked out) en este momento, y el archivo 'index' es donde Git almacena la información sobre tu area de preparación (staging area).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To see the same information in a much more useful way, we can run `git log -g`, which will give you a normal log output for your reflog.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T143307Z" changeid="juan">
        <seg>Para ver la misma información de manera mucho más amigable, podemos utilizar el comando `git log -g`. Este nos muestra una salida normal de registro:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You get a clean summary of all the commits since v1.0.1, grouped by author, that you can e-mail to your list.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Obtendrás un claro resumen de todas las confirmaciones de cambios (commit) desde la versión v1.0.1, agrupadas por autor, y listas para ser incorporadas en un mensaje a tu lista de correo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The main problem with this in Git is that you can’t modify a file with information about the commit after you’ve committed, because Git checksums the file first.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El principal problema para hacerlo en Git reside en la imposibilidad de modificar los ficheros con información relativa a la confirmación de cambios (commit). Debido a que Git calcula sus sumas de comprobación antes de las confirmaciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you’re on a Windows machine, set it to `true` — this converts LF endings into CRLF when you check out code:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si estás trabajando en una máquina Windows, ajustalo a 'true', --para convertir finales LF en CRLF cuando extraigas código (checkout)--.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The next place Git looks is the `~/.gitconfig` file, which is specific to each user.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El segundo es el archivo '~/.gitconfig', específico para cada usuario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Technically, `git am` is built to read an mbox file, which is a simple, plain-text format for storing one or more e-mail messages in one text file.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Técnicamente, 'git am' se construyó para leer un archivo de buzón de correo (mbox file), que no es más que un simple formato de texto plano para almacenar uno o varios mensajes de correo electrónico en un solo archivo de texto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can see where you’ve been at any time by running `git reflog`:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T143113Z" changeid="juan">
        <seg>Con el comando `git reflog` puedes revisar donde has estado en cualquier momento pasado:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It adds a section to your `.git/config` file, specifying the name of the remote (`origin`), the URL of the remote repository, and the refspec for fetching:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110815T215500Z" changeid="juan">
        <seg>Esto añade una nueva sección a tu archivo `.git/config`, indicando el nombre del remoto (`origin`), la ubicación (URL) del repositorio remoto y la referencia para recuperar (fench) desde él: </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now that you have the packfile index, you can see if your object is in it — because the index lists the SHAs of the objects contained in the packfile and the offsets to those objects.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T131328Z" changeid="juan">
        <seg>Una vez tengas el índice del empaquetado, puedes mirar si el objeto buscado está en él, (Dicho índice contiene la lista de SHAs de los objetos dentro del empaquetado y las ubicaciones -offsets- de cada uno de llos dentro de él.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>So, you can either run four config commands</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Es decir, has de ejecutar cuatro comandos de configuración:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>def log(treeish = 'master')
	-    command(&quot;git log #{treeish}&quot;)
	+    command(&quot;git log -n 20 #{treeish}&quot;)
	   end</seg>
      </tuv>
      <tuv lang="ES">
        <seg>def log(treeish = 'master')
	-    command(&quot;git log #{treeish}&quot;)
	+    command(&quot;git log -n 20 #{treeish}&quot;)
	   end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Let’s say you just pushed out a release of your code to a production environment, you’re getting bug reports about something that wasn’t happening in your development environment, and you can’t imagine why the code is doing that.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T071158Z" changeid="juan">
        <seg>Por ejemplo, en caso de aparecer problemas justo tras enviar a producción un cierto código que parecia funcionar bien en el entorno de desarrollo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is also useful if you have multiple packfiles on the server, so you can see which packfile contains the object you need:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T131257Z" changeid="juan">
        <seg>Hacer la comprobacion es sobre todo util en aquellos casos donde existan multiples archivos empaquetados en el servidor, para determinar así en cual de ellos se encuentra el objeto que necesitas:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Just to have a target, assume that each message has to include a string that looks like &quot;ref: 1234&quot; because you want each commit to link to a work item in your ticketing system.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Simplemente por fijar algo concreto, supongamos que cada mensaje ha de incluir un texto tal como &quot;ref: 1234&quot;, porque quieres enlazar cada confirmación de cambios con una determinada entrada de trabajo en un sistema de control.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When all the patches for your topic are applied and committed into your branch, you can choose whether and how to integrate them into a longer-running branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cuando tengas integrados y confirmados todos los parches relativos al tema puntual en que estas trabajando, puedes plantearte cómo y cuándo lo vas a integar en alguna otra rama de más largo recorrido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The `git verify-pack` plumbing command allows you to see what was packed up:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T114703Z" changeid="juan">
        <seg>Y, para eso, has de utilizar el comando &quot;de fontaneria&quot; `git verify-pack`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For example, to set the meta information in your diff output to blue foreground, black background, and bold text, you can run</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por ejemplo, para mostrar la meta-información del comando 'diff' con letra azul sobre fondo negro y con caracteres en negrita, puedes indicar:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The `fetch-pack` process sends data that looks like this to the daemon after connecting:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T075518Z" changeid="juan">
        <seg>Tras la conexión, el proceso `fetch-pack` envia datos de una forma parecida a esta: </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>hotfix branch based back at your master branch point.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>rama 'hotfix' basada en la rama 'master' original.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git checkout -b featureBv2 origin/master
	$ git merge --no-commit --squash featureB
	$ (change implementation)
	$ git commit
	$ git push myfork featureBv2</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git checkout -b featureBv2 origin/master
	$ git merge --no-commit --squash featureB
	$ (change implementation)
	$ git commit
	$ git push myfork featureBv2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Removing Objects ###</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T103145Z" changeid="juan">
        <seg>### Borrando objetos ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You have a number of choices, so I’ll cover a few of them.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tienes bastantes opciones, y vamos a ver algunas de ellas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>#### core.pager ####</seg>
      </tuv>
      <tuv lang="ES">
        <seg>#### core.pager ####</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git remote add local_proj /opt/git/project.git</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git remote add local_proj /opt/git/project.git</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>However, many larger public projects accept patches via a developer mailing list, so I’ll go over an example of that now.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>De todas formas, muchos de los proyectos públicos más grandes aceptar parches a través de una lista de correo electrónico, por lo que veremos un ejemplo de dicho procedimiento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To contribute to that project, you create your own public clone of the project and push your changes to it.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para contribuir en este tipo de proyecto, crearás tu propio clón público del mismo y enviarás (push) tus cambios a este.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git merge origin/master
	Updating 0550271..85a3eee
	Fast forward
	 rack |    2 +-
	 1 files changed, 1 insertions(+), 1 deletions(-)
	[master*]$ git status
	# On branch master
	# Changed but not updated:
	#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
	#   (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)
	#
	#      modified:   rack
	#</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T110042Z" changeid="juan">
        <seg>$ git merge origin/master
	Updating 0550271..85a3eee
	Fast forward
	 rack |    2 +-
	 1 files changed, 1 insertions(+), 1 deletions(-)
	[master*]$ git status
	# On branch master
	# Changed but not updated:
	#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
	#   (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)
	#
	#      modified:   rack
	#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If something is missing or the tests don’t pass, exiting non-zero also aborts the `git am` script without committing the patch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si falta algo o si alguna de las pruebas falla, saliendo con un código de salida distinto de cero abortará el comando 'git am' sin confirmar el parche.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>These path-specific settings are called Git attributes and are set either in a `.gitattribute` file in one of your directories (normally the root of your project) or in the `.git/info/attributes` file if you don’t want the attributes file committed with your project.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110801T122532Z" changeid="juan">
        <seg>Estos ajustes específicos relacionados con un camino, se denominan atributos en Git. Y se pueden fijar, bien mediante un archivo '.gitattribute' en una de las carpetas de tu proyecto (normalmente en la raiz del proyecto), o bien mediante el archivo 'git/info/attributes en el caso de no querer guardar el archivo de atributos dentro de tu proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Here is a small Ruby script that does that:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Este podria ser un pequeño script Ruby para hacerlo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git describe master
	v1.6.2-rc1-20-g8c5b85c</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git describe master
	v1.6.2-rc1-20-g8c5b85c</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When you receive such a project, you get the directories that contain submodules, but none of the files yet:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T171356Z" changeid="juan">
        <seg>Cuando se recibe, se reciben también las carpetas que contienen los submódulos; pero no se reciben ninguno de los archivos de dichos submódulos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Also notice that it doesn’t need to point to a commit; you can tag any Git object.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T112743Z" changeid="juan">
        <seg>Y también el que no ha sido necesario apuntar directamente a una confirmación de cambios. Realmente puedes etiquetar cualquier tipo de objeto Git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In order to resolve the conflict, you have to either choose one side or the other or merge the contents yourself.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para resolver el conflicto, has de elegir manualmente contenido de uno o de otro lado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Merge Strategies ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Estrategias de fusión ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Writing objects: 100% (19/19), done.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T134706Z" changeid="juan">
        <seg>Writing objects: 100% (19/19), done.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can keep the changes there for minutes, days, or months, and merge them in when they’re ready, regardless of the order in which they were created or worked on.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes mantener los cambios ahí durante minutos, dias o meses; y fusionarlos cuando realmente estén listos. En lugar de verte obligado a fusionarlos en el orden en que fueron creados y comenzaste a trabajar en ellos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The last major range-selection syntax is the triple-dot syntax, which specifies all the commits that are reachable by either of two references but not by both of them.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120712T200822Z" changeid="juan">
        <seg>La última de las opciones principales para seleccionar rangos es la sintaxis triple-punto. Utilizada para especificar todas las confirmaciones de cambio alcanzables separadamente desde cualquiera de dos referencias, pero no desde ambas a la vez.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git constructs a header that starts with the type of the object, in this case a blob.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T200443Z" changeid="juan">
        <seg>Git construye la cabecera comenzando por el tipo de objeto, en este caso un objeto binario grande (blob).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It takes a single argument: the name of the temporary file that contains the proposed commit message.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Recibe un solo argumento: el nombre del archivo temporal que contiene el mensaje de confirmación propuesto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ sudo vim /etc/passwd</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ sudo vim /etc/passwd</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Then, tell Git what the &quot;indent&quot;&quot; filter does on smudge and clean:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>E indicando después que el filtro &quot;indent&quot; actuará al manchar (smudge) y al limpiar (clean):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git remote add myfork (url)</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git remote add myfork (url)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Like many other Version Control Systems, Git has a way to fire off custom scripts when certain important actions occur.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Al igual que en otros sistemas de control de versiones, Git también cuenta con mecanismos para lanzar scrips de usuario cuando suceden ciertas acciones importantes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>HEAD points to another branch when you switch branches.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Apuntador HEAD apuntando a otra rama cuando saltamos de rama.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>At this point, you can run your test to see if the issue exists as of this commit.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T075036Z" changeid="juan">
        <seg>En este punto, se pueden lanzar las pruebas pertinentes para ver si el problema existe en esa confirmación de cambios extraida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Let’s work from the previous example.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si utilizamos el mismo ejemplo usado anteriormente,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>What now&gt; 1
	           staged     unstaged path
	  1:    unchanged        +0/-1 TODO
	  2:        +1/-1      nothing index.html
	  3:        +1/-1        +4/-0 lib/simplegit.rb</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T214426Z" changeid="juan">
        <seg>What now&gt; 1
	           staged     unstaged path
	  1:    unchanged        +0/-1 TODO
	  2:        +1/-1      nothing index.html
	  3:        +1/-1        +4/-0 lib/simplegit.rb</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ rm -Rf .git/refs/original
	$ rm -Rf .git/logs/
	$ git gc
	Counting objects: 19, done.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T134701Z" changeid="juan">
        <seg>$ rm -Rf .git/refs/original
	$ rm -Rf .git/logs/
	$ git gc
	Counting objects: 19, done.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Compressing objects: 100% (3/3), done.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Compressing objects: 100% (3/3), done.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>---
	 lib/simplegit.rb |    2 +-
	 1 files changed, 1 insertions(+), 1 deletions(-)</seg>
      </tuv>
      <tuv lang="ES">
        <seg>---
	 lib/simplegit.rb |    2 +-
	 1 files changed, 1 insertions(+), 1 deletions(-)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you have a shared mounted filesystem, then you can clone, push to, and pull from a local file-based repository.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si dispones de un sistema de archivos compartido, podrás clonar (clone), enviar (push) y recibir (pull) a/desde repositorios locales basado en archivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In this chapter, I’ll go through some operations that you can use to make Git operate in a more customized fashion by introducing several important configuration settings and the hooks system.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En este capítulo, avanzaremos sobre ciertas operaciones que puedes utilizar para personalizar el funcionamiento de Git ; presentando algunos de sus principales ajustes y el sistema de anclajes (hooks).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>First, you need to add something like the following to the `/etc/gitweb.conf` file:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Previamente, has de añadir algo como esto al archivo '/etc/gitweb.conf':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Simple version of the Git data model.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110801T121552Z" changeid="juan">
        <seg>Versión simplificada del modelo de datos de Git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can also see from the header on each of your project’s pages that you have two Git URLs (see Figure 4-8).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En la página de cabecera de cada uno de tus proyectos, podrás ver dos URLs (ver Figura 4-8).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The `git describe` command favors annotated tags (tags created with the `-a` or `-s` flag), so release tags should be created this way if you’re using `git describe`, to ensure the commit is named properly when described.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El comando 'git describe' da preferencia a las etiquetas anotativas (etiquetas creadas  con las opciones '-a' o '-s'). De esta forma las etiquetas para las versiones pueden ser creadas  usando 'git describe', asegurandose el que las confirmaciones de cambios (commit) son adecuadamente nombradas cuando se describen.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can zlib-uncompress it, strip off the header, and look at the commit content:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110817T222933Z" changeid="juan">
        <seg>Puedes descomprimirlo, quitarle la cabecera y mirar el contenido:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Another nice thing is that HTTP is such a commonly used protocol that corporate firewalls are often set up to allow traffic through this port.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Otro detalle muy util de emplear HTTP, es que, al ser un protocolo de uso común, la mayoría de los cortafuegos corporativos suelen tener habilitado el tráfico a traves de este puerto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now that you have basic read/write and read-only access to your project, you may want to set up a simple web-based visualizer.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Ahora que ya tienes acceso básico de lectura/escritura y de solo-lectura a tu proyecto, puedes querer instalar un visualizador web.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It’s generally undesirable for the Git protocol to be the only access to your project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>No es recomendable tenerlo como único protocolo de acceso a tus proyectos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Here’s the object SHA-1 value it created:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T112537Z" changeid="juan">
        <seg>Este es el objeto SHA-1 creado:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git log refA..refB
	$ git log ^refA refB
	$ git log refB --not refA</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T201650Z" changeid="juan">
        <seg>$ git log refA..refB
	$ git log ^refA refB
	$ git log refB --not refA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Jessica can now merge this into the work she did with `git merge`:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y los fusiona con su propio trabajo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you want some repositories to be read-only to certain users and read/write to others, access and permissions can be a bit difficult to arrange.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En caso de requerir varios repositorios de solo lectura para ciertos usuarios y de lectura/escritura para otros, preparar el acceso y los permisos puede dar bastante trabajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0513.png
Figure 5-13.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0513.png
Figura 5-13.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When you have hundreds of users, it’s much more of a pain to manage that process.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Pero, cuanto tengas cientos de usuarios, se hace bastante pesado gestionar así ese proceso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git diff --cached rack
	diff --git a/rack b/rack
	new file mode 160000
	index 0000000..08d709f
	--- /dev/null
	+++ b/rack
	@@ -0,0 +1 @@
	+Subproject commit 08d709f78b8c5b0fbeb7821e37fa53e69afcf433</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T104208Z" changeid="juan">
        <seg>$ git diff --cached rack
	diff --git a/rack b/rack
	new file mode 160000
	index 0000000..08d709f
	--- /dev/null
	+++ b/rack
	@@ -0,0 +1 @@
	+Subproject commit 08d709f78b8c5b0fbeb7821e37fa53e69afcf433</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>test tag</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T234343Z" changeid="juan">
        <seg>test tag</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>After you commit and push that change, all four users will be able to read from and write to that project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tras confirmar (commit) y enviar (push) estos cambios, los cuatro usuarios podrán acceder a leer y escribir sobre el proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git merge iss53
	Auto-merging index.html
	CONFLICT (content): Merge conflict in index.html
	Automatic merge failed; fix conflicts and then commit the result.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git merge iss53
	Auto-merging index.html
	CONFLICT (content): Merge conflict in index.html
	Automatic merge failed; fix conflicts and then commit the result.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>A way to remember this command is by recalling the `git push [remotename] [localbranch]:[remotebranch]` syntax that we went over a bit earlier.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Una manera de recordar este comando es dándonos cuenta de que proviene de la sintaxis 'git push [nombreremoto] [ramalocal]:[ramaremota]'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>&lt;script type=&quot;text/javascript&quot;&gt;</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T213316Z" changeid="juan">
        <seg>&lt;script type=&quot;text/javascript&quot;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In centralized systems, there is generally a single collaboration model—the centralized workflow.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En los sistemas centralizados, tenemos una única forma de trabajar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If your project is open source, you also get a huge community of developers who now have visibility into your project and may well fork it and help contribute to it.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si tu proyecto es de código abierto, puedes tener también una amplia comunidad de desarrolladores que podrán ver tu proyecto, bifurcarlo (fork) y ayudar contribuyendo a él.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For example, say you run `git push origin master` in your project, and `origin` is defined as a URL that uses the SSH protocol.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T073735Z" changeid="juan">
        <seg>Por ejemplo, si lanzas el comando `git push origin master` en tu proyecto y `origin` está definida como una ubicación que utiliza el protocolo SSH. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## Revision Selection ##</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T090025Z" changeid="juan">
        <seg>## Selección de confirmaciones de cambios concretas ##</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git can figure out a short, unique abbreviation for your SHA-1 values.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T184854Z" changeid="juan">
        <seg>En todos estos casos, Git puede deducir el resto del valor SHA-1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now, no matter what is set as your default shell editor variable, Git will fire up Emacs to edit messages.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>A partir de ese comando, por ejemplo, git lanzará Emacs cada vez que vaya a editar mensajes; indistintamente del editor configurado en la línea de comandos (shell) del sistema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>#!/usr/bin/env ruby
	message_file = ARGV[0]
	message = File.read(message_file)</seg>
      </tuv>
      <tuv lang="ES">
        <seg>#!/usr/bin/env ruby
	message_file = ARGV[0]
	message = File.read(message_file)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0520.png
Figure 5-20.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0520.png
Figura 5-20.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It’s important to notice that it isn’t the SHA of the commit, but of the blob itself:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Es importante destacar que no se trata de la suma SHA de la confirmación de cambios (commit), sino del propio objeto binario (blob):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Let’s assume you’ve received a few keys by e-mail and saved them to temporary files.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Suponiendo que hayas recibido las claves por correo electrónico y que las has guardado en archivos temporales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The default branch name in Git is master.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La rama por defecto de Git es la rama 'master'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git symbolic-ref HEAD
	refs/heads/master</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T192858Z" changeid="juan">
        <seg>$ git symbolic-ref HEAD
	refs/heads/master</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is an important point with submodules: you record them as the exact commit they’re at.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T171211Z" changeid="juan">
        <seg>Esto es importante al trabajar con submódulos: siempre son almacenados como la confirmación de cambios concreta en la que están.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The SHA-1 digest is 20 bytes or 160 bits.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T185558Z" changeid="juan">
        <seg>Los códigos SHA-1 son de 20 bytes, (160 bits).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It means that at the core of Git is a simple key-value data store.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110717T113030Z" changeid="juan">
        <seg>Pues significa que el núcleo Git es un simple almacén de claves y valores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now you can send the maintainer a message that you’ve made the requested changes and they can find those changes in your `featureBv2` branch (see Figure 5-18).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En estos momentos, puedes notificar al gestor del proyecto que has realizado todos los cambios solicitados y que los puede encontrar en tu rama 'featureBv2' (ver Figura 5-18).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Dictator and Lieutenants Workflow ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Flujo de trabajo con Dictador y Tenientes ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For example, say you have a commit history that looks like Figure 6-1.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T115749Z" changeid="juan">
        <seg>Por ejemplo, teniendo un historial de confirmaciones de cambio tal como el de la figura 6-1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It works by going to the common ancestor of the two branches (the one you’re on and the one you’re rebasing onto), getting the diff introduced by each commit of the branch you’re on, saving those diffs to temporary files, resetting the current branch to the same commit as the branch you are rebasing onto, and finally applying each change in turn.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Haciendo que Git: vaya al ancestro común de ambas ramas (donde estás actualmente y de donde quieres reorganizar), saque las diferencias introducidas por cada confirmación en la rama donde estás, guarde esas diferencias en archivos temporales, reinicie (reset) la rama actual hasta llevarla a la misma confirmación en la rama de donde quieres reorganizar, y, finalmente, vuelva a aplicar ordenadamente los cambios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Rather than remove a specific file with something like `rm file`, you have to remove it with `git rm --cached` — you must remove it from the index, not from disk.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T133913Z" changeid="juan">
        <seg>En lugar de borrar un archivo concreto con una orden tal como `rm archivo`, has de borrarlo con `git rm --cached` (es decir, tienes que borrarlo del índice, en lugar de del disco).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you’re running this on a server outside your firewall, it should only be used for projects that are publicly visible to the world.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si lo estás utilizando en un servidor fuera del perímetro de tu cortafuegos, se debe utilizar exclusivamente para proyectos que han de ser públicos, visibles para todo el mundo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Contributing to public projects is a bit different.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Contribuir a proyectos públicos es ligeramente diferente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now you’re on another commit, halfway between the one you just tested and your bad commit.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T075125Z" changeid="juan">
        <seg>Git extraeria otra confirmación de cambios, aquella a medio camino entre la que se acaba de chequear y la que se habia indicado como erronea al principio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The other way to move introduced work from one branch to another is to cherry-pick it.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El otro camino para introducir trabajo de una rama en otra, es entresacarlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The second developer must merge in the first one’s work before pushing changes up, so as not to overwrite the first developer’s changes.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El segundo desarrollador deberá fusionar previamente su trabajo con el del primero, antes de enviarlo, para evitar el sobreescribir los cambios del primero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Here you’ll use a format very much like the CVS ACL mechanism: it uses a series of lines, where the first field is `avail` or `unavail`, the next field is a comma-delimited list of the users to which the rule applies, and the last field is the path to which the rule applies (blank meaning open access).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Su formato es muy parecido al del mecanismo CVS ACL: utiliza una serie de líneas donde el primer campo es 'avail' o 'unavail' (permitido o no permitido), el segundo campo es una lista de usuarios separados por comas, y el último campo es la ubicación (path) sobre el que aplicar la regla (dejarlo en blanco equivale a un acceso abierto).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>After this comes a Commands section.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T212042Z" changeid="juan">
        <seg>Tras esa lista, viene la sección de comandos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Here you’ll clone a project with a submodule in it.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T171343Z" changeid="juan">
        <seg>Si se tiene un proyecto con submódulos dentro de él.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git config diff.word.textconv strings</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git config diff.word.textconv strings</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now that you have the basics of branching and merging down, what can or should you do with them?</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Ahora que ya has visto los procedimientos básicos de ramificación y fusión, ¿qué puedes o qué debes hacer con ellos?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ cd ~/.ssh
	$ ls
	authorized_keys2  id_dsa       known_hosts
	config            id_dsa.pub</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ cd ~/.ssh
	$ ls
	authorized_keys2  id_dsa       known_hosts
	config            id_dsa.pub</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$refname = ARGV[0]
	$oldrev  = ARGV[1]
	$newrev  = ARGV[2]
	$user    = ENV['USER']</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$refname = ARGV[0]
	$oldrev  = ARGV[1]
	$newrev  = ARGV[2]
	$user    = ENV['USER']</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>First, if it isn’t yet clear, Git is fundamentally a content-addressable filesystem with a VCS user interface written on top of it.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110717T111743Z" changeid="juan">
        <seg>Ante todo, por si no estuviera suficientemente claro ya, Git es fundamentalmente un sistema de archivo (filesystem) con un interface de usuario (VCS) escrito sobre él.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>How can you keep your code consistently up to date and your patches valid?</seg>
      </tuv>
      <tuv lang="ES">
        <seg>¿Cómo puedes mantener consistentemente actualizado tu código, y asegurarte así de que tus parches son válidos? </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The first section of this chapter will cover the available protocols and the pros and cons of each.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La primera parte de este capítulo cubrirá la gama de protocolos disponibles, detallando los pros y contras de cada uno de ellos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To add a local repository to an existing Git project, you can run something like this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para añadir un repositorio local a un proyecto Git existente, puedes usar algo como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In this case, the  master branch pull was rejected because it wasn’t a fast-forward reference.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110815T221053Z" changeid="juan">
        <seg>En este ejemplo, se ha rechazado la recuperación de la rama master porque no era una referencia de avance rápido (fast-forward).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Either the Git repository is available for everyone to clone or it isn’t.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>O el repositorio está disponible para que cualquiera lo pueda clonar, o no lo está.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git is smart enough to figure out what commit you meant to type if you provide the first few characters, as long as your partial SHA-1 is at least four characters long and unambiguous — that is, only one object in the current repository begins with that partial SHA-1.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T085114Z" changeid="juan">
        <seg>Simplemente dándole los primeros caracteres del código SHA-1, Git es lo suficientemente inteligente como para figurarse cual es la confirmación de cambios (commit) deseada. Es necesario teclear por lo menos 4 caracteres y estos han de ser no ambiguos --es decir, debe existir un solo objeto en el repositorio cuyo código comience por dicho trozo inicial del SHA--.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git submodule add git://github.com/chneukirchen/rack.git rack
	Initialized empty Git repository in /opt/subtest/rack/.git/
	remote: Counting objects: 3181, done.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T103331Z" changeid="juan">
        <seg>$ git submodule add git://github.com/chneukirchen/rack.git rack
	Initialized empty Git repository in /opt/subtest/rack/.git/
	remote: Counting objects: 3181, done.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you’re not interested in using KDiff3 for diff but rather want to use it just for merge resolution, and the kdiff3 command is in your path, then you can run</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por ejemplo, si no te interesa utilizar KDiff3 para comparaciones, sino que tan solo te interesa utilizarlo para resolver conflictos de integración; teniendo kdiff3 en el path de ejecución, solo has de lanzar el comando:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you want to remove the &quot;added cat-file&quot; commit and change the order in which the other two commits are introduced, you can change the rebase script from this</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T185733Z" changeid="juan">
        <seg>Por ejemplo, si se desea eliminar la confirmación de &quot;added cat-file&quot; y cambiar el orden en que se han introducido las otras dos confirmaciones de cambios, el script de reorganización pasaría de ser:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Examples include e-mailing a list, notifying a continuous integration server, or updating a ticket-tracking system — you can even parse the commit messages to see if any tickets need to be opened, modified, or closed.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Algunos ejemplos de posibles aplicaciones pueden ser la de alimentar una lista de correo-e, avisar a un servidor de integración continua, o actualizar un sistema de seguimiento de tickets de servicio --pudiendo incluso procesar el mensaje de confirmación para ver si hemos de abrir, modificar o dar por cerrado algún ticket--.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In the last section of this chapter, I’ll demonstrate using this hook to check that your commit message is conformant to a required pattern.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En la última parte de este capítulo, veremos cómo podemos utilizar este punto de enganche  para revisar si el mensaje de confirmación es conforme a un determinado patrón obligatorio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you and a co-worker are working on the same project and they want you to check something out, running a command like `git pull /home/john/project` is often easier than them pushing to a remote server and you pulling down.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si tu y otra persona estais trabajando en el mismo proyecto y ella quiere mostrarte algo, el usar un comando tal como 'git pull /home/john/project' suele ser más sencillo que el que esa persona te lo envie (push) a un servidor remoto y luego tú lo recojas (pull) desde allí.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg># on Johns computer
	$ cd myproject
	$ git init
	$ git add .</seg>
      </tuv>
      <tuv lang="ES">
        <seg># en la máquina de John
	$ cd myproject
	$ git init
	$ git add .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git doesn’t have a modify-history tool, but you can use the rebase tool to rebase a series of commits onto the HEAD they were originally based on instead of moving them to another one.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T122112Z" changeid="juan">
        <seg>Git no dispone de herramientas directas para modifica el historial de confirmaciones de cambio. Pero es posible emplear la herramienta de reorganización (rebase) para modificar series de confirmaciones; en la propia cabeza (HEAD) donde estaban basadas originalmente, en lugar de moverlas a otra distinta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git cat-file commit ca82a6
	tree cfda3bf379e4f8dba8717dee55aab78aef7f4daf
	parent 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
	author Scott Chacon &lt;schacon@gmail.com&gt; 1205815931 -0700
	committer Scott Chacon &lt;schacon@gmail.com&gt; 1240030591 -0700</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git cat-file commit ca82a6
	tree cfda3bf379e4f8dba8717dee55aab78aef7f4daf
	parent 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
	author Scott Chacon &lt;schacon@gmail.com&gt; 1205815931 -0700
	committer Scott Chacon &lt;schacon@gmail.com&gt; 1240030591 -0700</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Your local branches aren’t automatically synchronized to the remotes you write to — you have to explicitly push the branches you want to share.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tus ramas locales no se sincronizan automáticamente con los remotos en los que escribes. Sino que tienes que llevar (push) expresamente, cada vez, al remoto las ramas que desees compartir.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Add Grit::Commit#to_patch
	      Update version and History.txt
	      Remove stray `puts`
	      Make ls_tree ignore nils</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Add Grit::Commit#to_patch
	      Update version and History.txt
	      Remove stray `puts`
	      Make ls_tree ignore nils</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now, Git will check the integrity of your repository before each push is accepted to make sure faulty clients aren’t introducing corrupt data.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>A partir de ese momento, Git comprobará la integridad del repositorio antes de aceptar ningún envio (push), para asegurarse de que no está introduciendo datos corruptos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you run that, Git will page the entire output of all commands, no matter how long they are.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si lanzas esto, Git mostrará siempre el resultado completo de todos los comandos, independientemente de lo largo que sea este.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### External Merge and Diff Tools ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Herramientas externas para fusionar y para comparar ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git log -4 --pretty=format:&quot;%h %s&quot;
	1c002dd added cat-file
	9b29157 added blame
	35cfb2b updated README formatting
	f3cc40e changed my name a bit</seg>
      </tuv>
      <tuv lang="ES" changedate="20120728T093712Z" changeid="juan">
        <seg>$ git log -4 --pretty=format:&quot;%h %s&quot;
	1c002dd added cat-file
	9b29157 added blame
	35cfb2b updated README formatting
	f3cc40e changed my name a bit</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Jessica, Josie, and John inform the integrators that the `featureA` and `featureBee` branches on the server are ready for integration into the mainline.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Jessica, Josie y John informan a los integradores de que las ramas 'featureA' y 'featureBee' del servidor están preparadas para su integración con la línea principal del programa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If someone has e-mailed you the patch properly using git send-email, and you download that into an mbox format, then you can point git am to that mbox file, and it will start applying all the patches it sees.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si alguien te ha enviado correctamente un parche utilizando 'git send-email', y te lo has descargado a un formato mbox; podrás indicar dicho archivo mbox al comando 'git am', y este comenzará a incorporar todos los parches que encuentre dentro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0903.png
Figure 9-3.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110807T153604Z" changeid="juan">
        <seg>Insert 18333fig0903.png
Figura 9-3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The `--ignore-unmatch` option to `git rm` tells it not to error out if the pattern you’re trying to remove isn’t there.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T135310Z" changeid="juan">
        <seg>La opción `--ignore-unmatch` indica a `git rm` que evite lanzar errores en caso de no encontrar el patrón que le has ordenado buscar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>These commands are generally referred to as &quot;plumbing&quot; commands, and the more user-friendly commands are called &quot;porcelain&quot; commands.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Estos comandos son conocidos como los &quot;comandos de fontanería&quot;, mientras que los comandos más amigables son conocidos como los &quot;comandos de porcelana&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>What is also interesting is that the second version of the file is the one that is stored intact, whereas the original version is stored as a delta — this is because you’re most likely to need faster access to the most recent version of the file.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T114933Z" changeid="juan">
        <seg>Resulta curioso que se almacene completa la segunda versión del archivo, mientras que la versión original es donde se almacena solo la diferencia. Esto se debe a la mayor probabilidad de que vayamos a recuperar rápidamente la versión mas reciente del archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>What now&gt; 2
	           staged     unstaged path
	  1:    unchanged        +0/-1 TODO
	  2:    unchanged        +1/-1 index.html
	  3:    unchanged        +5/-1 lib/simplegit.rb
	Update&gt;&gt;</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T212521Z" changeid="juan">
        <seg>What now&gt; 2
	           staged     unstaged path
	  1:    unchanged        +0/-1 TODO
	  2:    unchanged        +1/-1 index.html
	  3:    unchanged        +5/-1 lib/simplegit.rb
	Update&gt;&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can tell Git to convert CRLF to LF on commit but not the other way around by setting `core.autocrlf` to input:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes indicar a Git que convierta CRLF en LF al confirmar cambios (commit), pero no en el otro sentido; utilizando también el parámetro 'core.autocrlf':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git successfully and succinctly tells me that I added the string &quot;Let’s see if this works&quot;, which is correct.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Git me indica correctamente que he añadido la frase &quot;Let's see if this works&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>A lot of people become concerned at some point that they will, by random happenstance, have two objects in their repository that hash to the same SHA-1 value.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120712T195410Z" changeid="juan">
        <seg>Mucha gente se suele preocupar por si, por casualidad, dos objetos en su repositorio reciben el mismo código SHA-1 para identificarlos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0525.png
Figure 5-25.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0525.png
Figura 5-25.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>There is only one packfile on the server, so your object is obviously in there, but you’ll check the index file to make sure.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T131156Z" changeid="juan">
        <seg>Vemos que hay un archivo empaquetado, y el objeto buscado ha de encontrarse dentro de él; pero merece comprobarlo revisando el archivo de índice, para asegurarse.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Basically, all you have to do is put the bare Git repository under your HTTP document root and set up a specific `post-update` hook, and you’re done (See Chapter 7 for details on Git hooks).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Basta con situar el repositorio Git bajo la raiz de los documentos HTTP y preparar el enganche (hook) 'post-update' adecuado. (Ver el Capítulo 7 para detalles sobre los enganches Git.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Instead of just moving the branch pointer forward, Git creates a new snapshot that results from this three-way merge and automatically creates a new commit that points to it (see Figure 3-17).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En lugar de simplemente avanzar el apuntador de la rama, Git crea una nueva instantánea (snapshot) resultante de la fusión a tres bandas; y crea automáticamente una nueva confirmación de cambios (commit) que apunta a ella.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In the next chapter, you’ll learn more powerful tools and tips for dealing with complex situations, which will truly make you a Git master.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En el capítulo siguiente, aprenderás el uso de más herramientas avanzadas y algunos trucos para tratar con situaciones complejas; haciendo de tí un verdadero maestro Git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Do work on a web site.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Trabajas en un sitio web.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Your commit history looks like Figure 3-36.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tu registro de cambios puede ser algo como lo de la Figura 3-36.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Generally, eight to ten characters are more than enough to be unique within a project.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T185127Z" changeid="juan">
        <seg>Normalmente, entre ocho y diez caracteres suelen ser más que suficientes para garantizar la unicidad de  todos los objetos dentro de cualquier proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git branch -d client
	$ git branch -d server</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git branch -d client
	$ git branch -d server</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git show HEAD^
	commit d921970aadf03b3cf0e71becdaab3147ba71cdef
	Merge: 1c002dd... 35cfb2b...
	Author: Scott Chacon &lt;schacon@gmail.com&gt;
	Date:   Thu Dec 11 15:08:43 2008 -0800</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T113913Z" changeid="juan">
        <seg>$ git show HEAD^
	commit d921970aadf03b3cf0e71becdaab3147ba71cdef
	Merge: 1c002dd... 35cfb2b...
	Author: Scott Chacon &lt;schacon@gmail.com&gt;
	Date:   Thu Dec 11 15:08:43 2008 -0800</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you’re happy with that, and you verify that everything that had conflicts has been staged, you can type `git commit` to finalize the merge commit.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si todo ha ido correctamente, y ves que todos los archivos conflictivos están marcados como preparados, puedes lanzar el comando 'git commit' para terminar de confirmar la fusión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can then use `git cat-file` to see how big that object is:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110810T230532Z" changeid="juan">
        <seg>Y ver su tamaño con el comando `git cat-file`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For future projects, you can also copy collaborator groups by copying the permissions of an existing project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En proyectos futuros, podras incluir también a tu grupo de colaboradores copiando los permisos desde otro proyecto ya existente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git stash branch testchanges
	Switched to a new branch &quot;testchanges&quot;
	# On branch testchanges
	# Changes to be committed:
	#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)
	#
	#      modified:   index.html
	#
	# Changed but not updated:
	#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
	#
	#      modified:   lib/simplegit.rb
	#
	Dropped refs/stash@{0} (f0dfc4d5dc332d1cee34a634182e168c4efc3359)</seg>
      </tuv>
      <tuv lang="ES" changedate="20120712T204726Z" changeid="juan">
        <seg>$ git stash branch testchanges
	Switched to a new branch &quot;testchanges&quot;
	# On branch testchanges
	# Changes to be committed:
	#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)
	#
	#      modified:   index.html
	#
	# Changed but not updated:
	#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
	#
	#      modified:   lib/simplegit.rb
	#
	Dropped refs/stash@{0} (f0dfc4d5dc332d1cee34a634182e168c4efc3359)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you want Git to check object consistency on every push, you can force it to do so by setting `receive.fsckObjects` to true:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>De todas formas, si deseas que Git compruebe la consistencia de todos los objetos en todos los envios, puedes forzarle a hacerlo ajustando a 'true' el parámetro 'receive.fsckObjects':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git can transfer data between two repositories in two major ways: over HTTP and via the so-called smart protocols used in the `file://`, `ssh://`, and `git://` transports.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T130216Z" changeid="juan">
        <seg>Git puede transferir datos entre dos repositorios utilizando uno de sus dos principales mecanismos de transporte: sobre HTTP (protocolo tonto), o sobre los denominados protocolos inteligentes (utilizados en  `file://`, `ssh://` o `git://`). </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can pull the content back out of Git with the `cat-file` command.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T143234Z" changeid="juan">
        <seg>Puedes volver a recuperar los contenidos usando el comando 'cat-file'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you edit that file manually, it remains like that until the next successful push to the `gitosis-admin` project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si lo editas manualmente, permanecerá como lo dejes; hasta el próximo envio (push) al proyecto 'gitosis-admin'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Your history then looks like Figure 3-21.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El registro será algo parecido a la Figura 3-21.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Don’t include any commit you’ve already pushed to a central server — doing so will confuse other developers by providing an alternate version of the same change.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120728T084435Z" changeid="juan">
        <seg>Por tanto, es importante no afectar a ninguna confirmación de cambios que haya sido ya enviada (push) a un servidor central. So pena de confundir a otros desarrolladores, a los cuales se estaria dando una versión alternativa de un mismo cambio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The git branch command only created a new branch — it didn’t switch to that branch (see Figure 3-5).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puesto que el comando git branch solamente crea una nueva rama, y no salta a dicha rama.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You need to be careful with this technique because amending changes the SHA-1 of the commit.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T121840Z" changeid="juan">
        <seg>Es importante ser cuidadoso con esta técnica. Porque al modifcar cualquier confirmación de cambios, cambia también su código SHA-1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This denies branch and tag deletion over a push across the board — no user can do it.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto impide el borrado de ramas o de etiquetas por medio de un envio a través de la mesa (push across the board), --ningún usuario lo podrá hacer--.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>That is, you’ll learn how to contribute code successfully to a project and make it as easy on you and the project maintainer as possible, and also how to maintain a project successfully with a number of developers contributing.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Es decir, aprenderás cómo contribuir adecuadamente a un proyecto; de la forma más efectiva posible, tanto para tí, como para quien gestione el proyecto. Y aprenderás también a gestionar proyectos en los que colaboren multiples desarrolladores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In this case, database.xml stays at whatever version you originally had.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y el archivo database.xml permanecerá inalterado en cualquier que fuera la versión que tú tenias originalmente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This way, you can make sure your commits are logically separate changesets and can be easily reviewed by the developers working with you.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T211728Z" changeid="juan">
        <seg>Así, se consiguen unas confirmaciones de cambio con agrupaciones lógicas de modificaciones, facilitando su revisión por parte otros desarrolladores que trabajen con nosotros. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>At this point, you’re ready to start the walking process.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T130621Z" changeid="juan">
        <seg>sus ramas al espacio de nombres `qa/`En este punto, ya estás preparado para seguir procesando el resto de los objetos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Thus, when you clone the Git repository, you have four branches that you can check out to evaluate the project in different stages of development, depending on how cutting edge you want to be or how you want to contribute; and the maintainer has a structured workflow to help them vet new contributions.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Así, cuando clonas el repositorio de Git, obtienes cuatro ramas que puedes recuperar (checkout); pudiendo evaluar el proyecto en distintos estadios de desarrollo, dependiendo de cuán avanzado desees estar o cómo desees contribuir. Y así, los gestores de mantenimiento disponen de un flujo de trabajo estructurado, para ayudarles en el procesado e incorporación de nuevas contribuciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>While she waits for feedback from John, Jessica decides to start working on `featureB` with Josie.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Mientras espera noticias de John, Jessica decide comenzar a trabajar en la funcionalidad B (featureB) con Josie.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git hasn’t automatically created a new merge commit.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Git no crea automáticamente una nueva fusión confirmada (merge commit).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Every time your branch tip is updated for any reason, Git stores that information for you in this temporary history.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T190737Z" changeid="juan">
        <seg>Cada vez que se actualiza una rama por cualquier razón, Git almacena esa información en este histórico temporal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>These strategies are automatically chosen for you because the recursive strategy can handle complex three-way merge situations — for example, more than one common ancestor — but it can only handle merging two branches.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T140827Z" changeid="juan">
        <seg>Estas son las estrategias escogidas por defecto, ya que la estrategia recursiva puede manejar complejas fusiones-de-tres-vias --por ejemplo, con más de un antecesor común-- pero tan solo puede fusionar dos ramas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you add a section for each repository, you can specify the ones from which you want your Git daemon to allow reading.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Añadiendo una sección por cada repositorio, puedes indicar a cuáles permitirá leer el demonio Git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Resolving deltas: 100% (1952/1952), done.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T142021Z" changeid="juan">
        <seg>Resolving deltas: 100% (1952/1952), done.Resolving deltas: 100% (1952/1952), done.Resolving deltas: 100% (1952/1952), done.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can’t set a symbolic reference outside of the refs style:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T112218Z" changeid="juan">
        <seg>Pero no puedes fijar una referencia simbólica fuera de &quot;refs&quot;:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>That’s why `git push` and `git pull` work out of the box with no other arguments.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y es por eso que 'git push' y 'git pull' trabajan directamente, sin necesidad de más argumentos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If she e-mails you again later with another branch containing another great feature, you can fetch and check out because you already have the remote setup.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si más tarde vuelva a enviarte otro correo-e avisandote de otra gran funcionalidad que ha incorporado, puedes recuperarla (fetch y checkout) directamente, porque tienes el remoto ya definido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>As a general rule, your messages should start with a single line that’s no more than about 50 characters and that describes the changeset concisely, followed by a blank line, followed by a more detailed explanation.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Como regla general, tus mensajes han de comenzar con una ĺínea, de no más de 50 caracteres, donde se resuma el grupo de cambios; seguida de una línea en blanco; y seguida de una detallada explicación en las líneas siguientes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Switch back to your original story and continue working.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Vuelves a la rama del tema en que andabas antes de la llamada y continuas tu trabajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git diff
	diff --git a/chapter1.doc b/chapter1.doc
	index c1c8a0a..b93c9e4 100644
	--- a/chapter1.doc
	+++ b/chapter1.doc
	@@ -8,7 +8,8 @@ re going to cover Version Control Systems (VCS) and Git basics
	 re going to cover how to get it and set it up for the first time if you don
	 t already have it on your system.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git diff
	diff --git a/chapter1.doc b/chapter1.doc
	index c1c8a0a..b93c9e4 100644
	--- a/chapter1.doc
	+++ b/chapter1.doc
	@@ -8,7 +8,8 @@ re going to cover Version Control Systems (VCS) and Git basics
	 re going to cover how to get it and set it up for the first time if you don
	 t already have it on your system.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you follow all the internal pointers, you get an object graph something like Figure 9-3.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110807T153557Z" changeid="juan">
        <seg>Siguiendo todos los enlaces internos, puedes llegar a un gráfico similar al de la figura 9-3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Total 3 (delta 0), reused 0 (delta 0)
	To git@gitserver:iphone_project.git
	 * [new branch]      master -&gt; master</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Total 3 (delta 0), reused 0 (delta 0)
	To git@gitserver:iphone_project.git
	 * [new branch]      master -&gt; master</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git count-objects -v
	count: 4
	size: 16
	in-pack: 21
	packs: 1
	size-pack: 2016
	prune-packable: 0
	garbage: 0</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T104902Z" changeid="juan">
        <seg>$ git count-objects -v
	count: 4
	size: 16
	in-pack: 21
	packs: 1
	size-pack: 2016
	prune-packable: 0
	garbage: 0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This concept is true in Git as it is in Subversion (or any CVCS), and this model works perfectly in Git.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Este concepto es también válido en Git, tanto como en Subversion (o cualquier otro CVCS), y puede ser perfectamente utilizado en Git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You have a lot of options at this point.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T214107Z" changeid="juan">
        <seg>En estas preguntas, hay varias opciones de respuesta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Another interesting example gets `$Date$` keyword expansion, RCS style.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Otro ejemplo interesante es el de poder conseguir una expansión de la clave '$Date$' del estilo de RCS.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>#### Removing a File from Every Commit ####</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T173010Z" changeid="juan">
        <seg>#### Quitar un archivo de cada confirmación de cambios ####</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git attributes offers you two ways to do this.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Los atributos Git admiten dos maneras de realizarlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Let’s follow the `http-fetch` process for the simplegit library:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110817T155511Z" changeid="juan">
        <seg>Vamos a revisar el proceso `http-fetch` para una libreria simple de Git: </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you already have a server to which all your developers have SSH access, it’s generally easiest to set up your first repository there, because you have to do almost no work (as we covered in the last section).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si ya dispones de un servidor donde todos los desarrolladores tengan acceso SSH, te será facil colocar los repositorios en él (tal y como se verá en el próximo apartado).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Switched to a new branch &quot;serverfix&quot;</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Switched to a new branch &quot;serverfix&quot;Switched to a new branch &quot;serverfix&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>That pulls down the work John has pushed up in the meantime.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto recupera el trabajo enviado por John durante el tiempo en que Jessica estaba trabajando.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You have to set it up.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tienes que configurarlo tú mismo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is in sharp contrast to the way most VCS tools branch, which involves copying all of the project’s files into a second directory.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto contrasta fuertemente con los métodos de ramificación usados por otros sistemas de control de versiones. En los que crear una nueva rama supone el copiar todos los archivos del proyecto a una nueva carpeta adiccional.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To fork a project, visit the project page (in this case, mojombo/chronic) and click the &quot;fork&quot; button in the header (see Figure 4-14).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para bifurcar un proyecto, visita su página (en el ejemplo, mojombo/chronic) y clica sobre el botón &quot;fork&quot; de su cabecera (ver Figura 4-14) </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git rev-list 538c33..d14fc7
	d14fc7c847ab946ec39590d87783c69b031bdfb7
	9f585da4401b0a3999e84113824d15245c13f0be
	234071a1be950e2a8d078e6141f5cd20c1e61ad3
	dfa04c9ef3d5197182f13fb5b9b1fb7717d2222a
	17716ec0f1ff5c77eff40b7fe912f9f6cfd0e475</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git rev-list 538c33..d14fc7
	d14fc7c847ab946ec39590d87783c69b031bdfb7
	9f585da4401b0a3999e84113824d15245c13f0be
	234071a1be950e2a8d078e6141f5cd20c1e61ad3
	dfa04c9ef3d5197182f13fb5b9b1fb7717d2222a
	17716ec0f1ff5c77eff40b7fe912f9f6cfd0e475</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>A common switch to use with the `log` command in this case is `--left-right`, which shows you which side of the range each commit is in.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120712T201019Z" changeid="juan">
        <seg>Una opción habitual a utilizar en estos casos con el comando 'log' suele ser 'left-right'. Haciendo así que en la salida se muestre cual es el lado al que pertenece cada una de las confirmaciones de cambio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can read trees into your staging area by calling `read-tree`.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T195400Z" changeid="juan">
        <seg>Para leer árboles al área de preparación puedes utilizar el comando `read-tree`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>A new text box appears, into which you can type a username.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Aparecerá un cuadro de texto, donde podrás teclear un nombre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Compressing objects: 100% (14/14), done.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Compressing objects: 100% (14/14), done.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Although you can technically push changes to and pull changes from individuals’ repositories, doing so is discouraged because you can fairly easily confuse what they’re working on if you’re not careful.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Aunque técnicamente es posible enviar (push) y recibir (pull) cambios directamente a o desde repositorios individuales, no es muy recomendable trabajar así por la gran facilidad de confundirte si no andas con sumo cuidado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0313.png
Figure 3-13.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0313.png
Figura 3-13.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Then, she can see what has been changed with `git log`:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>A continuación, puede ver las modificaciones realizadas, lanzando el comando 'git log':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>She’s created a topic branch called `issue54` and done three commits on that branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Ha creado una rama puntual denominada 'issue54' y ha realizado tres confirmaciones de cambios (commit) en dicha rama.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>remote: Compressing objects: 100% (3/3), done.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T110259Z" changeid="juan">
        <seg>remote: Compressing objects: 100% (3/3), done.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0702.png
Figure 7-2.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0702.png
Figura 7-2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### GitHub ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### GitHub ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>However, you can use namespacing to accomplish something like that.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T120247Z" changeid="juan">
        <seg>Aunque, para conseguir algo similar, puedes utilizar los espacios de nombres .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>[group mobile_2]
	writable  = another_iphone_project
	members   = @mobile_committers john</seg>
      </tuv>
      <tuv lang="ES">
        <seg>[group mobile_2]
	writable  = another_iphone_project
	members   = @mobile_committers john</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The `cat` program is basically a no-op: it spits out the same data that it gets in.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El programa 'cat' es básicamente transparente: de él salen los mismos datos que entran.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can modify that message with details about how you resolved the merge if you think it would be helpful to others looking at this merge in the future — why you did what you did, if it’s not obvious.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes modificar este mensaje añadiendo detalles sobre cómo has resuelto la fusión, si lo consideras util para que otros entiendan esta fusión en un futuro. Se trata de indicar porqué has hecho lo que has hecho; a no ser que resulte obvio, claro está.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When people visit your project, they see this page.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cuando la gente visite tu proyecto, verá esta página.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0508.png
Figure 5-8.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0508.png
Figura 5-8.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This commit is fine, and now Git has all the information it needs to determine where the issue was introduced.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T165851Z" changeid="juan">
        <seg>Con esto el proceso de búsqueda se completa y Git tiene la información necesaria para determinar dónde comenzaron los problemas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>See 'git --help'.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>See 'git --help'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>diff --git a/lib/simplegit.rb b/lib/simplegit.rb
	index dd5ecc4..57399e0 100644
	--- a/lib/simplegit.rb
	+++ b/lib/simplegit.rb
	@@ -22,7 +22,7 @@ class SimpleGit
	   end</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T214041Z" changeid="juan">
        <seg>diff --git a/lib/simplegit.rb b/lib/simplegit.rb
	index dd5ecc4..57399e0 100644
	--- a/lib/simplegit.rb
	+++ b/lib/simplegit.rb
	@@ -22,7 +22,7 @@ class SimpleGit
	   end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## Rebasing ##</seg>
      </tuv>
      <tuv lang="ES">
        <seg>## Reorganizando el trabajo realizado ##</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Determining What Is Introduced ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Revisando lo introducido ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Last, like the Git and Local protocols, SSH is efficient, making the data as compact as possible before transferring it.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y, por último, al igual que los procolos Git y Local, SSH es eficiente, comprimiendo los datos lo más posible antes de transferirlos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git will ask you which files you would like to partially stage; then, for each section of the selected files, it will display hunks of the file diff and ask if you would like to stage them, one by one:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T092825Z" changeid="juan">
        <seg>Git preguntará cual es el archivo a pasar parcialmente al área de preparación. Y después irá mostrando trozos de las distintas secciones modificadas en el archivo, preguntando por cada una si se desea pasar o no al área de preparación:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The most straightforward way to specify a commit requires that it have a branch reference pointed at it.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T190142Z" changeid="juan">
        <seg>La manera más directa de referirse a una confirmación de cambios es teniendo una rama apuntando a ella.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can also do the opposite — make changes in the `rack` subdirectory of your master branch and then merge them into your `rack_branch` branch later to submit them to the maintainers or push them upstream.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T173644Z" changeid="juan">
        <seg>También es posible hacer el camino contrario: realizar los cambios en la subcarpeta `rack` de la rama 'master', para posteriormente fusionarlos en la rama `rack_branch` y remitirlos a los encargados del mantenimiento o enviarlos aguas arriba.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0337.png
Figure 3-37.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0337.png
Figura 3-37.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>One simple workflow merges your work into your `master` branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Una forma simple de trabajar es fusionandolo todo en tu rama 'master'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you decide to sign the tag as the maintainer, the tagging may look something like this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si decides firmar la etiqueta como gestor de mantenimientos que eres, el proceso será algo como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When you download data, the `fetch-pack` and `upload-pack` processes are involved.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T132141Z" changeid="juan">
        <seg>Cuando descargas datos, los procesos que se ven envueltos son `fetch-pack` (recuperar paquete) y `upload-pack` (enviar paquete). </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Creating a new repository on GitHub.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Creando un nuevo repositorio en GitHub.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can use it to notify a group or the author of the patch you pulled in that you’ve done so.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes utilizarlo para notificar de su aplicación al grupo o al autor del parche.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The other listing in the `git status` output is the rack entry.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T104134Z" changeid="juan">
        <seg>Dos: la entrada `rack`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>At this point, the `fetch-pack` process looks at what objects it has and responds with the objects that it needs by sending &quot;want&quot; and then the SHA it wants.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T132415Z" changeid="juan">
        <seg>En este punto, el proceso `fetch-pack` revisa los objetos que tiene y responde indicando los objetos que necesita. Enviando &quot;want&quot; (quiero) y la clave SHA que necesita.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The `branches` directory isn’t used by newer Git versions, and the `description` file is only used by the GitWeb program, so don’t worry about those.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T142448Z" changeid="juan">
        <seg>La carpeta 'branches' no se utiliza en las últimas versiones de Git, y el archivo 'description' se utiliza solo en el programa GitWeb; por lo que no necesitas preocuparte por ellos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This Perl snippet strips out anything it sees in a `$Date$` string, to get back to where you started.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esta expresión Perl extrae cualquier cosa que vea dentro de una cadena '$Date$', para devolverla a como era en un principio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You need a file in which you can store the SHA-1 value under a simple name so you can use that pointer rather than the raw SHA-1 value.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T201255Z" changeid="juan">
        <seg>Necesitarias un archivo donde almacenar los valores de las sumas de comprobación SHA-1, junto con sus respectivos nombres simples que puedas utilizar como enlaces en lugar de la propia suma de comprobación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The first line also has a list of the server’s capabilities (here, `report-status` and `delete-refs`).</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T073638Z" changeid="juan">
        <seg> La primera linea suele indicar también una lista con las capacidades del servidor, (en este caso `report-status` --dar situación-- y `delete-refs` --borrar referencias--). </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Let’s say you decide to pull in your server branch as well.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Ahora supongamos que decides traerlos (pull) también sobre tu rama 'server'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The first parent is the branch you were on when you merged, and the second is the commit on the branch that you merged in:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T191702Z" changeid="juan">
        <seg>El primer padre es el proveniente de la rama activa al realizar la fusión, y el segundo es la confirmación de cambios en la rama desde la que se fusiona.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It’s very easy for patches or other collaborated work to introduce subtle whitespace changes because editors silently introduce them or Windows programmers add carriage returns at the end of lines they touch in cross-platform projects.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Es muy facil que algunos parches u otro trabajo recibido introduzcan sutiles cambios de espaciado, porque los editores suelen hacerlo inadvertidamente o, trabajando en entornos multi-plataforma, porque programadores Windows suelen añadir retornos de carro al final de las lineas que tocan.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now you have a directory named `gitosis-admin`, which has two major parts:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Con ello, tendrás una carpeta denominada 'gitosis-admin', con dos partes principales dentro de ella:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The packfile is a single file containing the contents of all the objects that were removed from your filesystem.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T114257Z" changeid="juan">
        <seg>El archivo empaquetador es un único archivo conteniendo dentro de él todos los objetos sueltos eliminados del sistema de archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Branch References ###</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T095727Z" changeid="juan">
        <seg>### Referencias a ramas ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The `config` file contains your project-specific configuration options, and the `info` directory keeps a global exclude file for ignored patterns that you don’t want to track in a .gitignore file.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T142526Z" changeid="juan">
        <seg>El archivo 'config' contiene las opciones de configuración específicas de este proyecto concreto, y la carpeta 'info' guarda un archivo global de exclusión con los patrones a ignorar ademas de los presentes en el archivo .gitignore.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git mergetool
	merge tool candidates: kdiff3 tkdiff xxdiff meld gvimdiff opendiff emerge vimdiff
	Merging the files: index.html</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git mergetool
	merge tool candidates: kdiff3 tkdiff xxdiff meld gvimdiff opendiff emerge vimdiff
	Merging the files: index.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>0085ca82a6dff817ec66f44342007202690a93763949  15027957951b64cf874c3557a0f3547bd83b3ff6 refs/heads/master report-status
	00670000000000000000000000000000000000000000 cdfdb42577e2506715f8cfeacdbabc092bf63e8d refs/heads/experiment
	0000</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T074446Z" changeid="juan">
        <seg>0085ca82a6dff817ec66f44342007202690a93763949  15027957951b64cf874c3557a0f3547bd83b3ff6 refs/heads/master report-status
	00670000000000000000000000000000000000000000 cdfdb42577e2506715f8cfeacdbabc092bf63e8d refs/heads/experiment
	0000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is often called a pull request, and you can either generate it via the website — GitHub has a &quot;pull request&quot; button that automatically messages the maintainer — or run the `git request-pull` command and e-mail the output to the project maintainer manually.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Normalmente se suele hacer a través de una solicitud de recuperación/integración (pull request). La puedes generar directamente desde el sitio web, --GitHub tiene un botón &quot;pull request&quot; que notifica automáticamente al gestor--, o puedes lanzar el comando 'git request-pull' y enviar manualmente su salida por correo electrónico al gestor del proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can also specify another group as one of the members (using `@` as prefix), to inherit all of its members automatically:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>También puedes indicar un grupo como miembro de otro (utilizado el prefijo '@'), para incluir todos sus miembros automáticamente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git push origin featureA
	...
	To jessica@githost:simplegit.git
	 * [new branch]      featureA -&gt; featureA</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git push origin featureA
	...
	To jessica@githost:simplegit.git
	 * [new branch]      featureA -&gt; featureA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>*** Commands ***
	  1: status     2: update      3: revert     4: add untracked
	  5: patch      6: diff        7: quit       8: help
	What now&gt; 6
	           staged     unstaged path
	  1:        +1/-1      nothing index.html
	Review diff&gt;&gt; 1
	diff --git a/index.html b/index.html
	index 4d07108..4335f49 100644
	--- a/index.html
	+++ b/index.html
	@@ -16,7 +16,7 @@ Date Finder</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T213307Z" changeid="juan">
        <seg>*** Commands ***
	  1: status     2: update      3: revert     4: add untracked
	  5: patch      6: diff        7: quit       8: help
	What now&gt; 6
	           staged     unstaged path
	  1:        +1/-1      nothing index.html
	Review diff&gt;&gt; 1
	diff --git a/index.html b/index.html
	index 4d07108..4335f49 100644
	--- a/index.html
	+++ b/index.html
	@@ -16,7 +16,7 @@ Date Finder</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>A contributor clones that repository and makes changes.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Una persona que desea contribuir, clona dicho repositorio y hace algunos cambios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Everything merges cleanly, and Jessica’s history looks like Figure 5-9.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Todo se integra limpiamente, y el historial de Jessica queda como en la Figura 5-9.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Other options are `100755`, which means it’s an executable file; and `120000`, which specifies a symbolic link.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110801T122904Z" changeid="juan">
        <seg>Otras opciones son `100755`, para un achivo ejecutable; o `120000`, para un enlace simbólico. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you set this to the path of a file on your system, Git will use that file as the default message when you commit.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si preparas este ajuste para apuntar a un archivo concreto de tu sistema, Git lo utilizará como mensaje por defecto cuando hagas confirmaciones de cambio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>First, you must be relatively careful when working in the submodule directory.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T133147Z" changeid="juan">
        <seg>El primero de los cuales es la necesidad de ser bastante cuidadoso cuando se trabaja en la carpeta de un submódulo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git config --global core.autocrlf true</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git config --global core.autocrlf true</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now, each of your topics is contained within a silo — similar to a patch queue — that you can rewrite, rebase, and modify without the topics interfering or interdepending on each other as in Figure 5-16.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>De esta forma, cada uno de los temas está aislado dentro de un silo, --similar a una cola de parches--; permitiendote reescribir, reorganizar y modificar cada uno de ellos sin interferir ni crear interdependencias entre ellos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>How much work are you contributing at a time?</seg>
      </tuv>
      <tuv lang="ES">
        <seg>¿Con cuánto trabajo contribuyes?.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0524.png
Figure 5-24.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0524.png
Figura 5-24.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you want to see which files are unmerged at any point after a merge conflict, you can run `git status`:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para ver qué archivos permanecen sin fusionar en un determinado momento conflictivo de una fusión, puedes usar el comando 'git status':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### The Shortlog ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### El registro rápido ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The issue with vendoring the code into your own project is that any custom changes you make are difficult to merge when upstream changes become available.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T170344Z" changeid="juan">
        <seg>La problemática en el segundo caso radica en las complicaciones para fusionar las personalizaciones realizadas por nosotros con futuras copias de la biblioteca original. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>They’re all also within the packfile you just downloaded, so you don’t have to do any more requests to your server.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T131355Z" changeid="juan">
        <seg>Y, como estás también están dentro del archivo empaquetado que acabas de descargar, ya no necesitas hacer mas peticiones al servidor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>All Git objects are stored the same way, just with different types — instead of the string blob, the header will begin with commit or tree.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T145846Z" changeid="juan">
        <seg>Todos los demas objetos Git se almacenan de forma similar, pero con la diferencia de que sus cabeceras comienzan con un tipo diferente. En lugar de 'blob' (objeto binario grande), comenzarán por 'commit' (confirmación de cambios), o por 'tree' (árbol).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can look into the packfile and see what Git did to save space.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110815T212441Z" changeid="juan">
        <seg>Puedes comprobarlo mirando en el interior del archivo empaquetador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In most scenarios, if you want color codes in your redirected output, you can instead pass a `--color` flag to the Git command to force it to use color codes.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En la mayor parte de las ocasiones, cuando necesites códigos de color en los resultados, es mejor indicar puntualmente la opción '--color' en el comando concreto, para obligarle a utilizar códigos de color.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Create a branch for a new story you’re working on.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Creas una rama para un nuevo tema sobre el que quieres trabajar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Set your key ID like so:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Configurando tu clave ID de esta forma: </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you want to see a list of all the options your version of Git recognizes, you can run</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si quieres consultar una lista completa, con todas las opciones contempladas en tu versión de Git, puedes lanzar el comando:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This way, you can set up HTTP-based read access to any of your projects for a fair number of users in a few minutes.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>De esta manera, puedes preparar en cuestión de minutos accesos de lectura basados en HTTP a tus proyectos, para grandes cantidades de usuarios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>General sequence of events for a simple multiple-developer Git workflow.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Secuencia general de eventos en un flujo de trabajo multidesarrollador simple.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can also manually repack at any time by running `git gc` by hand.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T115045Z" changeid="juan">
        <seg>Pero, también tu mismo puedes reempaquetar en cualquier momento, lanzando manualmente el comando `git gc`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The git fetch command updates your remote references.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El comando 'git fetch' actualiza tus referencias remotas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Or, to compare what is in your `rack` subdirectory with what the `master` branch on the server was the last time you fetched, you can run</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T173726Z" changeid="juan">
        <seg>O, otro ejemplo: para comparar el contenido de la subcarpeta `rack` con la rama `master` en el servidor: </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This command also exits with a non-zero status if the check fails, so you can use it in scripts if you want.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Además, este comando retorna con un status no-cero en caso de fallar la comprobación, por lo que puedes utilizarlo en scripts si lo deseas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To run `filter-branch` on all your branches, you can pass `--all` to the command.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T175646Z" changeid="juan">
        <seg>Si se desea lanzar `filter-branch` sobre todas las ramas del repositorio, se ha de pasar la opción `--all` al comando. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you replace an image in your project and run `git diff`, you see something like this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si sustituyes alguna de las imagenes en tu proyecto, y lanzas el comando 'git diff' obtendrás algo como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### More Interesting Rebases ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Algunas otras reorganizaciones interesantes ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you run it with no arguments, you get a simple listing of your current branches:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si lo lanzas sin argumentos, obtienes una lista de las ramas presentes en tu proyecto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It’s generally easier to think about them as work silos, where sets of commits graduate to a more stable silo when they’re fully tested (see Figure 3-19).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Podría ser más sencillo pensar en las ramas como si fueran silos de almacenamiento. Donde grupos de confirmaciones de cambio (commits) van promocionando hacia silos más estables a medida que son probados y depurados (ver Figura 3-19)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Formatting and whitespace issues are some of the more frustrating and subtle problems that many developers encounter when collaborating, especially cross-platform.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El formato y los espacios en blanco son la fuente de los problemas más sutiles y frustrantes que muchos desarrolladores se pueden encontrar en entornos colaborativos, especialmente si son multi-plataforma.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Assume that you have the rack files in a subdirectory of your project, and you want to switch it to a submodule.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T172657Z" changeid="juan">
        <seg>Asumiendo que se tenian archivos en una carpeta 'rack' del proyecto, y que se desea intercambiarla por un submódulo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git log --pretty=oneline  master
	1a410efbd13591db07496601ebc7a059dd55cfe9 third commit
	cac0cab538b970a37ea1e769cbbde608743bc96d second commit
	fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T191103Z" changeid="juan">
        <seg>$ git log --pretty=oneline  master
	1a410efbd13591db07496601ebc7a059dd55cfe9 third commit
	cac0cab538b970a37ea1e769cbbde608743bc96d second commit
	fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you run a `log`, you see something like this:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T122529Z" changeid="juan">
        <seg>En este último, se suele ver algo así como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You have to be careful, though, because the `.gitattributes` file is committed and passed around with the project but the driver (in this case, `dater`) isn’t; so, it won’t work everywhere.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>No obstante, debes de ser cuidadoso, ya que el archivo '.gitattibutes' se almacena y se transmite junto con el proyecto; pero no así el propio filtro, (en este caso, 'dater'), sin el cual no puede funcionar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you delete the subdirectory and then run `submodule add`, Git yells at you:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T172729Z" changeid="juan">
        <seg>Si se borra la carpeta y luego se lanza un comando `submodule add`, Git avisará de &quot;carpeta ya existente en el índice&quot;:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Doing so moves the `iss53` branch forward, because you have it checked out (that is, your HEAD is pointing to it; see Figure 3-12):</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Con ello avanzas la rama 'iss53', que es la que tienes activada (checked out) en este momento (es decir, a la que apunta HEAD; ver Figura 3-12):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>So, these are scripts to help developers, and they must be set up and maintained by them, although they can be overridden or modified by them at any time.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por tanto, estos scripts son para ayudar a los desarrolladores, y, como tales, han de ser configurados y mantenidos por ellos, pudiendo ser sobreescritos o modificados por ellos en cualquier momento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now, you can run `git fetch teamone` to fetch everything server has that you don’t have yet.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Ahora, puedes usar el comando 'git fetch teamone' para recuperar todo el contenido del servidor que tu no tenias.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This leaves four important entries: the `HEAD` and `index` files and the `objects` and `refs` directories.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto nos deja con cuatro entradas importantes: los archivos 'HEAD' e 'index' y las carpetas 'objects' y 'refs'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>=&gt; GET objects/pack/pack-816a9b2334da9953e530f27bcac22082a9f5b835.pack
	(13k of binary data)</seg>
      </tuv>
      <tuv lang="ES" changedate="20110817T224605Z" changeid="juan">
        <seg>=&gt; GET objects/pack/pack-816a9b2334da9953e530f27bcac22082a9f5b835.pack
	(13k of binary data)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The `format-patch` command prints out the names of the patch files it creates.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El comando `format-patch` lista los nombres de los archivos de parche que crea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can name this file `expand_date` and put it in your path.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes llamar 'expand_date' a este archivo y ponerlo en el path de ejecución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>She can do so by specifying the local branch followed by a colon (:) followed by the remote branch to the `git push` command:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puede hacerlo usando el comando 'git push' e indicando específicamente el nombre de la rama local seguida de dos puntos (:) y seguida del nombre de la rama remota:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Having a good guideline for creating commits and sticking to it makes working with Git and collaborating with others a lot easier.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Disponer unas reglas claras para crear confirmaciones de cambios, y seguirlas fielmente, facilta enormemente tanto el trabajo con Git y como la colaboración con otras personas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Revert &quot;added file_size&quot;
	stash@{2}: WIP on master: 21d80a5... added number to log
	$ git stash drop stash@{0}
	Dropped stash@{0} (364e91f3f268f0900bc3ee613f9f733e82aaed43)</seg>
      </tuv>
      <tuv lang="ES" changedate="20120712T203818Z" changeid="juan">
        <seg>Revert &quot;added file_size&quot;
	stash@{2}: WIP on master: 21d80a5... added number to log
	$ git stash drop stash@{0}
	Dropped stash@{0} (364e91f3f268f0900bc3ee613f9f733e82aaed43)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Stashing Your Work ###</seg>
      </tuv>
      <tuv lang="ES" changedate="20120712T202515Z" changeid="juan">
        <seg>### Guardando el trabajo temporalmente ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It’s like a branch reference, but it never moves — it always points to the same commit but gives it a friendlier name.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T112350Z" changeid="juan">
        <seg>Es como una referencia a una rama, pero permaneciendo siempre inmovil, --apuntando siempre a la misma confirmación de cambios--, dándo un nombre mas amigable a esta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Centralized Workflow ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Flujo de trabajo centralizado ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It tries to run a command on the remote server via an SSH call that looks something like this:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T073814Z" changeid="juan">
        <seg>En el servidor remoto, a través de una llamada SSH, intentará lanzar un comando tal como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The big object is at the bottom: 2MB.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T105924Z" changeid="juan">
        <seg>El archivo enorme es el último: 2 MB  (2056716 Bytes para ser exactos).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now you want to switch branches, but you don’t want to commit what you’ve been working on yet; so you’ll stash the changes.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120712T202610Z" changeid="juan">
        <seg>Si justo en este momento se desea cambiar de rama, pero sin confirmar los cambios realizados hasta entonces; la solución es un guardado rápido provisional de los cambios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git fsck --full
	dangling blob d670460b4b4aece5915caf5c68d12f560a9fe3e4
	dangling commit ab1afef80fac8e34258ff41fc1b867c702daa24b
	dangling tree aea790b9a58f6cf6f2804eeac9f0abbe9631e4c9
	dangling blob 7108f7ecb345ee9d0084193f147cdad4d2998293</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T144213Z" changeid="juan">
        <seg>$ git fsck --full
	dangling blob d670460b4b4aece5915caf5c68d12f560a9fe3e4
	dangling commit ab1afef80fac8e34258ff41fc1b867c702daa24b
	dangling tree aea790b9a58f6cf6f2804eeac9f0abbe9631e4c9
	dangling blob 7108f7ecb345ee9d0084193f147cdad4d2998293</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can delete a remote branch using the rather obtuse syntax `git push [remotename] :[branch]`.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes borrar la rama remota utilizando la un tanto confusa sintaxis:  'git push [nombreremoto] :[rama]'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is how other people who clone this project know where to get the submodule projects from.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T104033Z" changeid="juan">
        <seg>Así es como otras personas que clonen el proyecto pueden saber dónde encontrar los submódulos del mismo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>There are a lot of client-side hooks.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Hay muchos de ellos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>A push to the project takes the `gitosis.conf` file you just pushed up and sticks it there.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Un envio (push) de cambios al proyecto, coge el archivo 'gitosis.conf' enviado y sobreescribe con él el del servidor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The Your Clone URL is a read/write SSH-based URL that you can read or write over only if you connect with the SSH private key associated with the public key you uploaded for your user.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El enlace &quot;Your Clone URL&quot;, es un enlace de lectura/escritura basado en SSH; a través del cual puedes leer y escribir, pero solo si te conectas con la clave SSH privada correspondiente a la clave pública que has cargado para tu usuario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you commit those changes and check out the file again, you see the keyword properly substituted:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Al confirmar cambios (commit) y luego extraer (checkout) el archivo de vuelta, verás la clave sutituida:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You’ll learn how to work in an environment where small groups collaborate on features and then those team-based contributions are integrated by another party.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Aprenderás cómo trabajar en un entorno donde pequeños grupos colaboran en algunas funcionalidades, y luego todas las aportaciones de esos equipos son integradas por otro grupo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git bisect bad
	Bisecting: 1 revisions left to test after this
	[f71ce38690acf49c1f3c9bea38e09d82a5ce6014] drop exceptions table</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T072348Z" changeid="juan">
        <seg>$ git bisect bad
	Bisecting: 1 revisions left to test after this
	[f71ce38690acf49c1f3c9bea38e09d82a5ce6014] drop exceptions table</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>At this point, you should be able to visit `http://gitserver/` to view your repositories online, and you can use `http://git.gitserver` to clone and fetch your repositories over HTTP.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En este momento, deberias poder visitar 'http://gitserver/' para ver tus repositorios online. Y utilizar 'http://git.gitserver' para clonar (clone) y recuperar (fetch) tus repositorios a través de HTTP.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you’ve allowed everyone to connect with a single user (like &quot;git&quot;) via public-key authentication, you may have to give that user a shell wrapper that determines which user is connecting based on the public key, and set an environment variable specifying that user.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si has permitido a cualquiera conectarse con un mismo usuario (como &quot;git&quot;, por ejemplo), has tenido que dar a dicho usuario una envoltura (shell wraper) que te permite determinar cual es el usuario que se conecta según sea su clave pública, permitiendote fijar una variable de entorno especificando dicho usuario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git fetch origin
	...
	From jessica@githost:simplegit
	   3300904..aad881d  featureA   -&gt; origin/featureA</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git fetch origin
	...
	From jessica@githost:simplegit
	   3300904..aad881d  featureA   -&gt; origin/featureA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Here you’ll see how to do the same rack embedding as in the last section, but using subtree merges instead.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T173105Z" changeid="juan">
        <seg>En este caso se va a mostrar cómo se haria el mismo empotramiento del módulo rack tomado como ejemplo anteriormente, pero utilizando fusiones de subarbol en lugar de submódulos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To do this properly, you need a small script that takes a filename, figures out the last commit date for this project, and inserts the date into the file.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para hacerlo, necesitas un pequeño script que coja el nombre de un archivo, localice la fecha de la última confirmación de cambios en el proyecto, e inserte dicha información en el archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Deleting Remote Branches ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Borrando ramas remotas ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg># Git Internals #</seg>
      </tuv>
      <tuv lang="ES">
        <seg># Los entesijos internos de Git #</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>They have another parallel branch named develop or next that they work from or use to test stability — it isn’t necessarily always stable, but whenever it gets to a stable state, it can be merged into `master`.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Teniendo otras ramas paralelas denominadas 'desarrollo' o 'siguiente', en las que trabajan y realizan pruebas. Estas ramas paralelas no suele estar siempre en un estado estable; pero cada vez que sí lo están, pueden ser fusionadas con la rama 'master'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>#### Multiple Points ####</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T201333Z" changeid="juan">
        <seg>#### Puntos multiples ####</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For example, to change your `extDiff` and `extMerge` tools to run the KDiff3 tool instead, all you have to do is edit your `extMerge` file:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por ejemplo, para cambiar tus scripts 'extDiff' y 'extMerge' para utilizar KDiff3, tan solo has de editar el archivo 'extMerge:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Conflicts:
	  index.html
	#
	# It looks like you may be committing a MERGE.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Conflicts:
	  index.html
	#
	# It looks like you may be committing a MERGE.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is important because with more and more developers, you run into more issues with making sure your code applies cleanly or can be easily merged.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto es importante, ya que cuantos más desarrolladores haya, mayores serán los problemas para asegurarte de que tu código se integre limpiamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You begin by reading this data into a structure that you can use.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para implementarlo, hemos de leer previamente estos datos en una estructura que podamos emplear.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Jessica’s history after fetching John’s changes.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El historial de Jessica tras recuperar los cambios de John.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git config --global user.signingkey &lt;gpg-key-id&gt;</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git config --global user.signingkey &lt;gpg-key-id&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>#### Rebasing and Cherry Picking Workflows ####</seg>
      </tuv>
      <tuv lang="ES">
        <seg>#### Flujos de trabajo reorganizando o entresacando ####</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The book’s first eight chapters deal almost exclusively with porcelain commands.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Los primeros ocho capítulos de este libro se encargan casi exclusivamente de los comandos de porcelana.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git push -f origin master
	Counting objects: 5, done.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git push -f origin master
	Counting objects: 5, done.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When you’re branching and merging, everything is being done only in your Git repository — no server communication is happening.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cuando ramificas y fusionas, todo se realiza en tu propio repositorio Git. No hay nigún tipo de tráfico con ningún servidor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git cat-file -t 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a
	blob</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git cat-file -t 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a
	blob</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Basic Merging ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Procedimientos básicos de fusión ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>But in this chapter, you’ll be dealing mostly with the lower-level plumbing commands, because they give you access to the inner workings of Git and help demonstrate how and why Git does what it does.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110717T111952Z" changeid="juan">
        <seg>Pero en este capítulo trataremos sobre todo con los comandos de fontaneria; comandos que te darán acceso a los entresijos internos de Git y que te ayudarán a comprender cómo y por qué hace Git lo que hace como lo hace.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you’re merging more than two branches, Git picks the _octopus_ strategy.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T172959Z" changeid="juan">
        <seg>Si se están fusionando más de dos ramas, Git suele escoger la _estrategia_del_pulpo_ (_octopus_ strategy).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The two that are disabled by default but can be turned on are `indent-with-non-tab`, which looks for lines that begin with eight or more spaces instead of tabs, and `cr-at-eol`, which tells Git that carriage returns at the end of lines are OK.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Los dos inactivos por defecto son 'indent-with-non-tab' (indentado sin tabuladores), que vigila por si alguna línea empieza con ocho o mas espacios en lugar de con tabuladores; y 'cr-at-eol' (retorno de carro al final de línea), que vigila para que haya retornos de carro en todas las líneas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In this case, you already know what file it is.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T105306Z" changeid="juan">
        <seg>En este caso, ya sabes de antemano cual es.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git cat-file -p 83baae61804e65cc73a7201a7252750c76066a30 &gt; test.txt
	$ cat test.txt
	version 1</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git cat-file -p 83baae61804e65cc73a7201a7252750c76066a30 &gt; test.txt
	$ cat test.txt
	version 1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can think of the data that Git contains for these structures as being like Figure 9-2.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110807T145441Z" changeid="juan">
        <seg>Puedes pensar en algo parecido a la Figura 9-2 para representar los datos guardados por Git para estas estructuras.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>After the entire commit process is completed, the `post-commit` hook runs.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Despues de completar todo el proceso de confirmación de cambios, es cuando se lanza el punto de enganche 'post-commit'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You should now have a copy of the Git directory data in your `my_project.git` directory.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tras esto, tendrás una copia de los datos en tu carpeta 'my_project.git'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Be warned: this technique is destructive to your commit history.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T134444Z" changeid="juan">
        <seg>Una advertencia importante: estas técnicas son destructivas y alteran el historia de confirmaciones de cambio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>HEAD@{2}: commit: added some blame and merge stuff
	1c36188...</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T102025Z" changeid="juan">
        <seg>HEAD@{2}: commit: added some blame and merge stuff
	1c36188...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git concatenates the header and the original content and then calculates the SHA-1 checksum of that new content.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T200537Z" changeid="juan">
        <seg>Git concatena la cabecera y el contenido original, para calcular la suma de control SHA-1 conjunta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To remove it, you can run `git stash drop` with the name of the stash to remove:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120712T205932Z" changeid="juan">
        <seg>Para quitarlos de ahí, es necesario lanzar expresamente el comando `git stash drop` e indicar el número de guardado a borrar de la pila:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git log -1
	commit 0550271328a0038865aad6331e620cd7238601bb
	Author: Scott Chacon &lt;schacon@gmail.com&gt;
	Date:   Thu Apr 9 09:03:56 2009 -0700</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T105435Z" changeid="juan">
        <seg>$ git log -1
	commit 0550271328a0038865aad6331e620cd7238601bb
	Author: Scott Chacon &lt;schacon@gmail.com&gt;
	Date:   Thu Apr 9 09:03:56 2009 -0700</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is roughly the same script as the server-side part, but with two important differences.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Este es un script prácticamente igual al del lado servidor. Pero con dos importantes diferencias.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### The Nuclear Option: filter-branch ###</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T172339Z" changeid="juan">
        <seg>### La opción nuclear: filter-branch ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Let’s say you create a new branch called testing.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por ejemplo, si quieres crear una nueva rama denominada &quot;testing&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git is a content-addressable filesystem.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Git es un sistema de archivo orientado a contenidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Each time, Git will stop, let you amend the commit, and continue when you’re finished.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T185653Z" changeid="juan">
        <seg>En cada una de ellas, Git se detendrá, permitiendo enmendar la confirmación de cambios y continuar tras la modificación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>At that point, anyone who can access the web server under which you put the repository can also clone your repository.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>A partir de ese momento, cualquiera con acceso al servidor web podrá clonar tu repositorio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Again, you can use any web server for this; but as an example, we’ll demonstrate some basic Apache configurations that should give you an idea of what you might need.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Veremos algunas configuraciones básicas de Apache, para que puedas hacerte una idea de lo que puedes necesitar. (Recordar que esto es solo un ejemplo, y que puedes utilizar cualquier otro servidor web.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git config --global core.autocrlf false</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git config --global core.autocrlf false</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now that you’ve created, merged, and deleted some branches, let’s look at some branch-management tools that will come in handy when you begin using branches all the time.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Ahora que ya has creado, fusionado y borrado algunas ramas, vamos a dar un vistazo a algunas herramientas de gestión muy útiles cuando comienzas a utilizar ramas profusamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git rebase --continue</seg>
      </tuv>
      <tuv lang="ES" changedate="20120728T090036Z" changeid="juan">
        <seg>$ git rebase --continue</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you’ve been tracking files in your project and you want to move them out into a submodule, you must be careful or Git will get angry at you.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T135633Z" changeid="juan">
        <seg>Si se ha estado trabajando en archivos de un proyecto al que luego se desea convertir en un submódulo, hay que ser muy cuidadoso o Git se resentirá.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Gitosis is going to manage your keys for you, so you need to remove the current file, re-add the keys later, and let Gitosis control the `authorized_keys` file automatically.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Gitosis manejará tus claves por tí, por lo que tendrás que quitar el archivo actual, añadir de nuevo las claves más tarde, y dejar que Gitosis tome automáticamente el control del archivo 'authorized_keys'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The index is a file that contains offsets into that packfile so you can quickly seek to a specific object.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T114612Z" changeid="juan">
        <seg>El índice es un archivo que contiene las posiciones de cada uno de esos objetos dentro del archivo empaquetador. Permitiendonos así buscarlos y extraer rápidamente cualquiera de ellos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can also combine these syntaxes — you can get the second parent of the previous reference (assuming it was a merge commit) by using `HEAD~3^2`, and so on.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T191849Z" changeid="juan">
        <seg>E incluso también es posible combinar las dos sintaxis. Por ejemplo, para referirse al &quot;segundo padre de la referencia previa&quot; (asumiendo que es una confirmación de cambios de fusión -merge-), se pude escribir algo como `HEAD~3^2`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is a powerful tool that can help you check hundreds of commits for an introduced bug in minutes.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T170037Z" changeid="juan">
        <seg>Esta es una poderosa herramienta que permite chequear en minutos cientos de confirmaciones de cambio, para determinar rápidamente en que punto se pudo introducir el error.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can remove the `client` and `server` branches because all the work is integrated and you don’t need them anymore, leaving your history for this entire process looking like Figure 3-35:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y por último puedes eliminar las ramas 'client' y 'server' porque ya todo su contenido ha sido integrado y no las vas a necesitar más. Dejando tu registro tras todo este proceso tal y como se muestra en la Figura 3-35:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0506.png
Figure 5-6.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0506.png
Figura 5-6.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In that case, the `git am` process will fail and ask you what you want to do:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En ese caso, el proceso 'git am' fallará y te preguntará qué deseas hacer:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>These are some commonly used workflows that are possible with a distributed system like Git, but you can see that many variations are possible to suit your particular real-world workflow.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Hemos visto algunos de los flujos de trabajo mas comunes permitidos por un sistema distribuido como Git. Pero seguro que habrás comenzado a vislumbrar multiples variaciones que puedan encajar con tu particular forma de trabajar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Also, although the blob content can be nearly anything, the commit and tree content are very specifically formatted.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T145903Z" changeid="juan">
        <seg>Además, el contenido de un binario (blob) puede ser prácticamente cualquier cosa. Mientras que el contenido de una confirmación de cambios (commit) o de un árbol (tree) han de seguir unos formatos internos muy concretos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For a more in-depth tutorial on creating an SSH key on multiple operating systems, see the GitHub guide on SSH keys at `http://github.com/guides/providing-your-ssh-key`.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para más detalles sobre cómo crear unas claves SSH en variados sistemas operativos, consultar la correspondiente guia en GitHub:  `http://github.com/guides/providing-your-ssh-key`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git commit --amend</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T121707Z" changeid="juan">
        <seg>$ git commit --amend</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git comes preset to detect and fix some whitespace issues.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Git viene preajustado para detectar y resolver algunos de los problemas más tipicos relacionados con los espacios en blanco.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Generally, you’ll type `y` or `n` if you want to stage each hunk, but staging all of them in certain files or skipping a hunk decision until later can be helpful too.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120712T202011Z" changeid="juan">
        <seg>Habitualmente se tecleará 'y' o 'n' según se desee pasar o no cada trozo. Pero habrá ocasiones donde pueda ser útil pasar todos ellos conjuntamente, o el dejar para más tarde la decisión sobre un trozo concreto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>So, if there is a `master` branch on the server, you can access the log of that branch locally via</seg>
      </tuv>
      <tuv lang="ES" changedate="20110815T220255Z" changeid="juan">
        <seg>De tal forma que, si existe una rama `master` en el servidor, puedes acceder a ella localmente a través de  </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For example, if you make two changes to your simplegit.rb file and want to stage one of them and not the other, doing so is very easy in Git.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T213804Z" changeid="juan">
        <seg>Por ejemplo, si se han realizado dos cambios en el archivo simplegit.rb y se desea pasar solo uno de ellos al área de preparación, pero no el otro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now `origin/master` is reachable from Jessica’s `master` branch, so she should be able to successfully push (assuming John hasn’t pushed again in the meantime):</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En este punto, la rama 'origin/master' es alcanzable desde la rama 'master' de Jessica, permitiendole enviar (push) --asumiendo que John no haya enviado nada más durante ese tiempo--:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If they’re safe, they’re merged into `next`, and that branch is pushed up so everyone can try the topics integrated together.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Las funcionalidades que resultan ser seguras y estar preparadas se fusionan (merge) en la rama 'next'; y esta es enviada (push) al repositorio público, para que cualquiera pueda probarlas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When other developers try to run `git submodule update`, the submodule system can’t find the commit that is referenced, because it exists only on the first developer’s system.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T171945Z" changeid="juan">
        <seg>Cuando otros desarrolladores intenten lanzar un `git submodule update`, será imposible encontrar la confirmación de cambios a la que se refiere el submódulo, ya que esta tan solo existe en el sistema del desarrollador original.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ ssh user@git.example.com
	$ cd /opt/git/my_project.git
	$ git init --bare --shared</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ ssh user@git.example.com
	$ cd /opt/git/my_project.git
	$ git init --bare --shared</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The first script to run when handling a push from a client is `pre-receive`.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El primer script que se activa al manejar un envio de un cliente es el correspondiente al punto de enganche 'pre-receive'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>**Do not rebase commits that you have pushed to a public repository.**</seg>
      </tuv>
      <tuv lang="ES">
        <seg>**Nunca reorganices confirmaciones de cambio (commits) que hayas enviado (push) a un repositorio público.**</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Rebasing your server branch on top of your master branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Reorganizando la rama 'server' sobre la rama 'branch'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You’ll add some larger content to the repository to demonstrate an interesting feature of Git.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110810T230104Z" changeid="juan">
        <seg>Puedes añadir algún otro archivo de gran contenido al repositorio. Y verás una interesante funcionalidad de Git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Then, when the script drops you to the command line, you reset that commit, take the changes that have been reset, and create multiple commits out of them.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120728T093053Z" changeid="juan">
        <seg>Después, cuando el script devuelva la línea de comandos, se ha de deshacer (reset) esa confirmación de cambios, coger los cambios recién deshechos y crear multiples nuevas confirmaciones de cambios con ellos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You’ll have the `update` hook look at those rules, see what files are being introduced for all the commits being pushed, and determine whether the user doing the push has access to update all those files.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y tienes que preparar el enganche 'update' para hacerle consultar esas reglas, mirar los archivos que están siendo subidos en las confirmaciones de cambio (commit) enviadas (push), y determinar así si el usuario emisor del  envio tiene o no permiso para actualizar esos archivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Because the reflog data is kept in the `.git/logs/` directory, you effectively have no reflog.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T144036Z" changeid="juan">
        <seg>La información de registro (reflog) se guarda en la carpeta `.git/logs/`; por lo que, borrandola, nos quedamos efectivamente sin registro. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The difference becomes apparent when you specify a number.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T090008Z" changeid="juan">
        <seg>Pero la diferencia comienza al indicar un número tras ella.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>However, any language will work fine.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Pero, puede ser igualmente válido cualquier otro lenguaje.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The public keys look something like this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La clave pública será una serie de números, letras y signos, algo así como esto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>But suppose you didn’t; how would you identify what file or files were taking up so much space?</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T134947Z" changeid="juan">
        <seg>Pero suponiendo que no lo supieras, ¿cómo podrías identificar el archivo o archivos que están ocupando tanto espacio?.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Often, the quickest way is to use a tool called `git reflog`.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T142345Z" changeid="juan">
        <seg>El método más rápido para conseguirlo suele ser utilizar una herramienta denominada `git reflog`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>#### commit.template ####</seg>
      </tuv>
      <tuv lang="ES">
        <seg>#### commit.template ####</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is a configuration file that stores the mapping between the project’s URL and the local subdirectory you’ve pulled it into:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T170641Z" changeid="juan">
        <seg>un archivo de configuración para almacenar las relaciones entre la URL del proyecto y la subcarpeta local donde se ha colocado este.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>With the `rebase` command, you can take all the changes that were committed on one branch and replay them on another one.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Con el comando 'git rebase', puedes coger todos los cambios confirmados en una rama, y reaplicarlos sobre otra.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Issues with Submodules ###</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T132927Z" changeid="juan">
        <seg>### Posibles problemáticas al usar submódulos ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The Graphs tab has some contribution visualizations and statistics about your project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La pestaña &quot;Graphs&quot; muestra diversas visualizaciones sobre contribuciones y estadísticas de tu proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is the basic information that the commit object stores for you.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T145215Z" changeid="juan">
        <seg>Este es el tipo de información que almacenan para tí los objetos de confirmación de cambios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>/usr/bin/env ruby
	data = STDIN.read
	last_date = `git log --pretty=format:&quot;%ad&quot; -1`
	puts data.gsub('$Date$', '$Date: ' + last_date.to_s + '$')</seg>
      </tuv>
      <tuv lang="ES">
        <seg>/usr/bin/env ruby
	data = STDIN.read
	last_date = `git log --pretty=format:&quot;%ad&quot; -1`
	puts data.gsub('$Date$', '$Date: ' + last_date.to_s + '$')</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Rebasing changes the SHA-1 hashes of these commits so to Git they look like new commits, when in fact you already have the C4 work in your history (see Figure 3-39).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La reorganización cambia los resumenes (hash) SHA-1 de esas confirmaciones (commits), haciendo que Git se crea que son nuevas confirmaciones. Cuando realmente tu ya tenias el trabajo de C4 en tu registro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>#### user.signingkey ####</seg>
      </tuv>
      <tuv lang="ES">
        <seg>#### user.signingkey ####</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>remote: Total 6 (delta 0), reused 0 (delta 0)
	Receiving objects: 100% (6/6), done.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T105624Z" changeid="juan">
        <seg>remote: Total 6 (delta 0), reused 0 (delta 0)
	Receiving objects: 100% (6/6), done.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can modify these limits with the `gc.auto` and `gc.autopacklimit` config settings, respectively.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T092342Z" changeid="juan">
        <seg>Estos límites pueden configurarse con las opciones de configuración  `gc.auto` y `gc.autopacklimit`, respectivamente. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you add text between the `---` line and the beginning of the patch (the `lib/simplegit.rb` line), then developers can read it; but applying the patch excludes it.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si añades texto entre la línea que comienza por `---` y el comienzo del parche (la línea `lib/simplegit.rb). Los desarrolladores de la lista de correo podrán leerlo. Pero será ignorado al aplicar el parche al proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Note that someone must shell onto the machine and create a bare repository every time you want to add a project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cabe indicar que alguien tendrá que iniciar sesión en la máquina y crear un repositorio básico, cada vez que se desee añadir un nuevo proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>All the server-side work will go into the update file in your hooks directory.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Todo el trabajo del lado servidor va en el script 'update' de la carpeta 'hooks'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Jessica’s initial commit history.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Historial inicial de Jessica.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This discussion will include not having to create user accounts for each user, adding public read access to repositories, setting up web UIs, using the Gitosis tool, and more.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Incluyendo temas tales como el evitar crear cuentas para cada usuario, el añadir acceso público de lectura, el disponer interfaces de usuario web, el usar la herramienta Gitosis, y mucho más.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>There are a couple of reasons for this — the object could be in an alternate repository, or it could be in a packfile in this repository.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T130844Z" changeid="juan">
        <seg>Puede haber un par de razones para que suceda esto: el objeto está en otro repositorio alternativo; o el objeto está en este repositorio, pero dentro de un objeto empaquetador (packfile).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now, run the `cat-file` command on that SHA-1 value:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T112609Z" changeid="juan">
        <seg>Ahora, lanzando el comando `cat-file` para ese valor SHA-1: </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can’t use partial globs in the pattern, so this would be invalid:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T120128Z" changeid="juan">
        <seg>Pero, en ningún caso puedes poner referencias genéricas parciales; por ejemplo, algo como esto sería erroneo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The second developer, Jessica, does the same thing — clones the repository and commits a change:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La segunda desarrolladora, Jessica, hace lo mismo: clona el repositorio y confirma algunos cambios:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This hook can likewise validate the presence of files external to Git control that you may want copied in when the working tree changes.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Este punto de enganche puede utilizarse también para comprobar la presencia de ciertos archivos, externos al control de Git, que desees copiar cada vez que cambie la carpeta de trabajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The `gc` stands for garbage collect, and the command does a number of things: it gathers up all the loose objects and places them in packfiles, it consolidates packfiles into one big packfile, and it removes objects that aren’t reachable from any commit and are a few months old.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T132641Z" changeid="juan">
        <seg>`gc` corresponde a &quot;recogida de basura&quot; (garbage collect), y este comando realiza toda una serie de acciones: recoge los objetos sueltos y los agrupa en archivos empaquetadores; consolida los archivos empaquetadores pequeños en un solo gran archivo empaquetador; retira los objetos antiguos no incorporados a ninguna confirmación de cambios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This way, when people clone your project’s repository, they can either check out master to build the latest stable version and keep up to date on that easily, or they can check out develop, which is the more cutting-edge stuff.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>De esta forma, cuando alguien clone el repositorio de tu proyecto, podrá recuperar (checkout) y mantener actualizadas tanto la última version estable como la versión con el material más avanzado; en las ramas 'master' y 'develop', respectivamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can distribute these hooks within the project or in a separate project, but there is no way to set them up automatically.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes distribuir esos enganches dentro del mismo proyecto o en un proyecto separado. Pero no hay modo de implementarlos automáticamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git bisect good
	Bisecting: 3 revisions left to test after this
	[b047b02ea83310a70fd603dc8cd7a6cd13d15c04] secure this thing</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T072139Z" changeid="juan">
        <seg>$ git bisect good
	Bisecting: 3 revisions left to test after this
	[b047b02ea83310a70fd603dc8cd7a6cd13d15c04] secure this thing</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The commit message by default looks something like this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El mensaje de confirmación por defecto será algo parecido a:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When you rebase stuff, you’re abandoning existing commits and creating new ones that are similar but different.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cuando reorganizas algo, estás abandonando las confirmaciones de cambio ya creadas y estás creando unas nuevas; que son similares, pero diferentes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For each reference that this push will update, the `send-pack` process tells the `receive-pack` process that information.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T131940Z" changeid="juan">
        <seg>Para cada una de las referencias que se van a actualizar, el proceso `send-pack` llama al proceso `receive-pack` con la información pertinente.  </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git merge topic
	Auto-merging database.xml
	Merge made by recursive.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git merge topic
	Auto-merging database.xml
	Merge made by recursive.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You do this with the `git merge` command:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto se hace con el comando 'git merge':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can save a stash on one branch, switch to another branch later, and try to reapply the changes.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120712T205453Z" changeid="juan">
        <seg>Es perfectamente posible guardar rápidamente (stash) el estado de una rama. Cambiar posteriormente a otra rama. Y proceder a aplicar sobre esta otra rama los cambios guardados, en lugar de sobre la rama original.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The `send-pack` process runs on the client and connects to a `receive-pack` process on the remote side.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T131839Z" changeid="juan">
        <seg>El proceso `send-pack`  corre en el cliente y conecta con el proceso `receive-pack` corriendo en el lado remoto. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You then fetch from that server, bringing down the new commits.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tu te traes (fetch) esos nuevos cambios desde el servidor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Many Git developers have a workflow that embraces this approach, such as having only code that is entirely stable in their `master` branch — possibly only code that has been or will be released.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Muchos desarrolladores que usan Git llevan un flujo de trabajo de esta naturaleza, manteniendo en la rama 'master' únicamente el código totalmente estable (el código que ha sido o que va a ser liberado).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The `master^{tree}` syntax specifies the tree object that is pointed to by the last commit on your `master` branch.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110801T121247Z" changeid="juan">
        <seg>La sentencia `master^{tree}` indica el objeto árbol apuntado por la última confirmación de cambios (commit) en tu rama principal (master).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The line should look something like this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Quedará una linea algo así como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To get the appropriate SHA for a given reference, Git checks for that reference in the `refs` directory and then checks the `packed-refs` file as a fallback.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T092848Z" changeid="juan">
        <seg>Para obtener la clave SHA correspondiente a una determinada referencia, Git comprobará primero en la carpeta `refs` y luego en el archivo `packed-refs`. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg># On branch master
	# Changes to be committed:
	#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)
	#
	# modified:   lib/test.rb
	#
	~
	~
	&quot;.git/COMMIT_EDITMSG&quot; 14L, 297C</seg>
      </tuv>
      <tuv lang="ES">
        <seg># On branch master
	# Changes to be committed:
	#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)
	#
	# modified:   lib/test.rb
	#
	~
	~
	&quot;.git/COMMIT_EDITMSG&quot; 14L, 297C</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ ln -s /opt/git /home/git/repositories</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ ln -s /opt/git /home/git/repositories</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When you have resolved this problem run &quot;git am --resolved&quot;.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>When you have resolved this problem run &quot;git am --resolved&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The first four hooks have to do with the committing process.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Los primeros cuatro puntos de enganche están relacionados con el proceso de confirmación de cambios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This hook generally isn’t useful for normal commits; rather, it’s good for commits where the default message is auto-generated, such as templated commit messages, merge commits, squashed commits, and amended commits.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Este punto de enganche no tiene mucha utilidad para las confirmaciones de cambios normales; pero sí para las confirmaciones donde el mensaje por defecto es autogenerado, como en las confirmaciones de fusiones (merge), los mensajes con plantilla, las confirmaciones aplastadas (squash), o las confirmaciones de correccion (amend).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When you save and exit the editor, Git rewinds your branch to the parent of these commits, applies `310154e` and then `f7f3f6d`, and then stops.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120728T091130Z" changeid="juan">
        <seg>Cuando se guarde y salga en el editor, Git rebobinará la rama hasta el padre de las confirmaciones de cambio indicadas, reaplicará `310154e` y luego `f7f3f6d`, para finalmente detenerse.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The `--tree-filter` option runs the specified command after each checkout of the project and then recommits the results.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T174508Z" changeid="juan">
        <seg>Esta opción `--tree-filter`, tras cada extracción (checkout) del proyecto, lanzará el comando especificado y reconfirmará los cambios resultantes(recommit).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To see an up-to-date list, check out the GitHosting page on the main Git wiki:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para obtener una lista actualizada, puedes mirar en la página GitHosting del wiki principal de Git:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Project header with a public URL and a private URL.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cabecera de proyecto, con una URL pública y otra URL privada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Here is an example, where I’ve replaced a red terminal color with `X`s:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Aquí van algunos ejemplos, en los que hemos sustituido las marcas rojas por 'X's:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Before a topic branch merge.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Antes de fusionar una rama puntual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Summary ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Recapitulación ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It sends all the objects it already has with &quot;have&quot; and then the SHA.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T085819Z" changeid="juan">
        <seg>Los objetos que ya tiene, los envia con &quot;have&quot; (tengo) y la correspondiente clave SHA.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ ls
	HEAD
	branches/
	config
	description
	hooks/
	index
	info/
	objects/
	refs/</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T180445Z" changeid="juan">
        <seg>$ ls
	HEAD
	branches/
	config
	description
	hooks/
	index
	info/
	objects/
	refs/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You must pass it the `--add` option because the file doesn’t yet exist in your staging area (you don’t even have a staging area set up yet) and `--cacheinfo` because the file you’re adding isn’t in your directory but is in your database.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T144228Z" changeid="juan">
        <seg>Has de utilizar la opción `--add`, porque el archivo no existe aún en tu área de preparación (es más, ni siquiera tienes un área de preparación). Y has de utilizar también la opción `--cacheinfo`, porque el archivo que estas añadiendo no está en tu carpeta, sino en tu base de datos. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Click the &quot;edit&quot; button in the project header or the Admin tab at the top of the project to reach the Admin page of your GitHub project (see Figure 4-10).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Has de hacer clic sobre el botón &quot;edit&quot; en la cabecera del proyecto o en la pestaña Admin de la parte superior del proyecto; yendo así a la página de administración del proyecto GitHub.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>-&lt;div id=&quot;footer&quot;&gt;contact : support@github.com&lt;/div&gt;
	+&lt;div id=&quot;footer&quot;&gt;contact : email.support@github.com&lt;/div&gt;</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T213314Z" changeid="juan">
        <seg>-&lt;div id=&quot;footer&quot;&gt;contact : support@github.com&lt;/div&gt;
	+&lt;div id=&quot;footer&quot;&gt;contact : email.support@github.com&lt;/div&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You need to push your work up to it.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tu trabajo lo enviarás (push) a este segundo remoto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>I’ll go over all these plumbing commands in detail in Chapter 9; but for now, here’s what that command gives you:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En el capítulo 9 volveremos en detalle sobre estos comandos de mantenimiento; pero, por ahora, esto es lo que obtienes con dicho comando:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can recover it the same way, by adding a branch that points to that SHA.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T144328Z" changeid="juan">
        <seg>Y la puedes recuperar del mismo modo, añadiendo una rama que apunte a esa clave SHA.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Next, try to make each commit a logically separate changeset.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En segundo lugar, intentar hacer de cada confirmación (commit) un grupo lógico e independiente de cambios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>you put this script:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>un script tal como: </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Writing objects: 100% (17/17), done.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110810T231549Z" changeid="juan">
        <seg>Writing objects: 100% (17/17), done.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Throughout this book, you’ve used simple mappings from remote branches to local references; but they can be more complex.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110815T215301Z" changeid="juan">
        <seg>A lo largo del libro has utilizado sencillos mapeados entre ramas remotas y referencias locales; pero las cosas pueden ser bastante más complejas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can see GitWeb in use at sites like `http://git.kernel.org` (see Figure 4-1).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes ver a GitWeb en acción en sitios como `http://git.kernel.org` (ver figura 4-1)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ echo 'test content' | git hash-object -w --stdin
	d670460b4b4aece5915caf5c68d12f560a9fe3e4</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ echo 'test content' | git hash-object -w --stdin
	d670460b4b4aece5915caf5c68d12f560a9fe3e4</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It’s also possible to take a series of commits and squash them down into a single commit with the interactive rebasing tool.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T185831Z" changeid="juan">
        <seg>Con la herramienta de reorganización interactiva, es posible recombinar una serie de confirmaciones de cambio y agruparlas todas en una sola.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Rewrite 6df764092f3e7c8f5f94cbe08ee5cf42e92a0289 (1/2)rm 'git.tbz2'
	Rewrite da3f30d019005479c99eb4c3406225613985a1db (2/2)
	Ref 'refs/heads/master' was rewritten</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T110442Z" changeid="juan">
        <seg>Rewrite 6df764092f3e7c8f5f94cbe08ee5cf42e92a0289 (1/2)rm 'git.tbz2'
	Rewrite da3f30d019005479c99eb4c3406225613985a1db (2/2)
	Ref 'refs/heads/master' was rewritten</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To get the raw commit data, you can use another plumbing command called `git cat-file`.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para obtener los datos &quot;en crudo&quot;  de una confirmación de cambios, puedes utilizar otro comando de mantenimiento de Git denominado 'git cat-file'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>pick f7f3f6d changed my name a bit
	squash 310154e updated README formatting and added blame
	squash a5f4a0d added cat-file</seg>
      </tuv>
      <tuv lang="ES" changedate="20120728T091849Z" changeid="juan">
        <seg>pick f7f3f6d changed my name a bit
	squash 310154e updated README formatting and added blame
	squash a5f4a0d added cat-file</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>git://githost/simplegit.git featureA</seg>
      </tuv>
      <tuv lang="ES">
        <seg>git://githost/simplegit.git featureA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Many groups switch to Git because of this ability to have multiple teams working in parallel, merging the different lines of work late in the process.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Muchos grupos se están pasando a trabajar con Git, debido a su habilidad para mantener multiples equipos trabajando en paralelo, fusionando posteriormente las diferentes líneas de trabajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In addition to the client-side hooks, you can use a couple of important server-side hooks as a system administrator to enforce nearly any kind of policy for your project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Aparte de los puntos del lado cliente, como administrador de sistemas, puedes utilizar un par de puntos de enganche importantes en el lado servidor; para implementar prácticamente cualquier tipo de política que quieras mantener en tu proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For example, you can start a branch named `recover-branch` at that commit (ab1afef):</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T143511Z" changeid="juan">
        <seg>Por ejemplo, puedes iniciar una rama llamada `recover-branch` con dicha confirmación de cambios (ab1afef):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## Debugging with Git ##</seg>
      </tuv>
      <tuv lang="ES" changedate="20120827T142926Z" changeid="juan">
        <seg>## Depuración con Git ##</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Result: OK</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Result: OK</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>[group mobile]
	writable = iphone_project
	members = scott josie jessica</seg>
      </tuv>
      <tuv lang="ES">
        <seg>[group mobile]
	writable = iphone_project
	members = scott josie jessica</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>All you have to do is check out the branch you wish to merge into and then run the `git merge` command:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Simplemente, activando (checkout) la rama donde deseas fusionar y lanzando el comando 'git merge':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Remote references differ from branches (`refs/heads` references) mainly in that they can’t be checked out.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T113123Z" changeid="juan">
        <seg>Las referencias remotas son distintas de las ramas normales, (referencias en `refs/heads`); y no se pueden recuperar (checkout) al espacio de trabajo. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>These three main Git objects — the blob, the tree, and the commit — are initially stored as separate files in your `.git/objects` directory.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110807T153415Z" changeid="juan">
        <seg>Estos tres objetos Git, -binario, árbol y confirmación de cambios--, se guardan como archivos separados en la carpeta `.git/objects`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To see the diff of what you’ve staged, you can use the `6` or `d` (for diff) command.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T092505Z" changeid="juan">
        <seg>Para ver las diferencis entre lo que está preparado, se puede utilizar la opción '6' o 'd' (diff).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can create an account, add a new project, and push to it in a matter of minutes.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes crear una cuenta, añadir un nuevo proyecto y contribuir a él en cuestión de minutos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Topic Branches ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Ramas puntuales ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git bisect start
	$ git bisect bad
	$ git bisect good v1.0
	Bisecting: 6 revisions left to test after this
	[ecb6e1bc347ccecc5f9350d878ce677feb13d3b2] error handling on repo</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T071643Z" changeid="juan">
        <seg>$ git bisect start
	$ git bisect bad
	$ git bisect good v1.0
	Bisecting: 6 revisions left to test after this
	[ecb6e1bc347ccecc5f9350d878ce677feb13d3b2] error handling on repo</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git tag -s v1.5 -m 'my signed 1.5 tag'
	You need a passphrase to unlock the secret key for
	user: &quot;Scott Chacon &lt;schacon@gmail.com&gt;&quot;
	1024-bit DSA key, ID F721C45A, created 2009-02-09</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git tag -s v1.5 -m 'my signed 1.5 tag'
	You need a passphrase to unlock the secret key for
	user: &quot;Scott Chacon &lt;schacon@gmail.com&gt;&quot;
	1024-bit DSA key, ID F721C45A, created 2009-02-09</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>After you run a successful `git checkout`, the `post-checkout` hook runs; you can use it to set up your working directory properly for your project environment.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tras completarse la ejecución de un comando 'git checkout', es cuando se activa el punto de enganche 'post-checkout. Lo puedes utilizar para ajustar tu carpeta de trabajo al entorno de tu proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You’re looking for a pair of files named something and something.pub, where the something is usually `id_dsa` or `id_rsa`.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Has de buscar un par de archivos con nombres tales como 'algo' y 'algo.pub'; siendo ese &quot;algo&quot; normalmente 'id_dsa' o 'id_rsa'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0310.png
Figure 3-10.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0310.png
Figura 3-10.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git clone http://github.com/schacon/simplegit-progit.git</seg>
      </tuv>
      <tuv lang="ES" changedate="20110817T155517Z" changeid="juan">
        <seg>$ git clone http://github.com/schacon/simplegit-progit.git</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>HEAD@{0}: commit: fixed refs handling, added gc auto, updated
	d921970...</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T102020Z" changeid="juan">
        <seg>HEAD@{0}: commit: fixed refs handling, added gc auto, updated
	d921970...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The next time one of your collaborators fetches from the server, they will get a reference to where the server’s version of `serverfix` is under the remote branch `origin/serverfix`:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La próxima vez que tus colaboradores recuperen desde el servidor, obtendrán una referencia a donde la versión de 'serverfix' en el servidor esté bajo la rama remota 'origin/serverfix':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>At this point, you can determine what you’d like to do with it.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tienes que decidir lo que deseas hacer con él.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### The HEAD ###</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T191903Z" changeid="juan">
        <seg>### La CABEZA (HEAD) ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>How many users are actively contributing code to this project, and how often?</seg>
      </tuv>
      <tuv lang="ES">
        <seg>¿Cuántos usuarios están enviando activamente código a este proyecto?, y ¿con qué frecuencia?.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Because the refspec is `&lt;src&gt;:&lt;dst&gt;`, by leaving off the `&lt;src&gt;` part, this basically says to make the topic branch on the remote nothing, which deletes it.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110817T154718Z" changeid="juan">
        <seg>Se elimina la rama 'topic' del servidor remoto, ya que la sustituimos or nada. (Al ser la referencia `&lt;origen&gt;:&lt;destino&gt;`, si no indicamos la parte  `&lt;origen&gt;`, realmente estamos diciendo que enviamos 'nada' a `&lt;destino&gt;`.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>What is cool is that although the objects on disk before you ran the `gc` were collectively about 12K in size, the new packfile is only 6K.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110815T212157Z" changeid="juan">
        <seg>Lo que es interesante es el hecho de que, aunque los objetos originales presentes en el disco antes del `gc` ocupaban unos 12 Kbytes, el nuevo archivo empaquetador apenas ocupa 6 Kbytes. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can run tests or otherwise inspect the working tree with this script.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Con este script, puedes lanzar pruebas o similares para chequear el arbol de trabajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This option isn’t on by default because it doesn’t work if the commit the patch says it was based on isn’t in your repository.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esta opción no se usa por defecto, porque no funcionará en caso de que la confirmación de cambios en que el parche dice estar basado no esté presente en tu repositorio. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can have Git tell you the object type of any object in Git, given its SHA-1 key, with `cat-file -t`:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T143710Z" changeid="juan">
        <seg>Con la orden 'cat-file -t' puedes comprobar el tipo de cualquier objeto almacenado en Git, sin mas que indicar su clave SHA-1':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Adding a collaborator to your project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Añadirendo un colaborador a tu proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Suppose you look at the history of your project:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T191447Z" changeid="juan">
        <seg>Suponiendo que sea esta la historia de un proyecto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Aunpack ok</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T074914Z" changeid="juan">
        <seg>Aunpack ok</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Someone accidentally commits a huge binary file with a thoughtless `git add .`, and you want to remove it everywhere.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T173333Z" changeid="juan">
        <seg>Alguien confirma cambios y almacena accidentalmente un enorme archivo binario cuando lanza un `git add .` sin pensarlo demasiado. Y es necesario quitarlo del repositorio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>There are also more interesting ways to do this on a per-user basis via ACLs, as you’ll learn at the end of this chapter.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Existen también algunas otras maneras más interesantes de hacer esto mismo, pero para usuarios concretos, a través de permisos (ACLs); tal y como veremos al final de este capítulo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>git rebase --continue</seg>
      </tuv>
      <tuv lang="ES" changedate="20120728T085930Z" changeid="juan">
        <seg>git rebase --continue</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The negative aspect of SSH is that you can’t serve anonymous access of your repository over it.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El aspecto negativo de SSH es su imposibilidad para dar acceso anónimo al repositorio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>That’s it — you’ve created a valid Git blob object.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T201017Z" changeid="juan">
        <seg>Y ¡esto es todo!. --acabas de crear un auténtico objeto Git binario grande (blob)--.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You need to find the latest commit SHA and then add a branch that points to it.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T142231Z" changeid="juan">
        <seg>Necesitas localizar el SHA de la última confirmación de cambios y luego añadir una rama que apunte hacia ella.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Example history before a cherry pick.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Historial de ejemplo, antes de entresacar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Your file contains a section that looks something like this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El archivo conflictivo contendrá algo como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0509.png
Figure 5-9.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0509.png
Figura 5-9.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The packed repository size is down to 7K, which is much better than 2MB.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T134754Z" changeid="juan">
        <seg>El tamaño del repositorio ahora es de 7 KB, mucho mejor que los 2 MB anteriores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you have no interest in running your own server, you can skip to the last section of the chapter to see some options for setting up a hosted account and then move on to the next chapter, where we discuss the various ins and outs of working in a distributed source control environment.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si este es el caso, si no tienes interés de tener tu propio servidor, puedes saltar directamente a la última sección del capítulo; donde verás algunas opciones para dar de alta una cuenta albergada. Y después puedes moverte al capítulo siguiente, donde vamos a discutir algunos de los mecanismos para trabajar en un entorno distribuido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>#### export-subst ####</seg>
      </tuv>
      <tuv lang="ES">
        <seg>#### export-subst ####</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git blame -L 12,22 simplegit.rb
	^4832fe2 (Scott Chacon  2008-03-15 10:31:28 -0700 12)  def show(tree = 'master')
	^4832fe2 (Scott Chacon  2008-03-15 10:31:28 -0700 13)   command(&quot;git show #{tree}&quot;)
	^4832fe2 (Scott Chacon  2008-03-15 10:31:28 -0700 14)  end
	^4832fe2 (Scott Chacon  2008-03-15 10:31:28 -0700 15)
	9f6560e4 (Scott Chacon  2008-03-17 21:52:20 -0700 16)  def log(tree = 'master')
	79eaf55d (Scott Chacon  2008-04-06 10:15:08 -0700 17)   command(&quot;git log #{tree}&quot;)
	9f6560e4 (Scott Chacon  2008-03-17 21:52:20 -0700 18)  end
	9f6560e4 (Scott Chacon  2008-03-17 21:52:20 -0700 19)
	42cf2861 (Magnus Chacon 2008-04-13 10:45:01 -0700 20)  def blame(path)
	42cf2861 (Magnus Chacon 2008-04-13 10:45:01 -0700 21)   command(&quot;git blame #{path}&quot;)
	42cf2861 (Magnus Chacon 2008-04-13 10:45:01 -0700 22)  end</seg>
      </tuv>
      <tuv lang="ES" changedate="20120827T143652Z" changeid="juan">
        <seg>$ git blame -L 12,22 simplegit.rb
	^4832fe2 (Scott Chacon  2008-03-15 10:31:28 -0700 12)  def show(tree = 'master')
	^4832fe2 (Scott Chacon  2008-03-15 10:31:28 -0700 13)   command(&quot;git show #{tree}&quot;)
	^4832fe2 (Scott Chacon  2008-03-15 10:31:28 -0700 14)  end
	^4832fe2 (Scott Chacon  2008-03-15 10:31:28 -0700 15)
	9f6560e4 (Scott Chacon  2008-03-17 21:52:20 -0700 16)  def log(tree = 'master')
	79eaf55d (Scott Chacon  2008-04-06 10:15:08 -0700 17)   command(&quot;git log #{tree}&quot;)
	9f6560e4 (Scott Chacon  2008-03-17 21:52:20 -0700 18)  end
	9f6560e4 (Scott Chacon  2008-03-17 21:52:20 -0700 19)
	42cf2861 (Magnus Chacon 2008-04-13 10:45:01 -0700 20)  def blame(path)
	42cf2861 (Magnus Chacon 2008-04-13 10:45:01 -0700 21)   command(&quot;git blame #{path}&quot;)
	42cf2861 (Magnus Chacon 2008-04-13 10:45:01 -0700 22)  end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To be clear, Git isn’t tied into any particular issue-tracking system; but because issue #53 is a focused topic that you want to work on, you’ll create a new branch in which to work.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Aunque, por supuesto, Git no está ligado a ningún sistema de seguimiento de problemas concreto. Como el problema #53 es un tema concreto y puntual en el que vas a trabajar, creas una nueva rama para él.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can also initiate the process via the Git daemon, which listens on a server on port 9418 by default.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T075444Z" changeid="juan">
        <seg>O se puede arrancar a traves del demonio Git, que suele estar escuchando por el puerto 9418.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To apply a patch generated by `format-patch`, you use `git am`.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para incorporar un parche generado con 'format-patch', utilizarás el comando 'git am'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It keeps a special pointer called HEAD.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Pues...., mediante un apuntador especial denominado HEAD.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git stores content in a manner similar to a UNIX filesystem, but a bit simplified.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110801T120351Z" changeid="juan">
        <seg>Git guarda contenido de manera similar a un sistema de archivos UNIX, pero de forma algo más simple.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>A list of collaborators on your project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Lista de colaboradores en tu proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Multiple branches pointing into the commit’s data history.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Apuntadores de varias ramas en el registro de confirmaciones de cambio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>At this point, the others can clone it down and push changes back up just as easily:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tras lo cual, otros podrán clonarlo y enviar cambios de vuelta:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The third column in the output is the size of the object in the pack, so you can see that `05408` takes up 12K of the file but that `9bc1d` only takes up 7 bytes.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110815T212945Z" changeid="juan">
        <seg>La tercera columna refleja el tamaño de cada objeto dentro del paquete. Observandose que `05408` ocupa unos 12 Kbytes; pero `9bc1d` solo ocupa 7 bytes. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0307.png
Figure 3-7.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0307.png
Figura 3-7.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>All the objects in your Git directory.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110807T153626Z" changeid="juan">
        <seg>Todos los objetos en tu carpeta Git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git fetch origin master:refs/remotes/origin/mymaster \
	   topic:refs/remotes/origin/topic
	From git@github.com:schacon/simplegit
	 !</seg>
      </tuv>
      <tuv lang="ES" changedate="20110815T221000Z" changeid="juan">
        <seg>$ git fetch origin master:refs/remotes/origin/mymaster \
	   topic:refs/remotes/origin/topic
	From git@github.com:schacon/simplegit
	 !</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>As an extra precaution, you can easily restrict the 'git' user to only doing Git activities with a limited shell tool called `git-shell` that comes with Git.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para una mayor protección, puedes restringir facilmente el usuario 'git' a realizar solamente actividades relacionadas con Git. Utilizando un shell limitado llamado 'git-shell', que viene incluido en Git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For instance, if a documentation author tries to push a commit modifying something in the `lib` directory, they see</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por ejemplo, si un editor técnico intenta enviar una confirmación de cambios donde se haya modificado algo de la carpeta 'lib', verá:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>From now on, as long as that `update` script is there and executable, your repository will never be rewound and will never have a commit message without your pattern in it, and your users will be sandboxed.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>De ahora en adelante, en tanto en cuando el script 'update' este presente y sea ejecutable, tu repositorio nunca se verá perjudicado, nunca tendrá un mensaje de confirmación de cambios sin tu plantilla y tus usuarios estarán controlados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>First, you see this where the hook starts running.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Lo primero observado cuando el enganche (hook) arranca es:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ find .git/objects -type f
	.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a
	.git/objects/83/baae61804e65cc73a7201a7252750c76066a30
	.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ find .git/objects -type f
	.git/objects/1f/7a7a472abf3dd9643fd615f6da379c4acb3e3a
	.git/objects/83/baae61804e65cc73a7201a7252750c76066a30
	.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You created and switched to a branch, did some work on it, and then switched back to your main branch and did other work.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Has creado una rama y saltado a ella, has trabajado sobre ella; has vuelto a la rama original, y has trabajado también sobre ella.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git checkout -b serverfix origin/serverfix
	Branch serverfix set up to track remote branch refs/remotes/origin/serverfix.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git checkout -b serverfix origin/serverfix
	Branch serverfix set up to track remote branch refs/remotes/origin/serverfix.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To visualize this, let’s assume that you have a directory containing three files, and you stage them all and commit.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para ilustrar esto, vamos a suponer, por ejemplo, que tienes una carpeta con tres archivos, que preparas (stage) todos ellos y los confirmas (commit).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg># only allows certain users to modify certain subdirectories in a project
	def check_directory_perms
	  access = get_acl_access_data('.git/acl')</seg>
      </tuv>
      <tuv lang="ES">
        <seg># only allows certain users to modify certain subdirectories in a project
	def check_directory_perms
	  access = get_acl_access_data('.git/acl')</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Cuando hablamos de ramificaciones, significa que tu has tomado la rama principal de desarrollo (master) y a partir de ahí has continuado trabajando sin seguir la rama principal de desarrollo.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cuando hablamos de ramificaciones, significa que tu has tomado la rama principal de desarrollo (master) y a partir de ahí has continuado trabajando sin seguir la rama principal de desarrollo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>000</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T074912Z" changeid="juan">
        <seg>000</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When you run `git archive`, the contents of that file when people open the archive file will look like this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cuando lances la orden 'git archive', lo que la gente verá en ese archivo cuando lo abra será:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If your `master` branch has moved forward since you created the topic branch from it, then you’ll get seemingly strange results.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si tu rama 'master' ha avanzado con respecto al momento en que se creó la rama puntual a partir de ella, puedes obtener resultados realmente extraños.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git log --pretty=format:&quot;%h %s&quot; HEAD~3..HEAD
	a5f4a0d added cat-file
	310154e updated README formatting and added blame
	f7f3f6d changed my name a bit</seg>
      </tuv>
      <tuv lang="ES" changedate="20120728T084712Z" changeid="juan">
        <seg>$ git log --pretty=format:&quot;%h %s&quot; HEAD~3..HEAD
	a5f4a0d added cat-file
	310154e updated README formatting and added blame
	f7f3f6d changed my name a bit</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you track down a bug in your code and want to know when it was introduced and why, file annotation is often your best tool.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T164852Z" changeid="juan">
        <seg>Cuando se está rastreando un error dentro del código buscando localizar cuándo se introdujo y por qué, el mejor auxiliar para hacerlo es la anotación de archivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When you design these filters, they should be able to fail gracefully and have the project still work properly.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cuando diseñes este tipo de filtros, han de estar pensados para que el proyecto continue funcionando correctamente incluso cuando fallen.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>That is all a lightweight tag is — a branch that never moves.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T112439Z" changeid="juan">
        <seg>Una etiqueta ligera es simplemente eso: una rama que nunca se mueve.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When you have work in a topic branch that you’ve done or that someone has contributed and you’ve verified, you merge it into your master branch, delete the topic branch, and then continue the process.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cuando en una rama puntual tienes trabajo ya terminado o contribuciones ya verificadas de terceros, los fusionas en tu rama 'master', borras la rama puntual, y continuas trabajando en otra/s rama/s.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can do this by listing them with the `bisect start` command if you want, listing the known bad commit first and the known good commit second:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T073503Z" changeid="juan">
        <seg>Se puede hacer en un solo paso. Indicando ambas confirmaciones de cambios al comando `bisect start`, primero la mala y luego la buena:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For instance, some text files may be machine generated and not diffable, whereas some binary files can be diffed — you’ll see how to tell Git which is which.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por ejemplo, algunos archivos de texto se generan automáticamente y no tiene sentido compararlos; mientras que algunos archivos binarios sí que pueden ser comparados --vamos a ver cómo indicar a Git cual es cual--.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can also not specify a user, and Git assumes the user you’re currently logged in as.</seg>
      </tuv>
      <tuv lang="ES">
        <seg> Pudiendo asimismo prescindir del usuario; en cuyo caso Git asume el usuario con el que estés conectado en ese momento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git merge issue54
	Updating fbff5bc..4af4298
	Fast forward
	 README           |    1 +
	 lib/simplegit.rb |    6 +++++-
	 2 files changed, 6 insertions(+), 1 deletions(-)</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git merge issue54
	Updating fbff5bc..4af4298
	Fast forward
	 README           |    1 +
	 lib/simplegit.rb |    6 +++++-
	 2 files changed, 6 insertions(+), 1 deletions(-)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Do some work in that branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Realizas algo de trabajo en esa rama.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It shows you that a couple of lines are staged and a couple are unstaged.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T214629Z" changeid="juan">
        <seg>Muestra que un par de líneas han sido preparadas (staged) en el área de preparación y otro par han sido dejadas fuera de dicho área (unstaged).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>One of the great things about Git is that it allows you to make decisions at the last possible moment.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120728T075616Z" changeid="juan">
        <seg>Una de las grandes caracteristicas de Git es su capacidad de postponer las decisiones hasta el último momento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Then, they commit a pointer to that non-public state and push up the superproject.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T171918Z" changeid="juan">
        <seg>Pero, sin embargo, sí que confirma (commit) y envia (push) un puntero a dicho estado dentro del proyecto padre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You run your test again and find that this commit is broken, so you tell Git that with `git bisect bad`:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T075152Z" changeid="juan">
        <seg>De nuevo, se pueden lanzar las pruebas para ver si el problema existe o no en ese punto. Si, por ejemplo, si existiera se indicaría ese hecho a Git tecleando `git bisect bad`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>They’re all equivalent, because Git expands each of them to `refs/remotes/origin/master`.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T115249Z" changeid="juan">
        <seg>Todas estas sentencias son equivalentes, ya que Git expande cada una de ellas a `refs/remotes/origin/master`. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Often, when you’ve been working on part of your project, things are in a messy state and you want to switch branches for a bit to work on something else.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120712T202311Z" changeid="juan">
        <seg>Según se está trabajando en un apartado de un proyecto, normalmente el espacio de trabajo suele estar en un estado inconsistente. Pero puede que se necesite cambiar de rama durante un breve tiempo para ponerse a trabajar en algún otro tema urgente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you want to apply one of the older stashes, you can specify it by naming it, like this: `git stash apply stash@{2}`.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120702T085911Z" changeid="juan">
        <seg>Si lo que se desea es reaplicar alguno de los grupos más antiguos de cambios, se ha de indicar expresamente: `git stash apply stash@{2}`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This workflow is attractive to a lot of people because it’s a paradigm that many are familiar and comfortable with.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esta forma de trabajar es atractiva para mucha gente, por ser el paradigma con el que están familiarizados y se sienten confortables.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To give another user write access to your project, click the “Add another collaborator” link.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para dar acceso de escritura a otro usuario, clica sobre el enlace &quot;Add another collaborator&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Let’s see how much space you saved.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T135431Z" changeid="juan">
        <seg>Y ahora, vamos a ver cuanto espacio hemos ahorrado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The `gitosis.conf` file is the control file you use to specify users, repositories, and permissions.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El archivo 'gitosis.conf' es el archivo de control que usarás para especificar usuarios, repositorios y permisos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To demonstrate, you’ll go into your project and start working on a couple of files and possibly stage one of the changes.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120712T202528Z" changeid="juan">
        <seg>Por ejemplo, si se está trabajando sobre un par de archivos e incluso uno de ellos está ya añadido al área de preparación para un futuro almacenamiento de sus cambios en el repositorio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Pushing Refspecs ###</seg>
      </tuv>
      <tuv lang="ES" changedate="20110817T153434Z" changeid="juan">
        <seg>### Enviando (push) referencias ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0503.png
Figure 5-3.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0503.png
Figura 5-3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>She can merge either `origin/master` or `issue54` first — they’re both upstream, so the order doesn’t matter.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puede fusionar primero tanto 'origin/master' o como 'issue54', ya que ambos están aguas arriba.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You have to merge that work in at some point so you can keep up with the other developer in the future.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Te ves obligado a fusionar (merge) ese trabajo en algún punto, para poder seguir adelante con otros desarrollos en el futuro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ cat /usr/local/bin/extMerge
	#!/bin/sh
	/Applications/p4merge.app/Contents/MacOS/p4merge $*</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ cat /usr/local/bin/extMerge
	#!/bin/sh
	/Applications/p4merge.app/Contents/MacOS/p4merge $*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is how Git stores the content initially — as a single file per piece of content, named with the SHA-1 checksum of the content and its header.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T143151Z" changeid="juan">
        <seg>En principio, esta es la forma en que guarda Git los contenidos; como un archivo por cada pieza de contenido, nombrado con la suma de comprobación SHA-1 del contenido y su cabecera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>A single tree object contains one or more tree entries, each of which contains a SHA-1 pointer to a blob or subtree with its associated mode, type, and filename.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T193731Z" changeid="juan">
        <seg>Un objeto tipo árbol tiene una o más entradas de tipo arbol. Y cada una de ellas consta de un puntero SHA-1 a un objeto binario (blob) o a un subárbol, más sus correspondientes datos de modo, tipo y nombre de archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You have to move the `rack` submodule directory out of the way before you can switch to a branch that doesn’t have it:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T140118Z" changeid="juan">
        <seg>Antes de cambiar a cualquier rama que no lo contenga, es necesario quitar de enmedio la carpeta del submódulo 'rack'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It contains tabs to different aspects of your projects.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tiene pestañas que llevan a distintos aspectos del proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>*.c     filter=indent</seg>
      </tuv>
      <tuv lang="ES">
        <seg>*.c     filter=indent</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git config --global core.editor emacs</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git config --global core.editor emacs</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Each of the three commit objects points to one of the three snapshot trees you created.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T200026Z" changeid="juan">
        <seg>Cada uno de estos tres objetos de confirmación de cambios apunta a uno de los tres objetos tipo árbol que habias creado previamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Simply set up a single repository, and give everyone on your team push access; Git won’t let users overwrite each other.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Solo necesitas disponer un repositorio único, y dar acceso en envio (push) a todo tu equipo. Git se encargará de evitar el que se sobreescriban unos a otros.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now your users can’t push any commits with badly formed messages or with modified files outside of their designated paths.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Una vez implementado todo esto, tus usuarios no podrán enviar confirmaciones de cambios con mensajes mal formados o con modificaciones sobre archivos fuera de las ubicaciones que les hayas designado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You solve this issue much the same way — edit the file to resolve the conflict, stage the new file, and then run `git am --resolved` to continue to the next patch:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y resolverás los problemas de la misma manera: editar el archivo para resolver los conflictos, prepararlo (stage), y lanzar 'git am --resolved' para continuar con el siguiente parche:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>SSH is also the only network-based protocol that you can easily read from and write to.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por otro lado, SSH es el único protocolo de red con el que puedes facilmente tanto leer como escribir.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Because your starting point is the `ca82a6` commit object you saw in the `info/refs` file, you start by fetching that:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T130729Z" changeid="juan">
        <seg>En el archivo `info/refs` se ve que el punto de partida es la confirmación de cambios (commit) `ca82a6`, y, por tanto, comenzaremos recuperandola: </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To allow read access to your repository over HTTP, do something like this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para permitir acceso a tu repositorio a través de HTTP, puedes hacer algo como esto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You have to see who last changed the submodule:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T172031Z" changeid="juan">
        <seg>Forzandonos a mirar quién ha sido la persona que ha realizado los últimos cambios en el submódulo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Your branch will contain only work from that commit down:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T191454Z" changeid="juan">
        <seg>Y la rama contendrá únicamente trabajo desde esa confirmación de cambios hacia atrás.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Oddly enough, you have a real Git history now that you can view with the `git log` command, if you run it on the last commit SHA-1:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T145355Z" changeid="juan">
        <seg>Más aún, en estos momentos tienes ya un verdadero historial Git. Lo puedes comprobar con el comando `git log`. Lanzandolo mientras estás en la última de las confirmaciones de cambio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The `size-pack` entry is the size of your packfiles in kilobytes, so you’re using 2MB.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T134818Z" changeid="juan">
        <seg>El valor de  `size-pack` nos da el tamaño de tus archivos empaquetadores, en kilobytes, y, por lo que se ve, estás usando 2 MB. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now your history looks like Figure 5-27.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tu historial quedará tal como ilustra la Figura 5-27.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The next sections will explain some typical setups using those protocols and how to get your server running with them.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Las siguientes secciones explicarán algunas de las típicas configuraciones utilizando esos protocolos, y cómo podemos poner en marcha nuestro servidor con ellos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The core.pager setting determines what pager is used when Git pages output such as `log` and `diff`.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El parámetro core.pager selecciona el paginador utilizado por Git cuando muestra resultados de comandos tales como 'log' o 'diff'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The upside of using the HTTP protocol is that it’s easy to set up.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La mejor parte del protocolo HTTP es su sencillez de preparación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>She can then fetch Josie’s changes down with `git fetch`:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por tanto, recupera (fetch) los cambios de Josie: </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Starting with Submodules ###</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T102943Z" changeid="juan">
        <seg>### Trabajando con submódulos ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>But because Git was initially a toolkit for a VCS rather than a full user-friendly VCS, it has a bunch of verbs that do low-level work and were designed to be chained together UNIX style or called from scripts.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Pero, debido al origen de Git como una caja de herramientas para un VCS en lugar de como un completo y amigable sistema VCS, existen unos cuantos verbos para realizar tareas de bajo nivel y que se diseñaron para poder ser utilizados de forma encadenada al estilo UNIX o para ser utilizados en scripts.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You want to pull the Rack project into your `master` project as a subdirectory.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T142251Z" changeid="juan">
        <seg>Si se desea situar el proyecto Rack como una subcarpeta del proyecto `master`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you tell the script that it was, it stages the file to mark it as resolved for you.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si le indicas que así ha sido, Git marca como preparado (staged) el archivo que acabamos de modificar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>/etc/event.d/local-git-daemon</seg>
      </tuv>
      <tuv lang="ES">
        <seg>/etc/event.d/local-git-daemon</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Then, open the file with `File.open()` and write out the previously zlib-compressed content to the file with a `write()` call on the resulting file handle:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T200903Z" changeid="juan">
        <seg>Después, puedes abrir un archivo con la orden `File.open()` y escribir contenido en él con la orden `write()`:  </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git diff --check
	lib/simplegit.rb:5: trailing whitespace.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git diff --check
	lib/simplegit.rb:5: trailing whitespace.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>After you push your project up or have it imported from Subversion, you have a main project page that looks something like Figure 4-13.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Una vez hayas enviado (push) tu proyecto, o lo hayas importado desde Subversion, tendrás una página principal de proyecto tal como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>They’re all invoked by the `git am` command, so if you aren’t using that command in your workflow, you can safely skip to the next section.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Todos ellos se invocan al utilizar el comando 'git am', por lo que si no utilizas dicho comando, puedes saltar directamente a la siguiente sección.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ echo '# $Date$' &gt; date_test.txt
	$ echo 'date*.txt filter=dater' &gt;&gt; .gitattributes</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ echo '# $Date$' &gt; date_test.txt
	$ echo 'date*.txt filter=dater' &gt;&gt; .gitattributes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Because we can’t cover all of them, and because I happen to work at one of them, we’ll use this section to walk through setting up an account and creating a new project at GitHub.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por ser imposible el cubrir todos ellos, y porque da la casualidad de que trabajo en uno de ellos, concretamente, en esta sección veremos cómo crear una cuenta y nuevos proyectos albergados en 'GitHub'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Your database contains the two new versions of the file as well as the first content you stored there:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tu base de datos contendrá las dos nuevas versiones del archivo, así como el primer contenido que habias guardado en ella antes:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0411.png
Figure 4-11.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0411.png
Figura 4-11.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>But instead of appending them manually to the `~/.ssh/authorized_keys` file on your server, you’ll add them, one key per file, into the `keydir` directory.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Pero en lugar de hacerlo manualmente sobre el archivo `~/.ssh/authorized_keys` de tu servidor, has de hacerlo --un archivo por clave-- en la carpeta 'keydir' del proyecto de control.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg># This is the 3rd commit message:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120728T092014Z" changeid="juan">
        <seg># This is the 3rd commit message:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It takes the patch that was introduced in a commit and tries to reapply it on the branch you’re currently on.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Se trata de coger el parche introducido por una determinada confirmación de cambios e intentar reaplicarlo sobre la rama donde te encuentres en ese momento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can use this hook to do things like make sure none of the updated references are non-fast-forwards; or to check that the user doing the pushing has create, delete, or push access or access to push updates to all the files they’re modifying with the push.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes utilizar este punto de enganche para realizar tareas tales como la de comprobar que ninguna de las referencias actualizadas no son de avance directo (non-fast-forward); o para comprobar que el usuario que realiza el envio tiene realmente permisos para para crear, borrar o modificar cualquiera de los archivos que está tratando de cambiar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The next issue is your commit access.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La tercera variable es el nivel de acceso que tengas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The script puts helpful instructions in the rebase message:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T185940Z" changeid="juan">
        <seg>El propio script indica las instrucciones a seguir:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## Git Objects ##</seg>
      </tuv>
      <tuv lang="ES">
        <seg>## Los objetos Git ##</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you do happen to commit an object that hashes to the same SHA-1 value as a previous object in your repository, GIt will see the previous object already in your Git database and assume it was already written.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T085439Z" changeid="juan">
        <seg>Si se da la casualidad de confirmar cambios en un objeto y que a este se le asigne el mismo código SHA-1 que otro ya existente en el repositorio. Al ver  el objeto previamente almacenado en la base de datos, Git asumirá que este ya existía.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Notice the last line of the file, which begins with a `^`.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T093017Z" changeid="juan">
        <seg>Merece destacar que la última línea de este archivo comenzaba con  `^`- </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>She runs `git log` to find out:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Lo comprueba con el comando 'git log':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Type</seg>
      </tuv>
      <tuv lang="ES" changedate="20120728T090006Z" changeid="juan">
        <seg>Teclear</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git attribute data also allows you to do some interesting things when exporting an archive of your project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Los atributos de Git permiten realizar algunas cosas interesantes cuando exportas un archivo de tu proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>How can you recover that commit at this point?</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T133746Z" changeid="juan">
        <seg>¿Cómo podriamos ahora recuperar esas confirmaciones de cambio?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git will occasionally repack your database automatically, always trying to save more space.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110815T213745Z" changeid="juan">
        <seg>De vez en cuando, Git, en su empeño por optimizar la ocupación de espacio, reempaqueta automaticamente toda la base de datos</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>By blaming `GITPackUpload.m` with the `-C` option, I could see where sections of the code originally came from:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T065942Z" changeid="juan">
        <seg>Aplicando la opción `-C` de `git blame` sobre `GITPackUpload.m`, es posible ver de donde proviene cada sección del código: </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In this chapter, you’ll see how to work with Git in a distributed environment as a contributor and an integrator.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En este capítulo, verás cómo trabajar con Git en un entorno distribuido, bien como colaborador o bien como integrador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To remove remote branches, you must remove the ref files from the server manually.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para borrar ramas remotas, tendrás que borrar los archivos de referencia manualmente sobre el propio servidor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>With these tools, it’s easy to get Git to work exactly the way you, your company, or your group needs it to.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Con estas operaciones, será facil conseguir que Git trabaje exactamente como tú, tu empresa o tu grupo necesiteis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It’s strange, but it works.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T171800Z" changeid="juan">
        <seg>Es algo extraño, pero ¡funciona!.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git checkout rack_branch
	$ git pull</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T163108Z" changeid="juan">
        <seg>$ git checkout rack_branch
	$ git pull</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Finally, you’ll write your zlib-deflated content to an object on disk.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T181847Z" changeid="juan">
        <seg>Para terminar, has de escribir el contenido comprimido en un objeto en disco.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Generating a Build Number ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Generando un número de ensamblado ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>#### Triple Dot ####</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T202015Z" changeid="juan">
        <seg>#### Triple-punto ####</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The last main caveat that many people run into involves switching from subdirectories to submodules.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T135542Z" changeid="juan">
        <seg>Y una última problemática en que se suelen encontrar quienes intercambian de carpetas a submódulos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>P4Merge.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>P4Merge.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you want to see which specific SHA a branch points to, or if you want to see what any of these examples boils down to in terms of SHAs, you can use a Git plumbing tool called `rev-parse`.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120712T195634Z" changeid="juan">
        <seg>Para ver a qué código SHA apunta una determinada rama, o si se desea conocer cómo se comportarian cualquiera de los ejemplos anteriores en términos de SHAs, se puede emplear el comando de fontaneria 'rev-parse'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>=&gt; GET objects/ca/82a6dff817ec66f44342007202690a93763949
	(179 bytes of binary data)</seg>
      </tuv>
      <tuv lang="ES" changedate="20110817T222433Z" changeid="juan">
        <seg>=&gt; GET objects/ca/82a6dff817ec66f44342007202690a93763949
	(179 bytes of binary data)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can put patterns in your project’s `.gitignore` file to have Git not see them as untracked files or try to stage them when you run `git add` on them, as discussed in Chapter 2.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Se pueden indicar expresiones en el archivo '.gitignore' de tu proyecto para indicar a Git lo que debe considerar o no como archivos sin seguimiento, o lo que interará o no seleccionar cuando lances el comando 'git add', tal y como se indicó en el capítulo 2. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>How you name the keys determines how you refer to the users in the `gitosis.conf` file.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Según pongas los nombres a estos archivos, así tendrás que referirte a los usuarios en el archivo 'gitosis.conf'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In this example, you’d run the following:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por ejemplo, puedes lanzar los comandos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If the contributor is a Git user and was good enough to use the `format-patch` command to generate their patch, then your job is easier because the patch contains author information and a commit message for you.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si la persona que contribuye es usuaria de Git y conoce lo suficiente como para utilizar el comando 'format-patch' al generar su parche, tendrás mucho camino recorrido al incorporarlo; ya que el parche traerá consigo información sobre el o la autora, además de un mensaje de confirmación de cambios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Using submodules isn’t without hiccups, however.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T133115Z" changeid="juan">
        <seg>El uso de submódulos tiene también sus contratiempos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Then, you can fast-forward the base branch (`master`):</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Después, puedes avanzar rápidamente la rama base ('master'):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you make some changes and commit again, the next commit stores a pointer to the commit that came immediately before it.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si haces más cambios y vuelves a confirmar, la siguiente confirmación guardará un apuntador a esta su confirmación precedente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git log --pretty=oneline
	ab1afef80fac8e34258ff41fc1b867c702daa24b modified repo a bit
	484a59275031909e19aadb7c92262719cfcdf19a added repo.rb
	1a410efbd13591db07496601ebc7a059dd55cfe9 third commit
	cac0cab538b970a37ea1e769cbbde608743bc96d second commit
	fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T141554Z" changeid="juan">
        <seg>$ git log --pretty=oneline
	ab1afef80fac8e34258ff41fc1b867c702daa24b modified repo a bit
	484a59275031909e19aadb7c92262719cfcdf19a added repo.rb
	1a410efbd13591db07496601ebc7a059dd55cfe9 third commit
	cac0cab538b970a37ea1e769cbbde608743bc96d second commit
	fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you’ve committed whitespace issues but haven’t yet pushed upstream, you can run a `rebase` with the `--whitespace=fix` option to have Git automatically fix whitespace issues as it’s rewriting the patches.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si has confirmado cambios con problemas de espaciado, pero no los has enviado (push) aún &quot;aguas arriba&quot;. Puedes realizar una reorganización (rebase) con la opción '--whitespace=fix' para que Git corrija automáticamente los problemas según va reescribiendo los parches.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>But remembering the SHA-1 key for each version of your file isn’t practical; plus, you aren’t storing the filename in your system — just the content.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T143613Z" changeid="juan">
        <seg>Pero no es práctico esto de andar recordando la clave SHA-1 para cada versión de tu archivo; es más, realmente no estás guardando el nombre de tu archivo en el sistema, --solo su contenido--.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git tag -a maintainer-pgp-pub 659ef797d181633c87ec71ac3f9ba29fe5775b92</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git tag -a maintainer-pgp-pub 659ef797d181633c87ec71ac3f9ba29fe5775b92</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can also have your rebase replay on something other than the rebase branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>También puedes aplicar una reorganización (rebase) sobre otra cosa además de sobre la rama de reorganización.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You’ve seen a number of advanced tools that allow you to manipulate your commits and staging area more precisely.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T173742Z" changeid="juan">
        <seg>Se han visto una serie de herramientas avanzadas que permiten manipular de forma precisa las confirmaciones de cambio y el área de preparación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can easily see that the file size and image dimensions have both changed.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Aquí se vé claramente que ha cambiado el tamaño del archivo y las dimensiones de la imagen.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Your Project ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Tu proyecto ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You still get the advantages of things like offline committing and vastly simpler branching and merging, but the workflow can be very similar; the main difference is that merges happen client-side rather than on the server at commit time.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Sigues disfrutando de ventajas tales como las confirmaciones offline y la mayor simplicidad en las ramificaciones/fusiones. Pero, en el fondo, la forma de trabajar será bastante similar; la mayor diferencia radica en que las fusiones (merge) se hacen en el lado cliente en lugar de en el servidor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can add the following line to your Git attributes file:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes añadir la siguiente línea al archivo de atributos de Git:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git clone git@gitserver:/opt/git/project.git
	$ vim README
	$ git commit -am 'fix for the README file'
	$ git push origin master</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git clone git@gitserver:/opt/git/project.git
	$ vim README
	$ git commit -am 'fix for the README file'
	$ git push origin master</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>HEAD@{5}: rebase -i (squash): updating HEAD
	7e05da5...</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T102034Z" changeid="juan">
        <seg>HEAD@{5}: rebase -i (squash): updating HEAD
	7e05da5...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Because you don’t download the whole history in those systems, this type of addition carries few consequences.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T134407Z" changeid="juan">
        <seg>En esos sistemas, uno no se suele descargar la historia completa. Y, por tanto, los archivos enormes no tienen mayores consecuencias.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>On the ACL file you looked at earlier, this `get_acl_access_data` method returns a data structure that looks like this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si lo aplicamos sobre la lista ACL descrita anteriormente, este método 'get acl access_data' devolverá una estructura de datos similar a esta:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Furthermore, if you push this history back up to the server, you’ll reintroduce all those rebased commits to the central server, which can further confuse people.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Es más, si luego tu envias (push) ese registro de vuelta al servidor, vas a introducir todas esas confirmaciones reorganizadas en el servidor central. Lo que puede confundir aún más a la gente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>HEAD@{4}: commit: # This is a combination of two commits.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T102031Z" changeid="juan">
        <seg>HEAD@{4}: commit: # This is a combination of two commits.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>First, you should check to make sure you don’t already have a key.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Ante todo,  asegurarte que no tengas ya una clave.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It records the snapshots and then tries to figure out what was renamed implicitly, after the fact.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T074153Z" changeid="juan">
        <seg>Git simplemente se limita a almacenar instantáneas (snapshots) de los archivos, para después intentar deducir cuáles han podido ser renombrados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0901.png
Figure 9-1.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110801T121501Z" changeid="juan">
        <seg>Insert 18333fig0901.png
Figura 9-1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>#### receive.denyDeletes ####</seg>
      </tuv>
      <tuv lang="ES">
        <seg>#### receive.denyDeletes ####</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>One common problem happens when a developer makes a change locally in a submodule but doesn’t push it to a public server.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T171849Z" changeid="juan">
        <seg>Un problema típico se suele dar cuando un desarrollador realiza y confirma (commit) un cambio local en el submódulo, pero no lo envia (push) a un servidor público.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>These instructions tell you exactly what to do.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120728T085958Z" changeid="juan">
        <seg>Estas instrucciones indican exactamente lo que se ha de realizar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This lets you clone another repository into your project and keep your commits separate.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T085935Z" changeid="juan">
        <seg>Esto permite clonar un segundo repositorio dentro del repositorio del proyecto en que se está trabajando, manteniendo separadamente las confirmaciones de cambios en ambos repositorios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>These commands aren’t meant to be used manually on the command line, but rather to be used as building blocks for new tools and custom scripts.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110717T112028Z" changeid="juan">
        <seg>Estos comando no están pensados para ser utilizados manualmente desde la línea de comandos; sino más bien para ser utilizados como bloques de construcción para nuevas herramientas y scripts de usuario personalizados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>At this point, you should be able to do most of the day-to-day tasks for which you’ll be using Git.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>A estas alturas, ya podrás realizar la mayor parte de las tareas habituales trabajando con Git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is referred to as a merge commit and is special in that it has more than one parent.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Nos referimos a este proceso como &quot;fusión confirmada&quot;. Y se diferencia en que tiene más de un padre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You may not want to run `adduser` and set temporary passwords for every user.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Ya que tendrias que lanzar el comando 'adduser' e inventarte contraseñas temporales para cada uno.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>However, if you want another file outside of your project to hold those values or have extra values, you can tell Git where that file is with the `core.excludesfile` setting.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Sin embargo, si quieres disponer de otro archivo fuera de tus proyectos o tener expresiones extra, puedes indicarselo a Git con el parámetro 'core.excludesfile'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Enforcing Policies...
	(refs/heads/master) (fb8c72) (c56860)</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Enforcing Policies...
	(refs/heads/master) (fb8c72) (c56860)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you’re running it internally, and you set up DNS for `gitserver` to point to that server, then you can use the commands pretty much as is:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>que dicho servidor es interno a vuestra red y que está asignado el nombre 'gitserver' en vuestro DNS.  Podrás utlizar comandos tales como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Commit history after featureA work.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Historial tras el trabajo en la funcionalidad A.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git count-objects -v
	count: 8
	size: 2040
	in-pack: 19
	packs: 1
	size-pack: 7
	prune-packable: 0
	garbage: 0</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T134726Z" changeid="juan">
        <seg>$ git count-objects -v
	count: 8
	size: 2040
	in-pack: 19
	packs: 1
	size-pack: 7
	prune-packable: 0
	garbage: 0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git write-tree
	d8329fc1cc938780ffdd9f94e0d364e0ea74f579
	$ git cat-file -p d8329fc1cc938780ffdd9f94e0d364e0ea74f579
	100644 blob 83baae61804e65cc73a7201a7252750c76066a30      test.txt</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T180312Z" changeid="juan">
        <seg>$ git write-tree
	d8329fc1cc938780ffdd9f94e0d364e0ea74f579
	$ git cat-file -p d8329fc1cc938780ffdd9f94e0d364e0ea74f579
	100644 blob 83baae61804e65cc73a7201a7252750c76066a30      test.txt</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>However, your reflog and a new set of refs that Git added when you did the `filter-branch` under `.git/refs/original` still do, so you have to remove them and then repack the database.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T135334Z" changeid="juan">
        <seg>Pero, sin embargo, quedan referencias en el registro (reflog) y en el nuevo conjunto de referencias en `.git/refs/original` que Git ha añadido al procesar  `filter-branch`. Por lo que has de borrar también estás y reempaquetar la base de datos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>That way, you can use private branches for work you don’t want to share, and push up only the topic branches you want to collaborate on.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>De esta forma, puedes usar ramas privadas para el trabajo que no deseas compartir. Llevando a un remoto tan solo aquellas partes que deseas aportar a los demás.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Next, the client uploads a packfile of all the objects the server doesn’t have yet.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T132121Z" changeid="juan">
        <seg>A continuación, el cliente envia un archivo empaquetado con todos los objetos que faltan en el servidor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If your fix for issue #53 modified the same part of a file as the `hotfix`, you’ll get a merge conflict that looks something like this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por ejemplo, si en tu trabajo del problema #53 has modificado una misma porción que también ha sido modificada en el problema 'hotfix'. Puedes obtener un conflicto de fusión tal que:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The first place Git looks for these values is in an `/etc/gitconfig` file, which contains values for every user on the system and all of their repositories.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El primero de ellos es el archivo '/etc/gitconfig', que contiene valores para todos y cada uno de los usuarios en el sistema y para todos sus repositorios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>git:x:1000:1000::/home/git:/bin/sh</seg>
      </tuv>
      <tuv lang="ES">
        <seg>git:x:1000:1000::/home/git:/bin/shgit:x:1000:1000::/home/git:/bin/sh</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>GitHub is slightly different than most code-hosting sites in the way that it namespaces projects.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>GitHub es ligeramente distinto a otros sitios de alberge, en tanto en cuanto que contempla espacios de nombres para los proyectos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>seeing if this helps the gem</seg>
      </tuv>
      <tuv lang="ES">
        <seg>seeing if this helps the gem</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In Git versions 1.6 or newer, you can set the `receive.denyDeletes` and `receive.denyNonFastForwards` settings.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En las versiones a partir de la 1.6, puedes ajustar las opciones 'receive.denyDeletes' (prohibir borrados) y 'receive.denyNonFastForwards' (prohibir envios que no sean avances-rápidos).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git remote add origin git@github.com:schacon/simplegit-progit.git</seg>
      </tuv>
      <tuv lang="ES" changedate="20110815T215314Z" changeid="juan">
        <seg>$ git remote add origin git@github.com:schacon/simplegit-progit.git</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Technically you won’t lose the work, but you won’t have a branch pointing to it, so it will be somewhat difficult to retrieive.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T172443Z" changeid="juan">
        <seg>Técnicamente, no se pierde nada del trabajo. Simplemente, nos quedamos sin ninguna rama apuntando a él. Con lo que resulta problemático recuperar el acceso a los cambios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg># Git on the Server #</seg>
      </tuv>
      <tuv lang="ES">
        <seg># Git en un servidor #</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It rewrites every commit object downstream from the earliest tree you have to modify to remove a large file reference.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T134459Z" changeid="juan">
        <seg>Se basan en reescribir todos los objetos confirmados aguas abajo desde el árbol más reciente modificado para borrar la referencia a un archivo enorme.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Without the `-3` option, it looks like a conflict.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Sin la opción '-3', tendríamos problemas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git config --global color.ui true</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git config --global color.ui true</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>One of the main advantages of this approach is that you can continue to work, and the maintainer of the main repository can pull in your changes at any time.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La principal ventaja de esta forma de trabajar es que puedes continuar trabajando, y la persona gestora del repositorio principal podrá recuperar (pull) tus cambios en cualquier momento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It can look for four primary whitespace issues — two are enabled by default and can be turned off, and two aren’t enabled by default but can be activated.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puede vigilar acerca de cuatro tipos de problemas de espaciado --dos los tiene activados por defecto, pero se pueden desactivar; y dos vienen desactivados por defecto, pero se pueden activar--.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In this section you’ll learn what rebasing is, how to do it, why it’s a pretty amazing tool, and in what cases you won’t want to use it.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En esta sección vas a aprender en qué consiste la reorganización, como utilizarla, por qué es una herramienta sorprendente y en qué casos no es conveniente utilizarla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can view the public key by running</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T234813Z" changeid="juan">
        <seg>Puedes ver esta clave pública con el comando</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The main reason is speed.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Principalmente, por razones de velocidad.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The `-M` switch tells Git to look for renames.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La opción `-M` indica a Git que ha de mirar por si hay algo renombrado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The sequence looks basically like this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La secuencia será algo parecido a esto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You and the other developers all have push access to the repository.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tanto tu como el resto del equipo teneis acceso de envio (push) al repositorio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can set the color to any of the following values: normal, black, red, green, yellow, blue, magenta, cyan, or white.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes ajustar un color a cualquiera de los siguientes valores: 'normal' (normal), 'black' (negro), 'green' (verde), 'yellow' (amarillo), 'blue' (azul oscuro), 'magenta' (rojo oscuro), 'cyan' (azul claro) o 'white' (blanco).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git log --stat 1a410e
	commit 1a410efbd13591db07496601ebc7a059dd55cfe9
	Author: Scott Chacon &lt;schacon@gmail.com&gt;
	Date:   Fri May 22 18:15:24 2009 -0700</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T200110Z" changeid="juan">
        <seg>$ git log --stat 1a410e	commit 1a410efbd13591db07496601ebc7a059dd55cfe9
	Author: Scott Chacon &lt;schacon@gmail.com&gt;
	Date:   Fri May 22 18:15:24 2009 -0700</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Benevolent dictator workflow.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Fujo de trabajo del dictador benevolente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you want to pull commit `e43a6` into your master branch, you can run</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si deseas integar únicamente la confirmación 'e43a6' en tu rama 'master', puedes lanzar:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The `pre-commit` hook is run first, before you even type in a commit message.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Primero se activa el punto de enganche 'pre-commit', incluso antes de que teclees el mensaje de confirmación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git config --global core.pager ''</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git config --global core.pager ''</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## Git References ##</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T185122Z" changeid="juan">
        <seg>## Referencias Git ##</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Basically, you need to run this command in a daemonized manner:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tan solo necesitas lanzar este comando de forma demonizada:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git uses a series of configuration files to determine non-default behavior that you may want.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para determinar su comportamiento no estandar, Git emplea una serie de archivos de configuración.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now you’re ready to add your contributed work into this topic branch and determine if you want to merge it into your longer-term branches.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tras esto, estarás listo para añadir tu trabajo a esa rama puntual y ver si deseas o no fusionarla luego con alguna otra de tus ramas de más largo recorrido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Having their carefully crafted work rejected at the last minute can be extremely frustrating and confusing; and furthermore, they will have to edit their history to correct it, which isn’t always for the faint of heart.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Ver rechazado en el último minuto su tan cuidadosamente preparado trabajo, puede ser realmente frustrante. Y, aún peor, tener que reescribir su histórico para corregirlo puede ser un auténtico calvario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you want an easier way to test the stashed changes again, you can run `git stash branch`, which creates a new branch for you, checks out the commit you were on when you stashed your work, reapplies your work there, and then drops the stash if it applies successfully:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T094402Z" changeid="juan">
        <seg>Una forma más sencilla de reaplicar cambios es utilizando el comando `git stash branch`. Este comando crea una nueva rama, extrayendo (checkout) la confirmación de cambios original en la que se estaba cuando los cambios fueron guardados en la pila, reaplica estos sobre dicha rama y los borra de la pila si se consigue completar el proceso con éxito.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>A higher probability exists that every member of your programming team will be attacked and killed by wolves in unrelated incidents on the same night.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120712T195556Z" changeid="juan">
        <seg>Es mucho más probable que todos los miembros de nuestro equipo de programación fuesen atacados y matados por lobos, en incidentes no relacionados entre sí, acaecidos todos ellos en una misma noche.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>A second method is to create a single 'git' user on the machine, ask every user who is to have write access to send you an SSH public key, and add that key to the `~/.ssh/authorized_keys` file of your new 'git' user.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La segunda forma es el crear un solo usuario 'git' en la máquina y solicitar a cada persona que te envie una clave pública SSH, para que puedas añadirlas al archivo  `~/.ssh/authorized_keys` de dicho usuario 'git'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Once you’re satisfied with your changes, run</seg>
      </tuv>
      <tuv lang="ES" changedate="20120728T085928Z" changeid="juan">
        <seg>Once you’re satisfied with your changes, run</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The first is to set up accounts for everybody, which is straightforward but can be cumbersome.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La primera forma es el habilitar cuentas para todos; es la manera más directa, pero también la más laboriosa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>remote: Compressing objects: 100% (4/4), done.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T105622Z" changeid="juan">
        <seg>remote: Compressing objects: 100% (4/4), done.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you have a commit-message policy in place, then putting a template for that policy on your system and configuring Git to use it by default can help increase the chance of that policy being followed regularly.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si tienes una política concreta con respecto a los mensajes de confirmación de cambios, puedes aumentar las posibilidades de que sea respetada si creas una plantilla acorde a dicha política y la pones como plantilla por defecto de Git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You also don’t have any information about who saved the snapshots, when they were saved, or why they were saved.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T195603Z" changeid="juan">
        <seg>Asimismo, careces de información alguna sobre quién guardó las instantáneas de esos momentos, cuándo fueron guardados o por qué se guardaron.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git push origin master:refs/heads/qa/master</seg>
      </tuv>
      <tuv lang="ES" changedate="20110817T153806Z" changeid="juan">
        <seg>$ git push origin master:refs/heads/qa/master</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The `rack` directory is there, but empty.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T105642Z" changeid="juan">
        <seg>La carpeta `rack` está presente, pero vacia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>They’re local branches that you can’t move; they’re moved automatically whenever you do any network communication.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Son ramas locales que no puedes mover;  se mueven automáticamente cuando estableces comunicaciones en la red.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is generally straightforward to do.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Normalmente suele ser sencillo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Cualquier sistema de control de versiones moderno tiene algún mecanismo para soportar distintas ramas.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cualquier sistema de control de versiones moderno tiene algún mecanismo para soportar distintos ramales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Because Git allows you to have multiple remote repositories, it’s possible to have a workflow where each developer has write access to their own public repository and read access to everyone else’s.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Al permitir multiples repositorios remotos, en Git es posible tener un flujo de trabajo donde cada desarrollador tenga acceso de escritura a su propio repositorio público y acceso de lectura a los repositorios de todos los demás.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In Git, there are two main ways to integrate changes from one branch into another: the `merge` and the `rebase`.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En Git tenemos dos formas de integrar cambios de una rama en otra: la fusión (merge) y la reorganización (rebase).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Add the repo.rb file from the Grit library you worked with earlier — this is about a 12K source code file:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110810T230212Z" changeid="juan">
        <seg>Añadiendo el archivo repo.rb de la libreria Grit con la que has estado trabajando anteriormente, supondrá añadir un achivo con unos 12 Kbytes de código fuente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>That way, they can correct any problems before committing and before those issues become more difficult to fix.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>De esta forma, pueden corregir los problemas antes de confirmar cambios y antes de que se conviertan en algo realmente complicado de arreglar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you’ve lost push access by pushing a messed-up configuration, you can manually fix the file on the server under `/home/git/.gitosis.conf` — the file from which Gitosis reads its info.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si, por lo que sea, pierdes acceso de envio (push) de nuevos cambios, (por ejemplo, tras haber enviado una configuración problemática); siempre puedes arreglar manualmente ,en el propio servidor, el archivo '/home/git/.gitosis.conf', (el archivo del que Gitosis lee su configuración).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Then, you must tell bisect when the last known good state was, using `git bisect good [good_commit]`:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T074946Z" changeid="juan">
        <seg>Y después, con el comando `git bisect good [good_commit]`, se le indica cual es la última confirmación de cambios conocida donde el código funcionaba bien:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>By default, Git passes the following arguments to the diff program:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por defecto, Git pasa los siguientes argumentos al programa diff (comparador):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0406.png
Figure 4-6.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0406.png
Figura 4-6.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>`git apply` is overall much more paranoid than `patch`.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>'git apply' es, de lejos, mucho más paranoico que 'patch'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Your master branch points to the same place as your hotfix branch after the merge.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tras la fusión (merge), la rama 'master' apunta al mismo sitio que la rama 'hotfix'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>&lt;VirtualHost *:80&gt;
	    ServerName gitserver
	    DocumentRoot /var/www/gitweb
	    &lt;Directory /var/www/gitweb&gt;
	        Options ExecCGI +FollowSymLinks +SymLinksIfOwnerMatch
	        AllowOverride All
	        order allow,deny
	        Allow from all
	        AddHandler cgi-script cgi
	        DirectoryIndex gitweb.cgi
	    &lt;/Directory&gt;
	&lt;/VirtualHost&gt;</seg>
      </tuv>
      <tuv lang="ES">
        <seg>&lt;VirtualHost *:80&gt;
	    ServerName gitserver
	    DocumentRoot /var/www/gitweb
	    &lt;Directory /var/www/gitweb&gt;
	        Options ExecCGI +FollowSymLinks +SymLinksIfOwnerMatch
	        AllowOverride All
	        order allow,deny
	        Allow from all
	        AddHandler cgi-script cgi
	        DirectoryIndex gitweb.cgi
	    &lt;/Directory&gt;
	&lt;/VirtualHost&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In this example, you’ll use the `authorized_keys` method for authenticating your users.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En este ejemplo, usarás el método de las 'claves autorizadas' para autentificar a tus usuarios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is very similar to what `receive-pack` responds with, but the capabilities are different.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T080201Z" changeid="juan">
        <seg>La respuesta es muy similar a la dada por `receive-pack`, pero las capacidades que se indican son diferentes. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Jessica doesn’t have push access to the `master` branch — only the integrators do — so she has to push to another branch in order to collaborate with John:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Como Jessica no tiene acceso de envio a la rama 'master' --solo los integradores lo tienen--, ha de enviar a alguna otra rama para poder colaborar con John:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Instead, Git records it as a particular commit from that repository.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T171028Z" changeid="juan">
        <seg>En su lugar, Git realiza confirmaciones de cambio particulares en ese repositorio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git fetch origin master:refs/remotes/origin/mymaster</seg>
      </tuv>
      <tuv lang="ES" changedate="20110815T220918Z" changeid="juan">
        <seg>$ git fetch origin master:refs/remotes/origin/mymaster</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you run this instead of setting up the `extMerge` and `extDiff` files, Git will use KDiff3 for merge resolution and the normal Git diff tool for diffs.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si utilizas este comando en lugar de preparar los archivos 'extMerge' y 'extDiff' antes comentados, Git utilizará KDiff3 para resolución de conflictos de integración y la herramienta estandar diff para las comparaciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Get a writable copy of any repository by clicking the &quot;fork&quot; button.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Obtener una copia sobre la que escribir, clicando sobre el botón &quot;fork&quot; de un repositorio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>At this point, you may want to turn to a widely used software project called Gitosis.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En este punto, es posible que desees cambiar a un popular programa llamado Gitosis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Document version change</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T105442Z" changeid="juan">
        <seg>Document version change</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>However, you can set up other tracking branches if you wish — ones that don’t track branches on `origin` and don’t track the `master` branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Sin embargo, puedes preparar otras ramas de seguimiento si deseas tener unas que no hagan seguimiento de ramas en 'origin' y que no sigan a la rama 'master'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Luckily, Git provides a tool to help you send properly formatted patches via IMAP, which may be easier for you.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Afortunadamente, Git suministra una herramienta que nos puede ser de gran ayuda para enviar parches correctamente formateados a través de protocolo IMAP, facilitandonos así las cosas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You’ll notice the phrase &quot;Fast forward&quot; in that merge.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Merece destacar la frase &quot;Avance rápido&quot; (&quot;Fast forward&quot;) que aparece en la respuesta al comando.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The first developer, John, clones the repository, makes a change, and commits locally.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El primero de ellos, John, clona el repositorio, hace algunos cambios y los confirma localmente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>However, that isn’t convenient, so Git provides another shorthand for doing the same thing: the triple-dot syntax.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Pero esto no es lo más conveniente. De ahí que Git suministre otro atajo para hacerlo: la sintaxis del triple-punto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you pass `-C` to `git blame`, Git analyzes the file you’re annotating and tries to figure out where snippets of code within it originally came from if they were copied from elsewhere.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T074228Z" changeid="juan">
        <seg>Indicando la opción `-C` en el comando `git blame`, Git analizará el archivo que se está anotando para intentar averiguar si alguno de sus fragmentos pudiera provenir de, o haber sido copiado de, algún otro archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The downside to this approach is the whining that will inevitably result when your users’ commit pushes are rejected.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Lo malo del sistema descrito en la sección anterior pueden ser los lamentos que inevitablemente se van a producir cuando los envios de tus usuarios sean rechazados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The example `pre-rebase` hook that Git installs does this, although it assumes that next is the name of the branch you publish.</seg>
      </tuv>
      <tuv lang="ES">
        <seg> El script de ejemplo para 'pre-rebase' hace precisamente eso, aunque asumiendo que 'next' es el nombre de la rama publicada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The mode is taken from normal UNIX modes but is much less flexible — these three modes are the only ones that are valid for files (blobs) in Git (although other modes are used for directories and submodules).</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T195034Z" changeid="juan">
        <seg>Estos modos son como los modos de UNIX, pero mucho menos flexibles. Solo estos tres modos son válidos para archivos (blobs) en Git; (aunque  también se permiten otros modos para carpetas y submódulos).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Remote branches are references to the state of branches on your remote repositories.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Las ramas remotas son referencias al estado de ramas en tus repositorios remotos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>[group mobile_ro]
	readonly = iphone_project
	members = john</seg>
      </tuv>
      <tuv lang="ES">
        <seg>[group mobile_ro]
	readonly = iphone_project
	members = john</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>access = get_acl_access_data('acl')</seg>
      </tuv>
      <tuv lang="ES">
        <seg>access = get_acl_access_data('acl')</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Jessica thinks her topic branch is ready, but she wants to know what she has to merge her work into so that she can push.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Jessica considera su rama puntual terminada, pero quiere saber lo que debe integrar con su trabajo antes de poder enviarla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To modify a commit that is farther back in your history, you must move to more complex tools.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120728T082156Z" changeid="juan">
        <seg>Para modificar una confirmación de cambios situada bastante atrás en el historial, es necesario emplear herramientas más complejas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This kind of workflow isn’t common but can be useful in very big projects or in highly hierarchical environments, because as it allows the project leader (the dictator) to delegate much of the work and collect large subsets of code at multiple points before integrating them.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esta manera de trabajar no es muy habitual, pero es muy util en proyectos muy grandes o en organizaciónes fuertemente jerarquizadas. Permite al lider o a la lider del proyecto (el/la dictador/a) delegar gran parte del trabajo; recolectando el fruto de multiples puntos de trabajo antes de integrarlo en el proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For instance, if you want to include a file named `LAST_COMMIT` in your project, and the last commit date was automatically injected into it when `git archive` ran, you can set up the file like this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por ejemplo, si deseas incluir un archivo llamado 'LAST COMMIT' en tu proyecto, y poner en él automáticamente la fecha de la última confirmación de cambios cada vez que lances el comando 'git archive':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can make Git read and write to this file by passing the `--global` option.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Con la opción '--global', 'git config' lee y escribe en este archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git log -g
	commit 1a410efbd13591db07496601ebc7a059dd55cfe9
	Reflog: HEAD@{0} (Scott Chacon &lt;schacon@gmail.com&gt;)
	Reflog message: updating HEAD
	Author: Scott Chacon &lt;schacon@gmail.com&gt;
	Date:   Fri May 22 18:22:37 2009 -0700</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T143308Z" changeid="juan">
        <seg>$ git log -g
	commit 1a410efbd13591db07496601ebc7a059dd55cfe9
	Reflog: HEAD@{0} (Scott Chacon &lt;schacon@gmail.com&gt;)
	Reflog message: updating HEAD
	Author: Scott Chacon &lt;schacon@gmail.com&gt;
	Date:   Fri May 22 18:22:37 2009 -0700</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Occasionally, this process doesn’t go smoothly.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En algunas ocasiones, los procesos de fusión no suelen ser fluidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This basically says, “Check out the client branch, figure out the patches from the common ancestor of the `client` and `server` branches, and then replay them onto `master`.” It’s a bit complex; but the result, shown in Figure 3-32, is pretty cool.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto viene a decir: &quot;Activa la rama 'client', averigua los cambios desde el ancestro común entre las ramas 'client' y 'server', y aplicalos en la rama 'master'. Puede parecer un poco complicado, pero los resultados, mostrados en la Figura 3-32, son realmente interesantes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Keeping all users’ public keys in the `authorized_keys` file for access works well only for a while.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Mantener claves públicas, para todos los usuarios, en el archivo 'authorized_keys', puede ser una buena solución inicial.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The `request-pull` command takes the base branch into which you want your topic branch pulled and the Git repository URL you want them to pull from, and outputs a summary of all the changes you’re asking to be pulled in.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Este comando 'request-pull' compara la rama base donde deseas que se integre tu rama puntual y el repositorio desde cuya URL deseas que se haga, para darte un resumen de todos los cambios que deseas integrar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>*** Commands ***
	  1: status     2: update      3: revert     4: add untracked
	  5: patch      6: diff        7: quit       8: help
	What now&gt; 1
	           staged     unstaged path
	  1:        +0/-1      nothing TODO
	  2:        +1/-1      nothing index.html
	  3:    unchanged        +5/-1 lib/simplegit.rb</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T212805Z" changeid="juan">
        <seg>*** Commands ***
	  1: status     2: update      3: revert     4: add untracked
	  5: patch      6: diff        7: quit       8: help
	What now&gt; 1
	           staged     unstaged path
	  1:        +0/-1      nothing TODO
	  2:        +1/-1      nothing index.html
	  3:    unchanged        +5/-1 lib/simplegit.rb</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Well, doing so creates a new pointer for you to move around.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Bueno....., simplemente se crea un nuevo apuntador para que lo puedas mover libremente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now you can see that the TODO and index.html files are staged and the simplegit.rb file is still unstaged.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T212908Z" changeid="juan">
        <seg>En estos momentos se ve que los archivos TODO e index.html están en el área de preparación y que el archivo simplegit.rb no está aún.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>We’ll discuss how to export a bare repository copy for this purpose in the next section, “Getting Git on a Server.”</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En la próxima sección, &quot;Disponiendo Git en un servidor&quot;, veremos cómo exportar un repositorio básico para conseguir esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>However, if your message contains the proper pattern, Git allows you to commit:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Sin embargo, si el mensaje está formateado adecuadamente, Git te permitirá confirmar cambios:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you click it, you see a form with information about the import process and a text box where you can paste in the URL of your public Subversion project (see Figure 4-9).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si clicas sobre dicho enlace, verás un formulario con información sobre el proceso de importación y un cuadro de texto donde puedes pegar la URL de tu proyecto Subversion (ver Figura 4-9).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git fetch origin
	...
	From jessica@githost:simplegit
	 * [new branch]      featureBee -&gt; origin/featureBee</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git fetch origin
	...
	From jessica@githost:simplegit
	 * [new branch]      featureBee -&gt; origin/featureBee</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If your project is very large, nonstandard, or private, this process probably won’t work for you.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si tu proyecto es muy grande, no-estandar o privado, es muy posible que no se pueda importar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you don’t specify a stash, Git assumes the most recent stash and tries to apply it:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120702T085943Z" changeid="juan">
        <seg>Si no se indica ningún grupo concreto, Git asume que se desea reaplicar el grupo de cambios más reciente de entre los guardados en la pila.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>One of them is the _subtree_ merge, and you can use it to deal with the subproject issue.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T141332Z" changeid="juan">
        <seg>Una de ellas, la _fusión_subárbol_ (_subtree_ merge), es precisamente la más adecuada para tratar con subproyectos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The format for a commit object is simple: it specifies the top-level tree for the snapshot of the project at that point; the author/committer information pulled from your `user.name` and `user.email` configuration settings, with the current timestamp; a blank line, and then the commit message.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T145311Z" changeid="juan">
        <seg>El formato para un objeto de confirmación de cambios (commit) es sencillo, contemplando: el objeto tipo árbol para la situación del proyecto en ese momento puntual; la información sobre el autor/confirmador, recogida desde las opciones de configuración`user.name` y `user.email`; la fecha y hora actuales; una línea en blanco; y el mensaje de la confirmación de cambios.  </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In this environment, you can follow a workflow similar to what you might do when using Subversion or another centralized system.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En un entorno como este, puedes seguir un flujo de trabajo similar al que adoptarías usando Subversion o algún otro sistema centralizado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Since `clone` is basically a `git init` then a `git fetch`, we see some output from the `git init` part, which creates an empty directory.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Como 'clone' es fundamentalmente un 'git init' seguido de un 'git fetch', veremos algunos de los mensajes de la parte 'init', concretamente de la parte en que se crea una carpeta vacia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you want to use a merge tool other than the default (Git chose `opendiff` for me in this case because I ran the command on a Mac), you can see all the supported tools listed at the top after “merge tool candidates”.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si deseas usar una herramienta distinta de la escogida por defecto (en mi caso 'opendiff', porque estoy lanzando el comando en un Mac), puedes escogerla entre la lista de herramientas soportadas mostradas al principio (&quot;merge tool candidates&quot;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Suppose you’ve done an import from another source control system and have subdirectories that make no sense (trunk, tags, and so on).</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T192302Z" changeid="juan">
        <seg>Por ejemplo, en el caso de que se haya importado trabajo desde otro sistema de control de versiones, y se tengan algunas subcarpetas sin sentido (trunk, tags,...).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git rm -r rack
	$ git submodule add git@github.com:schacon/rack.git rack
	Initialized empty Git repository in /opt/testsub/rack/.git/
	remote: Counting objects: 3184, done.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T135847Z" changeid="juan">
        <seg>$ git rm -r rack
	$ git submodule add git@github.com:schacon/rack.git rack
	Initialized empty Git repository in /opt/testsub/rack/.git/
	remote: Counting objects: 3184, done.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You’re ready to go — nothing else needed.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>y.... ¡listo!, eso es todo lo que necesitas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>git daemon --reuseaddr --base-path=/opt/git/ /opt/git/</seg>
      </tuv>
      <tuv lang="ES">
        <seg>git daemon --reuseaddr --base-path=/opt/git/ /opt/git/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git log --pretty=oneline test
	cac0cab538b970a37ea1e769cbbde608743bc96d second commit
	fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T191456Z" changeid="juan">
        <seg>$ git log --pretty=oneline test
	cac0cab538b970a37ea1e769cbbde608743bc96d second commit
	fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Revert &quot;added file_size&quot;
	stash@{2}: WIP on master: 21d80a5... added number to log</seg>
      </tuv>
      <tuv lang="ES" changedate="20120702T085437Z" changeid="juan">
        <seg>Revert &quot;added file_size&quot;
	stash@{2}: WIP on master: 21d80a5... added number to log</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In addition, it sends back the HEAD reference so the client knows what to check out if this is a clone.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T132510Z" changeid="juan">
        <seg>Además, nos indica la referencia HEAD, para que el cliente pueda saber qué ha de activar (check out) en el caso de estar requiriendo un clon.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now, let’s say you decide you like the second solution to your issue best (`iss91v2`); and you showed the `dumbidea` branch to your coworkers, and it turns out to be genius.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En este momento, supongamos que te decides por la segunda solución al problema (rama 'iss92v2'); y que, tras mostrar la rama 'dumbidea' a tus compañeros, resulta que les parece una idea genial.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>[POLICY] Your message is not formatted correctly</seg>
      </tuv>
      <tuv lang="ES">
        <seg>[POLICY] Your message is not formatted correctly</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This replays your `server` work on top of your `master` work, as shown in Figure 3-34.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto vuelca el trabajo de 'server' sobre el de 'master', tal y como se muestra en la Figura 3-34.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>A history with a topic branch off another topic branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Un registro con una rama puntual sobre otra rama puntual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>One cool trick for which you can use Git attributes is telling Git which files are binary (in cases it otherwise may not be able to figure out) and giving Git special instructions about how to handle those files.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Un buen truco donde utilizar los atributos Git es para indicarle cuales de los archivos son binarios, (en los casos en que Git no podría llegar a determinarlo por sí mismo), dandole a Git instruciones especiales sobre cómo tratar estos archivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Because 'scott' is the only user in the system right now, you’ll add him as the only member, and you’ll create a new project called `iphone_project` to start on:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por ser 'scott' el único usuario que tienes definido por ahora, lo añadirás como el único miembro. Y puedes crear además un proyecto llamado 'iphone_project' para empezar:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It gets a list of all the commits you’re about to rewrite and checks whether they exist in any of your remote references.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Con la lista de confirmaciones de cambio que estás a punto de reescribir, las comprueba por si alguna de ellas existe en alguna de tus referencias remotas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you’re running a firewall, you’ll also need to punch a hole in it at port 9418 on the box you’re setting this up on.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si tienes un cortafuegos activo, necesitarás abrir el puerto 9418 para la máquina donde estás configurando el demónio Git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Running your own server gives you a lot of control and allows you to run the server within your own firewall, but such a server generally requires a fair amount of your time to set up and maintain.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Disponer de tu propio servidor te da pleno control sobre él y te permite trabajar dentro de tu propio cortafuegos. Pero un servidor así suele requerir bastante de tu tiempo para prepararlo y mantenerlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>So, to get a list of all the commit SHAs introduced between one commit SHA and another, you can run something like this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Con él, puedes obtener la lista de todas las claves SHA que se han introducido entre una clave SHA y otra clave SHA dadas; obtendrás algo así como esto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For example, to clone a local repository, you can run something like this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por ejemplo, para clonar un repositorio local, puedes usar algo como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ cat .git/HEAD
	ref: refs/heads/test</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T192402Z" changeid="juan">
        <seg>$ cat .git/HEAD
	ref: refs/heads/test</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Compressing objects: 100% (2/2), done.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Compressing objects: 100% (2/2), done.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is useful if you want to keep the `experiment` branch up to date and preview what you’re about to merge in.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T192100Z" changeid="juan">
        <seg>Esto es útil si se desea mantener actualizada la rama 'experiment' y previsualizar lo que se está a punto de fusionar en ella.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>HEAD@{6}: rebase -i (pick): updating HEAD</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T102039Z" changeid="juan">
        <seg>HEAD@{6}: rebase -i (pick): updating HEAD</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For really large companies or projects, the number of developers could be in the thousands, with dozens or even hundreds of patches coming in each day.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En proyectos o empresas verdaderamente grandes puedes tener cientos de desarrolladores, con docenas o incluso cientos de parches llegando cada día.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>However, it can be helpful sometimes when you need to see what’s really going on.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120712T195907Z" changeid="juan">
        <seg>Pero que, sin embargo, pueden ser muy útiles cuando se desea ver lo que realmente sucede &quot;tras las bambalinas&quot;, en el interior de Git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When you create the commit by running `git commit`, Git checksums each subdirectory (in this case, just the root project directory) and stores those tree objects in the Git repository.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cuando creas una confirmación con el comando 'git commit', Git realiza sumas de control de cada subcarpeta (en el ejemplo, solamente tenemos la carpeta principal del proyecto), y guarda en el repositorio Git una copia de cada uno de los archivos contenidos en ella/s.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can add it as a new remote reference to the project you’re currently working on by running the `git remote add` command as we covered in Chapter 2.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes incluirlo como una nueva referencia remota a tu proyecto actual, mediante el comando 'git remote add', tal y como vimos en el capítulo 2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Here are all the objects in the example directory now, commented with what they store:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110807T153509Z" changeid="juan">
        <seg>Aquí se muestran todos los objetos presentes en este momento en la carpeta del ejemplo, con comentarios acerca de lo que almacena cada uno de ellos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you check out one and then the other, you can see that they have different project roots:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T173343Z" changeid="juan">
        <seg>Si se comprueban una o la otra, se puede observar que ambos proyectos tienen distintas raices:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>target_shas.each do |sha|
	  remote_refs.each do |remote_ref|
	    shas_pushed = `git rev-list ^#{sha}^@ refs/remotes/#{remote_ref}`
	    if shas_pushed.split(“\n”).include?(sha)
	      puts &quot;[POLICY] Commit #{sha} has already been pushed to #{remote_ref}&quot;
	      exit 1
	    end
	  end
	end</seg>
      </tuv>
      <tuv lang="ES">
        <seg>target_shas.each do |sha|
	  remote_refs.each do |remote_ref|
	    shas_pushed = `git rev-list ^#{sha}^@ refs/remotes/#{remote_ref}`
	    if shas_pushed.split(“\n”).include?(sha)
	      puts &quot;[POLICY] Commit #{sha} has already been pushed to #{remote_ref}&quot;
	      exit 1
	    end
	  end
	end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>git:x:1000:1000::/home/git:/usr/bin/git-shell</seg>
      </tuv>
      <tuv lang="ES">
        <seg>git:x:1000:1000::/home/git:/usr/bin/git-shellgit:x:1000:1000::/home/git:/usr/bin/git-shell</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now you can remove your topic branch and drop the commits you didn’t want to pull in.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Ahora, ya puedes borrar la rama puntual y descartar las confirmaciones de cambios que no deseas integrar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Limit log functionality to the first 20</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Limit log functionality to the first 20Limit log functionality to the first 20Limit log functionality to the first 20</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Change `/bin/sh` to `/usr/bin/git-shell` (or run `which git-shell` to see where it’s installed).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y cambiar '/bin/sh' por '/usr/bin/git-shell' (nota: puedes utilizar el comando 'which git-shell' para ver dónde está instalado dicho shell).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>First you need to enable the hook:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Lo primero, es activar el anclaje (hook):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For pre-1.6 versions of Git, the example files are named properly but are not executable.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para las versiones anteriores a la 1.6, los ejemplos tienen el nombre correcto, pero les falta la marca de ejecutables.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Annotating a file helps if you know where the issue is to begin with.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T165421Z" changeid="juan">
        <seg>La anotación de archivos es útil si se conoce aproximadamente el punto dónde se localizan los problemas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>GitHub is by far the largest open source Git hosting site and it’s also one of the very few that offers both public and private hosting options so you can keep your open source and private commercial code in the same place.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>GitHub es, de lejos, el mayor sitio de alberge público de proyectos Git de código abierto. Y es también uno de los pocos que ofrece asimismo opciones de alberge privado; de tal forma que puedes tener tanto tus proyectos de código abierto y como los de código comercial cerrado en un mismo emplazamiento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If all 6.5 billion humans on Earth were programming, and every second, each one was producing code that was the equivalent of the entire Linux kernel history (1 million Git objects) and pushing it into one enormous Git repository, it would take 5 years until that repository contained enough objects to have a 50% probability of a single SHA-1 object collision.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T190006Z" changeid="juan">
        <seg>Si todos los 6'5 billones de humanos en el planeta Tierra estuvieran programando y, cada segundo, cada uno de ellos escribiera código equivalente a todo el histórico del kernel de Linux (cerca de 1 millón de objetos Git), enviandolo todo a un enorme repositorio Git. Serían necesarios unos 5 años antes de que dicho repositorio contuviera suficientes objetos como para tener una probabilidad del 50% de darse una sola colisión en el código SHA-1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If someone only has a single patch to contribute once in a while, then accepting it over e-mail may be less time consuming than requiring everyone to run their own server and having to continually add and remove remotes to get a few patches.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En cambio, si alguien tiene un solo parche para enviarte, una sola vez, puede ser más efectivo aceptarlo directamente por correo-e; en lugar de pedir a todo el mundo que tenga cada uno su propio servidor y tener nosotros que estar continuamente añadiendo y quitando remotos para cada parche.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ chgrp -R www-data /opt/git</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ chgrp -R www-data /opt/git</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ cat /usr/local/bin/extMerge
	#!/bin/sh
	/Applications/kdiff3.app/Contents/MacOS/kdiff3 $*</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ cat /usr/local/bin/extMerge
	#!/bin/sh
	/Applications/kdiff3.app/Contents/MacOS/kdiff3 $*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You now have a nice tarball and a zip archive of your project release that you can upload to your website or e-mail to people.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Así, tendrás sendos archivos tarball y zip con tu nueva versión, listos para subirlos a tu sitio web o para ser enviados por correo electrónico a tus usuarios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Probably the simplest way for smaller setups is to run a static web server with its document root where your Git repositories are, and then enable that `post-update` hook we mentioned in the first section of this chapter.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La manera más sencilla de hacerlo para pequeños despliegues, es el preparar un servidor web estático cuya raiz de documentos sea la ubicación donde tengas tus repositorios Git; y luego activar el anclaje (hook) 'post-update' que se ha mencionado en la primera parte de este capítulo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## The Protocols ##</seg>
      </tuv>
      <tuv lang="ES">
        <seg>## Los Protocolos ##</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>We’ll refer to this repository as a &quot;Git server&quot;; but you’ll notice that it generally takes a tiny amount of resources to host a Git repository, so you’ll rarely need to use an entire server for it.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Nos referiremos a este repositorio como &quot;servidor Git&quot;; pero en seguida te darás cuenta de que solo se necesitan unos pocos recursos para albergar un repositorio Git, y, por tanto, no será necesario utilizar todo un servidor entero para él.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The question now is, when you run `git branch (branchname)`, how does Git know the SHA-1 of the last commit?</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T111204Z" changeid="juan">
        <seg>Y ahora nos preguntamos, al lanzar el comando `git branch (nombrederama)`, ¿cómo sabe Git cuál es el valor SHA-1 de la última confirmación de cambios?.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg># only allows certain users to modify certain subdirectories in a project
	def check_directory_perms
	  access = get_acl_access_data('acl')</seg>
      </tuv>
      <tuv lang="ES">
        <seg># only allows certain users to modify certain subdirectories in a project
	def check_directory_perms
	  access = get_acl_access_data('acl')</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>[group mobile]
	writable  = iphone_project
	members   = @mobile_committers</seg>
      </tuv>
      <tuv lang="ES">
        <seg>[group mobile]
	writable  = iphone_project
	members   = @mobile_committers</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The simplest setup you’re likely to encounter is a private project with one or two other developers.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Lo más simple que te puedes encontrar es un proyecto privado con uno o dos desarrolladores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In fact, if you have a script that will exit 0 if the project is good or non-0 if the project is bad, you can fully automate `git bisect`.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T075422Z" changeid="juan">
        <seg>De hecho, si se dispone de un script que dé una salida 0 si el proyecto funciona correctamente y distinto de 0 si el proyecto tiene errores, todo este proceso de búsqueda con `git bisect` se puede automatizar completamente. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is particularly useful for managing your branches — if you have a lot of branches, you can use range specifications to answer questions such as, &quot;What work is on this branch that I haven’t yet merged into my main branch?&quot;</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T115547Z" changeid="juan">
        <seg>Esto es especialmente útil en la gestión de ramas. Si se tienen multitud de ramas, se pueden emplear las espeficicaciones de rango para responder a cuestiones tales como &quot;¿cual es el trabajo de esta rama que aún no se ha fusionado con la rama principal?&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>subject line</seg>
      </tuv>
      <tuv lang="ES">
        <seg>subject line</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This can also be written `HEAD^^^`, which again is the first parent of the first parent of the first parent:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T114831Z" changeid="juan">
        <seg>Igualmente, se podría haber escrito `HEAD^^^`, que también se refiere al &quot;primer padre del primer padre del primer padre&quot;:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git cherry-pick e43a6fd3e94888d76779ad79fb568ed180e5fcdf
	Finished one cherry-pick.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git cherry-pick e43a6fd3e94888d76779ad79fb568ed180e5fcdf
	Finished one cherry-pick.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If there is a subdirectory or file that you don’t want to include in your archive file but that you do want checked into your project, you can determine those files via the `export-ignore` attribute.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cuando tienes alguna carpeta o archivo que no deseas incluir en tus registros, pero quieras tener controlado en tu proyecto, puedes marcarlos a través del atributo 'export-ignore'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>John has to fetch Jessica’s changes and merge them in before he will be allowed to push:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>John se vé obligado a recuperar (fetch) los cambios de jessica y a fusionarlos (merge) con los suyos, antes de que se le permita enviar (push):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can run your tests, make sure the hotfix is what you want, and merge it back into your master branch to deploy to production.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes realizar las pruebas oportunas, asegurarte que la solución es correcta, e incorporar los cambios a la rama 'master' para ponerlos en producción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Because it’s rarely used, we won’t cover it in this book.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y precisamente porque se usa raramente, no lo vamos a cubrir en este libro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This allows you to introduce all the changes from another branch and then make more changes before recording the new commit.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto te permitirá el aplicar todos los cambios de la otra rama y después hacer más cambios, antes de guardarlos todos ellos en una nueva confirmación (commit).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can use this hook to disallow rebasing any commits that have already been pushed.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes usarlo para impedir reorganizaciones de cualquier confirmación de cambios ya enviada (push) a algún servidor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Finally, John’s commit history looks like Figure 5-6.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Finalmente, el historial de John es algo parecido a la Figura 5-6.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Switched to a new branch &quot;sf&quot;</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Switched to a new branch &quot;sf&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you have it read the message from the file passed as the first argument and compare that to the pattern, you can force Git to abort the commit if there is no match:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Comparando el mensaje del archivo pasado como primer argumento con el mensaje patrón, puedes obligar a Git a abortar la confirmación de cambios (commit) en caso de no coincidir ambos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>#### core.editor ####</seg>
      </tuv>
      <tuv lang="ES">
        <seg>#### core.editor ####</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Notice the `*` character that prefixes the `master` branch: it indicates the branch that you currently have checked out.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Fijate en el carácter '*' delante de la rama 'master': nos indica la rama  activa en este momento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git clone user@git.example.com:/opt/git/my_project.git</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git clone user@git.example.com:/opt/git/my_project.git</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now you want to release a build.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si quieres lanzar una nueva versión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Thus these three commands are equivalent:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T201647Z" changeid="juan">
        <seg>Así, estos tres comandos son equivalentes:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Jessica’s history after merging both her topic branches.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El historial de Jessica tras fusionar sus dos ramas puntuales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The really interesting part is that the UI for this tool for adding people and determining access isn’t a web interface but a special Git repository.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Lo interesante de la interfaz de usuario para esta herramienta de gestión de usuarios y de control de accesos, es que, en lugar de un interface web, es un repositorio especial de Git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git compresses the contents of these files with zlib, and you’re not storing much, so all these files collectively take up only 925 bytes.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T113230Z" changeid="juan">
        <seg>Git comprime todos esos archivos con zlib, por lo que ocupan más bien poco. Entre todos suponen solamente 925 bytes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>By private, I mean closed source — not read-accessible to the outside world.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por privado, me refiero a código propietario --no disponible para ser leido por el mundo exterior--.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git instaweb --httpd=webrick
	[2009-02-21 10:02:21] INFO  WEBrick 1.3.1
	[2009-02-21 10:02:21] INFO  ruby 1.8.6 (2008-03-03) [universal-darwin9.0]</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git instaweb --httpd=webrick
	[2009-02-21 10:02:21] INFO  WEBrick 1.3.1
	[2009-02-21 10:02:21] INFO  ruby 1.8.6 (2008-03-03) [universal-darwin9.0]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Writing objects: 100% (3/3), 323 bytes, done.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Writing objects: 100% (3/3), 323 bytes, done.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can use it to restore data in the working tree that Git can’t track, such as permissions data.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes utilizarlo para recuperar datos de tu carpeta de trabajo que Git no puede controlar, como por ejemplo datos relativos a permisos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>[group mobile]
	writable = iphone_project
	members = scott john josie jessica</seg>
      </tuv>
      <tuv lang="ES">
        <seg>[group mobile]
	writable = iphone_project
	members = scott john josie jessica</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Putting the Bare Repository on a Server ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Poniendo el repositorio básico en un servidor ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>A repository on NFS is often slower than the repository over SSH on the same server, allowing Git to run off local disks on each system.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Normalmente un repositorio sobre NFS es más lento que un repositorio SSH en el mismo servidor, asumiendo que las pruebas se hacen con Git sobre discos locales en ambos casos. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For instance, if you wanted to see what the `master` branch on your `origin` remote looked like as of the last time you communicated with it, you would check the `origin/master` branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por ejemplo, si quieres saber cómo estaba la rama 'master' en el remoto 'origin'. Puedes revisar la rama 'origin/master'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>[ticket: X]
	# Please enter the commit message for your changes.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>[ticket: X]
	# Please enter the commit message for your changes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Because you rebased the branch, you have to specify the `–f` to your push command in order to be able to replace the `featureA` branch on the server with a commit that isn’t a descendant of it.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Debido a que has reorganizado (rebase) tu rama de trabajo, tienes que indicar la opción '-f' en tu comando de envio (push), para permitir que la rama 'featureA' del servidor sea reemplazada por una confirmación de cambios (commit) que no es hija suya.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>At the very least, this may be a way to get up and running with Git and try it out quickly.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y, por último, comentar que esta puede ser una buena manera de iniciarte y comenzar rápidamente a trabajar con Git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The first line was printed out by you, the other two were Git telling you that the update script exited non-zero and that is what is declining your push.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La primera línea la has enviado tú, pero las otras dos son de Git. Indicando que el script de actualización ha terminado con código no-cero y, por tanto, ha rechazado la modificación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You just append them to your `authorized_keys` file:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>No tienes más que añadirlas al archivo 'authorized_keys':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You work for a while, generally in a topic branch, and merge into your master branch when it’s ready to be integrated.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Trabajas un rato, normalmente en una rama puntual de un asunto concreto, y la fusionas con tu rama principal cuando la tienes lista para integrar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Most of that should be easy to follow.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La mayor parte de este código debería de ser sencillo de leer.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git branch –D recover-branch
	$ rm -Rf .git/logs/</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T143841Z" changeid="juan">
        <seg>$ git branch –D recover-branch
	$ rm -Rf .git/logs/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git fires up the `send-pack` process, which initiates a connection over SSH to your server.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T073748Z" changeid="juan">
        <seg>Git lanzará el proceso `send-pack` , con el que establece conexión SSH con tu servidor. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Using smart protocols is a more common method of transferring data.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T131449Z" changeid="juan">
        <seg>Es mucho más común utilizar protocolos inteligentes para transferir datos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you follow that guideline, you’ll be fine.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Siguiendo esta recomendación, no tendrás problemas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For post-1.6 versions of Git, these example hook files end with .sample; you’ll need to rename them.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En las versiones de Git posteriores a la 1.6, esos ejemplos tendrán un nombre acabado en .sample; y tendras que renombrarlos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0516.png
Figure 5-16.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0516.png
Figura 5-16.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you want to try this out, P4Merge works on all major platforms, so you should be able to do so.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si lo quieres probar, P4Merge funciona en todas las principales plataformas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Finally, Git looks for configuration values in the config file in the Git directory (`.git/config`) of whatever repository you’re currently using.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y por último, Git también puede considerar valores de configuración presentes en el archivo '.git/config' de cada repositorio que estés utilizando.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git gc
	Counting objects: 21, done.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T104818Z" changeid="juan">
        <seg>$ git gc
	Counting objects: 21, done.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Having work themes isolated into topic branches also makes it easier for you to rebase your work if the tip of the main repository has moved in the meantime and your commits no longer apply cleanly.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Manteniendo el trabajo de distintos temas aislados en sus respectivas ramas puntuales, te facilitas también el poder reorganizar tu trabajo si la cabeza del repositorio principal se mueve mientras tanto y tus confirmaciones de cambio (commits) ya no se pueden integrar limpiamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>One of the workarounds to the `denyNonFastForwards` policy is for the user to delete the branch and then push it back up with the new reference.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Uno de los cortocircuitos que suelen utilizar los usuarios para saltarse la politica de 'denyNonFastForwards', suele ser el borrar la rama y luego volver a enviarla de vuelta con la nueva referencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Then, you can push to and pull from that remote as though you were doing so over a network.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Con lo que podrás enviar (push) y recibir (pull) desde dicho remoto exactamente de la misma forma a como lo harías a través de una red.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To see what changes each commit introduces, remember that you can pass the `-p` option to `git log` and it will append the diff introduced to each commit.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para ver en detalle los cambios introducidos por cada confirmación (commit), recuerda que pasando la opción '-p' al comando 'git log', obtendrás un listado extendido con las diferencias introducidas por cada confirmación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git verify-pack -v .git/objects/pack/pack-3f8c0...bb.idx | sort -k 3 -n | tail -3
	e3f094f522629ae358806b17daf78246c27c007b blob   1486 734 4667
	05408d195263d853f09dca71d55116663690c27c blob   12908 3478 1189
	7a9eb2fba2b1811321254ac360970fc169ba2330 blob   2056716 2056872 5401</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T105742Z" changeid="juan">
        <seg>$ git verify-pack -v .git/objects/pack/pack-3f8c0...bb.idx | sort -k 3 -n | tail -3
	e3f094f522629ae358806b17daf78246c27c007b blob   1486 734 4667
	05408d195263d853f09dca71d55116663690c27c blob   12908 3478 1189
	7a9eb2fba2b1811321254ac360970fc169ba2330 blob   2056716 2056872 5401</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you want to see what is in `master` or `experiment` but not any common references, you can run</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T202403Z" changeid="juan">
        <seg>Si se desea ver lo que está o bien en 'master' o bien en 'experiment', pero no en ambas simultáneamente, se puede emplear el comando:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It looks basically like this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Pues tiene una pinta tal como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can treat the `rack` directory as a separate project and then update your superproject from time to time with a pointer to the latest commit in that subproject.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T171326Z" changeid="juan">
        <seg>Se puede considerar la carpeta `rack` como si fuera un proyecto separado. Y, como tal, de vez en cuando se puede actualizar el proyecto padre con un puntero a la última confirmación de cambios en dicho subproyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now, you need to remove this file from all trees in your past.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T135044Z" changeid="juan">
        <seg>Una vez tengas ese dato, lo puedes utilizar para borrar ese archivo en todos los árboles pasados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It looks like the bottom commit is the one you lost, so you can recover it by creating a new branch at that commit.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T133357Z" changeid="juan">
        <seg>Parece que la confirmación de cambios perdida es esta última. Puedes recuperarla creando una nueva rama apuntando a ella.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If the book spontaneously
	+s going on, modify stuff and contribute changes.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>If the book spontaneously
	+s going on, modify stuff and contribute changes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can ask Git to show you a log of just those commits with `master..experiment` — that means &quot;all commits reachable by experiment that aren’t reachable by master.&quot; For the sake of brevity and clarity in these examples, I’ll use the letters of the commit objects from the diagram in place of the actual log output in the order that they would display:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T120452Z" changeid="juan">
        <seg>Se puede pedir a Git que muestre un registro con las confirmaciones de cambio en `master..experiment`. Es decir, &quot;todas las confirmaciones de cambio alcanzables desde experiment que no se pueden alcanzar desde master&quot;. Por razones de brevedad y claridad en los ejemplos, para representar los objetos confirmación de cambios (commit) se utilizarán las letras mostradas en el diagrama en lugar de todo el registro propiamente dicho: </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git checkout master
	Switched to branch &quot;master&quot;
	Your branch is behind 'origin/master' by 2 commits, and can be fast-forwarded.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git checkout master
	Switched to branch &quot;master&quot;
	Your branch is behind 'origin/master' by 2 commits, and can be fast-forwarded.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In this scenario, all work is done in team-based branches and pulled together by the integrators later.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En este escenario, todo el trabajo se realiza en ramas propias de cada grupo y es consolidado por los integradores más tarde.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you look at the file, you’ll normally see something like this:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T192318Z" changeid="juan">
        <seg>Si miras dentro del archivo, podrás observar algo como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Every time you commit, it moves forward automatically.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En cada confirmación de cambios que realicemos, la rama irá avanzando automáticamente. Y la rama 'master' apuntará siempre a la última confirmación realizada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>def ls_tree(treeish = 'master')
	--
	1.6.2.rc1.20.g8c5b.dirty</seg>
      </tuv>
      <tuv lang="ES">
        <seg>def ls_tree(treeish = 'master')
	--
	1.6.2.rc1.20.g8c5b.dirty</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can do that in the `rebase -i` script by changing the instruction on the commit you want to split to &quot;edit&quot;:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T190302Z" changeid="juan">
        <seg>Se puede realizar cambiando la instrucción en el script de `rebase -i`, desde 'split' a 'edit': </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The format of the refspec is an optional `+`, followed by `&lt;src&gt;:&lt;dst&gt;`, where `&lt;src&gt;` is the pattern for references on the remote side and `&lt;dst&gt;` is where those references will be written locally.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110815T215846Z" changeid="juan">
        <seg>El formato para esta referencia es un signo `+` opcional, seguido de una sentencia `&lt;orig&gt;:&lt;dest&gt;`; donde  `&lt;orig&gt;` es la plantilla para referencias en el lado remoto y `&lt;dest&gt;` el lugar donde esas referencias se escribirán en el lado local.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To initialize a project if it isn’t already a Git project, you use</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para inicializar un proyecto, no siendo aún un proyecto Git, sueles utilizar:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Commit history after featureBv2 work.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Historial tras el trabajo en la versión 2 de la funcionalidad B.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0321.png
Figure 3-21.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0321.png
Figura 3-21.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Next is the Git protocol.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El protocolo Git </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Next, you need to add a VirtualHost entry to your Apache configuration with the document root as the root directory of your Git projects.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>A continuación, has de añadir una entrada VirtualHost al archivo de configuración de Apache, fijando su raiz de documentos a la ubicación donde tengas tus proyectos Git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It may be helpful to think of your branches as silos.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puede ayudar pensar en las ramas como silos de almacenamiento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The problem is, you don’t want to do a commit of half-done work just so you can get back to this point later.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120712T202323Z" changeid="juan">
        <seg>Esto plantea el problema de confirmar cambios en un trabajo medio hecho, simplemente para poder volver a ese punto más tarde.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You get a list of new commits being pushed to your server with `git rev-list`.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Con 'git rev-list', obtienes una lista de las nuevas confirmaciones de cambio enviadas a tu servidor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Integrating Contributed Work ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Integrando el trabajo aportado por otros ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>I used Ruby to write these, both because it’s my preferred scripting language and because I feel it’s the most pseudocode-looking of the scripting languages; thus you should be able to roughly follow the code even if you don’t use Ruby.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>He usado Ruby para escribir los ejemplos, tanto porque es mi lenguaje preferido de scripting y porque creo que es el más parecido a pseudocódigo; de tal forma que puedas ser capaz de seguir el código, incluso si no conoces Ruby.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>There are a few ways you can give access to everyone on your team.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tienes varias maneras para dar acceso a todos los miembros de tu equipo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Here we can see the two commits that we have had checked out, however there is not much information here.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T143207Z" changeid="juan">
        <seg>Se pueden ver las dos confirmaciones de cambios que hemos activado, pero no hay mucha más información al respecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git checkout master
	$ git merge iss53
	Merge made by recursive.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git checkout master
	$ git merge iss53
	Merge made by recursive.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>&lt;VirtualHost *:80&gt;
	    ServerName git.gitserver
	    DocumentRoot /opt/git
	    &lt;Directory /opt/git/&gt;
	        Order allow, deny
	        allow from all
	    &lt;/Directory&gt;
	&lt;/VirtualHost&gt;</seg>
      </tuv>
      <tuv lang="ES">
        <seg>&lt;VirtualHost *:80&gt;
	    ServerName git.gitserver
	    DocumentRoot /opt/git
	    &lt;Directory /opt/git/&gt;
	        Order allow, deny
	        allow from all
	    &lt;/Directory&gt;
	&lt;/VirtualHost&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Gitosis is basically a set of scripts that help you manage the `authorized_keys` file as well as implement some simple access controls.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Gitosis es básicamente un conjunto de scripts que te ayudarán a gestionar el archivo 'authorized_keys', así como a implementar algunos controles de acceso simples.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you add a remote and push to it, Git stores the value you last pushed to that remote for each branch in the `refs/remotes` directory.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110810T224749Z" changeid="juan">
        <seg>Si añades un remoto y envias algo a él, Git almacenará en dicho remoto el último valor para cada rama presente en la carpeta `refs/remotes`. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now that you have the contents of your key in Git, you can create a tag that points directly to it by specifying the new SHA-1 value that the `hash-object` command gave you:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Una vez tengas el contenido de tu clave guardado en Git, puedes crear una etiquta que apunte directamente al mismo; indicando para ello el nuevo valor SHA-1 que te ha devuelto el objeto 'hash-object':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It’s important to note that these commits are listed in the opposite order than you normally see them using the `log` command.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T122452Z" changeid="juan">
        <seg>Es importante destacar que esas confirmaciones de cambios se han listado en el orden opuesto al que normalmente son mostradas en el comando `log`. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Again, this gives you normal `log` output but shows you only the commit information for those four commits, appearing in the traditional commit date ordering.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T202704Z" changeid="juan">
        <seg>De nuevo, esto da una salida normal de 'log', pero mostrando tan solo información sobre las cuatro confirmaciones de cambio, dadas en la tradicional secuencia ordenada por fechas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git remote add origin git@github.com:schacon/simplegit-progit.git
	$ git push origin master
	Counting objects: 11, done.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110810T224901Z" changeid="juan">
        <seg>$ git remote add origin git@github.com:schacon/simplegit-progit.git
	$ git push origin master
	Counting objects: 11, done.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You’re ready to roll.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y ya estás preparado para trabajar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0515.png
Figure 5-15.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0515.png
Figura 5-15.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git rebase master server</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git rebase master server</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The end snapshot should be identical no matter which order she chooses; only the history will be slightly different.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La situación final (snapshot) será la misma, indistintamente del orden elegido; tan solo el historial variará ligeramente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git will move them for the sake of efficiency into a file named `.git/packed-refs` that looks like this:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T132747Z" changeid="juan">
        <seg>En aras de la eficiencia, Git los moverá a un archivo denominado `.git/packed-refs`: </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In the early days of Git (mostly pre 1.5), the user interface was much more complex because it emphasized this filesystem rather than a polished VCS.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T142111Z" changeid="juan">
        <seg>En los primeros tiempos de Git (principalmente antes de la versión 1.5), el interface de usuario era mucho más complejo, ya que se centraba en el sistema de archivos en lugar de en el VCS.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ cp -Rf my_project/.git my_project.git</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ cp -Rf my_project/.git my_project.git</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is the case because the pointer you have for the submodule isn’t what is actually in the submodule directory.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T171731Z" changeid="juan">
        <seg>Siendo esto debido a que el puntero al submódulo que se tiene en este momento  no corresponde a lo que realmente hay en carpeta del submódulo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>#### Enforcing Fast-Forward-Only Pushes ####</seg>
      </tuv>
      <tuv lang="ES">
        <seg>#### Obligando a realizar envios solo-de-avance-rapido (Fast-Forward-Only pushes) ####</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Passing `-p` to it instructs the `cat-file` command to figure out the type of content and display it nicely for you:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Pasandole la opción '-p', puedes indicar al comando 'cat-file' que deduzca el tipo de contenido y te lo muestre adecuadamente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In Git, however, every developer is potentially both a node and a hub — that is, every developer can both contribute code to other repositories and maintain a public repository on which others can base their work and which they can contribute to.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En Git, en cambio, cada desarrollador es potencialmente tanto un nodo como un repositorio --es decir, cada desarrollador puede tanto contribuir a otros repositorios, como servir de repositorio público sobre el que otros desarrolladores pueden basar su trabajo y contribuir a él--.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you create an annotated tag, Git creates a tag object and then writes a reference to point to it rather than directly to the commit.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T112508Z" changeid="juan">
        <seg>Al crear una etiqueta anotativa, Git crea un objeto tipo etiqueta y luego escribe una referencia apuntando a él en lugar de apuntar directamente a una confirmación de cambios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The maintainer of the Git project tends to namespace these branches as well — such as `sc/ruby_client`, where `sc` is short for the person who contributed the work.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La persona gestora del proyecto Git suele tender a nombrar cada rama de foma parecida --por ejemplo 'sc/ruby client', donde sc es la abreviatura para la persona que ha contribuido con ese trabajo--.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The stable branches are farther down the line in your commit history, and the bleeding-edge branches are farther up the history (see Figure 3-18).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Las ramas estables apuntan hacia posiciones más antiguas en el registro de confirmaciones. Mientras que las ramas avanzadas, las que van abriendo camino, apuntan hacia posiciones más recientes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Connection to gitserver closed.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Connection to gitserver closed.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now, you can add content to Git and pull it back out again.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110717T113713Z" changeid="juan">
        <seg>Ahora que sabes cómo añadir contenido a Git y cómo recuperarlo de vuelta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Some Linux distributions have a `gitweb` package that you may be able to install via `apt` or `yum`, so you may want to try that first.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Algunas distribuciones Linux suelen incluir el paquete 'gitweb', y podrás instalarlo a través de las utilidades 'apt' o 'yum'; merece la pena probarlo en primer lugar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Various integration managers are in charge of certain parts of the repository; they’re called lieutenants.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Unos gestores de integración se encargan de partes concretas del repositorio; y se denominan tenientes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To create a branch and switch to it at the same time, you can run the `git checkout` command with the `-b` switch:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para crear una nueva rama y saltar a ella, en un solo paso, puedes utilizar el comando 'git checkout' con la opción '-b':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You stage the changes you want by editing a file and running `git add` on it or `git rm` to a tracked file, and the subsequent `git commit --amend` takes your current staging area and makes it the snapshot for the new commit.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T121822Z" changeid="juan">
        <seg>Se preparan en el área de preparación los archivos deseados; con los comandos `git add` o `git rm`, según corresponda. Y, a continuación, se lanza el comando `git commit --amend`. Este tendrá en cuenta dicha preparación para rehacer la instantánea de archivos en la nueva confirmación de cambios. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To do this, you can figure out which key you want by running `gpg --list-keys`:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para ello, has de seleccionar cada clave que deseas incluir, lanzando el comando 'gpg ---list-keys':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you’re making signed annotated tags (as discussed in Chapter 2), setting your GPG signing key as a configuration setting makes things easier.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si tienes costumbre de firmar tus etiquetas (tal y como se ha visto en el capítulo 2), configurar tu clave de firma GPG puede facilitarte la labor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Author: Scott Chacon &lt;schacon@gmail.com&gt;
	Date:   Thu Dec 11 15:08:43 2008 -0800</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T103006Z" changeid="juan">
        <seg>Author: Scott Chacon &lt;schacon@gmail.com&gt;
	Date:   Thu Dec 11 15:08:43 2008 -0800</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can also use this syntax to see where a branch was some specific amount of time ago.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T102426Z" changeid="juan">
        <seg>Esta misma sintaxis puede emplearse cuando se desea ver dónde estaba una rama en un momento específico en el tiempo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>However, you can inject text into a file when it’s checked out and remove it again before it’s added to a commit.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>De todas formas, es posible inyectar textos en un archivo cuando lo extraemos del repositorio (checkout) y quitarlos de nuevo antes de devolverlo al repositorio (commit).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Rebasing a topic branch off another topic branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Reorganizando una rama puntual fuera de otra rama puntual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Because you only want the `old-file` and `new-file` arguments, you use the wrapper script to pass the ones you need.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Ya que solo necesitarás 'old-file' y 'new-file', puedes utilizar el siguiente script para extraerlos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>test.txt |    1 +
	 1 files changed, 1 insertions(+), 0 deletions(-)</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T180418Z" changeid="juan">
        <seg>test.txt |    1 +
	 1 files changed, 1 insertions(+), 0 deletions(-)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You should feel comfortable creating and switching to new branches, switching between branches and merging local branches together.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>A estas alturas, te sentirás cómodo creando nuevas ramas (branch), saltando (checkout) entre ramas para trabajar y fusionando (merge) ramas entre ellas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Next, access over SSH is secure — all data transfer is encrypted and authenticated.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Además, el acceso a través de SSH es seguro, estando todas las transferencias encriptadas y autentificadas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Your fork of a project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tu bifurcación (fork) de un proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>From the interactive prompt, type `5` or `p` (for patch).</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T213835Z" changeid="juan">
        <seg>En el indicador interactivo se ha de teclear '5' o 'p' (patch).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now it’s time to initialize Gitosis.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y, en este punto, ya podemos inicializar Gitosis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>[POLICY] You do not have access to push to lib/test.rb</seg>
      </tuv>
      <tuv lang="ES">
        <seg>[POLICY] You do not have access to push to lib/test.rb</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Yes, I’m using global variables.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Sí, estoy usando variables globales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In any case, the Git protocol is relatively easy to set up.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En cualquier caso, el protocolo Git es relativamente sencillo de configurar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>What then?</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T185221Z" changeid="juan">
        <seg>¿Y qué sucederia si se diera ese caso?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The tag object is very much like a commit object — it contains a tagger, a date, a message, and a pointer.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T233640Z" changeid="juan">
        <seg>El objeto tipo etiqueta es muy parecido al tipo confirmación de cambios, --contiene un marcador, una fecha, un mensaje y un enlace--.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>remote: Total 3181 (delta 1951), reused 2623 (delta 1603)
	Receiving objects: 100% (3181/3181), 675.42 KiB | 422 KiB/s, done.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T103335Z" changeid="juan">
        <seg>remote: Total 3181 (delta 1951), reused 2623 (delta 1603)
	Receiving objects: 100% (3181/3181), 675.42 KiB | 422 KiB/s, done.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Did you mean this?</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Did you mean this?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>lib/simplegit.rb |    2 +-
	 1 files changed, 1 insertions(+), 1 deletions(-)</seg>
      </tuv>
      <tuv lang="ES">
        <seg>lib/simplegit.rb |    2 +-
	 1 files changed, 1 insertions(+), 1 deletions(-)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>First, you create a 'git' user and a `.ssh` directory for that user.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Comienzas creando un usuario 'git' y una carpeta '.ssh' para él.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You work on your web site and do some commits.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Trabajas en el sitio web y haces algunas confirmaciones de cambios (commits).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Delta compression using 2 threads.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110810T231546Z" changeid="juan">
        <seg>Delta compression using 2 threads.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>That commit is when this file was first added to this project, and those lines have been unchanged since.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T165155Z" changeid="juan">
        <seg>(la confirmación en la que este archivo se incluyó en el proyecto por primera vez). No habiendo sufrido esas líneas ninguna modificación desde entonces.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The beauty of the HTTP or HTTPS protocol is the simplicity of setting it up.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>  Cuya belleza radica en la simplicidad para habilitarlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git filter-branch --tree-filter 'rm -f passwords.txt' HEAD
	Rewrite 6b9b3cf04e7c5686a9cb838c3f36a8cb6a0fc2bd (21/21)
	Ref 'refs/heads/master' was rewritten</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T173612Z" changeid="juan">
        <seg>$ git filter-branch --tree-filter 'rm -f passwords.txt' HEAD
	Rewrite 6b9b3cf04e7c5686a9cb838c3f36a8cb6a0fc2bd (21/21)
	Ref 'refs/heads/master' was rewritten</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>What does that mean?</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T142639Z" changeid="juan">
        <seg>Y eso, ¿qué significa?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0304.png
Figure 3-4.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0304.png
Figura 3-4.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You have your tree object, so you continue walking your commits.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110817T224725Z" changeid="juan">
        <seg>Cuando tengas el objeto árbol, puedes continuar avanzando por las confirmaciones de cambio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git rebase -i HEAD~3</seg>
      </tuv>
      <tuv lang="ES" changedate="20120728T084133Z" changeid="juan">
        <seg>$ git rebase -i HEAD~3</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>#### Other Client Hooks ####</seg>
      </tuv>
      <tuv lang="ES">
        <seg>#### Otros puntos de enganche del lado cliente ####</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You need to check out the `master` branch when you’ve completed the process.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T130557Z" changeid="juan">
        <seg>Ves que es la rama`master` la que has de activar cuando el proceso esté completado. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now that you’ve seen the difficulties of the submodule system, let’s look at an alternate way to solve the same problem.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T172952Z" changeid="juan">
        <seg>Ahora que se han visto las dificultades que se pueden presentar utilizando el sistema de submódulos, es momento de hechar un vistazo a una vía alternativa de atacar esa misma problemática.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>SSH is also an authenticated network protocol; and because it’s ubiquitous, it’s generally easy to set up and use.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Otra ventaja de SSH es el su mecanismo de autentificación, sencillo de habilitar y de usar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you’re merging two branches, Git uses a _recursive_ strategy.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T173046Z" changeid="juan">
        <seg>Si se están fusionando dos ramas, Git suele utilizar la _estategia_recursiva_ (_recursive_ strategy).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## Maintaining a Project ##</seg>
      </tuv>
      <tuv lang="ES">
        <seg>## Gestionando un proyecto ##</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you run `git gc`, you’ll no longer have these files in the `refs` directory.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T092535Z" changeid="juan">
        <seg>Lanzando el comando `git gc`, dejarás de tener esos archivos en la carpeta `refs`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Then, when you switch back, you get an empty `rack` directory.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T172900Z" changeid="juan">
        <seg>Y, cuando se retorne a la rama anterior, se tendrá una carpeta 'rack' vacia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>if !$regex.match(message)
	  puts &quot;[POLICY] Your message is not formatted correctly&quot;
	  exit 1
	end</seg>
      </tuv>
      <tuv lang="ES">
        <seg>if !$regex.match(message)
	  puts &quot;[POLICY] Your message is not formatted correctly&quot;
	  exit 1
	end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It takes no arguments and is run after the patch is applied, so you can use it to inspect the snapshot before making the commit.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>No recibe ningún argumento de entrada y se lanza después de que el parche haya sido aplicado, por lo que puedes utilizarlo para revisar la situación (snapshot) antes de confirmarla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git archive master --prefix='project/' | gzip &gt; `git describe master`.tar.gz
	$ ls *.tar.gz
	v1.6.2-rc1-20-g8c5b85c.tar.gz</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git archive master --prefix='project/' | gzip &gt; `git describe master`.tar.gz
	$ ls *.tar.gz
	v1.6.2-rc1-20-g8c5b85c.tar.gz</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If your public key isn’t on the server, you’ll have to copy it there:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si tu clave pública personal no está en el servidor, la has de copiar a él:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can start up interactive Ruby mode with the `irb` command:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T180939Z" changeid="juan">
        <seg>Puedes arrancar el modo interactivo de Ruby con el comando `irb`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To begin, she starts a new feature branch, basing it off the server’s `master` branch:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para empezar, arranca una nueva rama puntual, basada en la rama 'master' del servidor:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## Setting Up the Server ##</seg>
      </tuv>
      <tuv lang="ES">
        <seg>## Preparando el servidor ##</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git clone ssh://user@server/project.git</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git clone ssh://user@server/project.git</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>At this point, your project working directory is exactly the way it was before you started working on issue #53, and you can concentrate on your hotfix.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tras esto, tendrás la carpeta de trabajo exactamente igual a como estaba antes de comenzar a trabajar sobre el problema #53. Y podrás concentrarte en el nuevo problema urgente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For instance, to see where your `master` branch was yesterday, you can type</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T085836Z" changeid="juan">
        <seg>Por ejemplo, para ver dónde apuntaba la rama 'master' en el día de ayer, se puede teclear:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Congratulations on being an effective Git developer!</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Felicidades por haber llegado a ser un desarrollador Git efectivo!.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You have to change the path to the ACL file from this</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto obliga a cambiar la ubicación del archivo ACL de</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ vim test.rb
	$ git commit -a -m 'made a change'</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ vim test.rb
	$ git commit -a -m 'made a change'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>That way, the maintainer doesn’t have to do any integration work — just a fast-forward or a clean apply.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>De esta forma, la persona que mantiene el proyecto no necesitará hacer ninguna integración con tu trabajo; le bastará con un avance rápido o una incorporación limpia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Reordering Commits ###</seg>
      </tuv>
      <tuv lang="ES" changedate="20120728T090651Z" changeid="juan">
        <seg>### Reordenar confirmaciones de cambios ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The next variable is the workflow in use for the project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La segunda variable es la forma de trabajo que se utilice para el proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Because you don’t have the permissions to directly update branches on the project, you have to get the work to the maintainers some other way.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Ya que no tendrás permisos para actualizar ramas directamente sobre el proyecto, has de enviar el trabajo a los gestores de otra manera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>(I’m replacing the protocol messages with `...` in these examples to shorten them somewhat.)</seg>
      </tuv>
      <tuv lang="ES">
        <seg>(en estos ejemplos estoy sustituyendo los mensajes del protocolo con '...' , para acortarlos)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You’re likely to have to either include this code from a shared library like a CPAN install or Ruby gem, or copy the source code into your own project tree.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T084805Z" changeid="juan">
        <seg>Y dicha biblioteca se incluye desde una biblioteca compartida tal como CPAN install o Ruby gem; o copiando directamente su código fuente en el árbol del propio proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git checkout -b sf origin/serverfix
	Branch sf set up to track remote branch refs/remotes/origin/serverfix.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git checkout -b sf origin/serverfix
	Branch sf set up to track remote branch refs/remotes/origin/serverfix.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You regularly push both of these branches to the public repository.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Ambas ramas se enviarán periodicamente al repositorio público.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The dictator pushes their master to the reference repository so the other developers can rebase on it.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El dictador envia (push) su rama master al repositorio de referencia, para permitir que los desarrolladores reorganicen (rebase) desde ella.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can go into that subdirectory, make changes, add your own writable remote repository to push your changes into, fetch and merge from the original repository, and more.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T103611Z" changeid="juan">
        <seg>En dicha subcarpeta es posible realizar cambios, añadir un repositorio propio a donde enviar (push) los cambios, recuperar (fetch) y fusionar (merge) desde el repositorio original, y mucho mas...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git allows you to specify specific commits or a range of commits in several ways.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T095019Z" changeid="juan">
        <seg>Git tiene varios modos de seleccionar confirmaciones de cambio o grupos de confirmaciones de cambio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>modified repo a bit</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T143336Z" changeid="juan">
        <seg>modified repo a bit</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>[group mobile_committers]
	members = scott josie jessica</seg>
      </tuv>
      <tuv lang="ES">
        <seg>[group mobile_committers]
	members = scott josie jessica</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ echo '# testing' &gt;&gt; repo.rb
	$ git commit -am 'modified repo a bit'
	[master ab1afef] modified repo a bit
	 1 files changed, 1 insertions(+), 0 deletions(-)</seg>
      </tuv>
      <tuv lang="ES" changedate="20110810T230539Z" changeid="juan">
        <seg>$ echo '# testing' &gt;&gt; repo.rb
	$ git commit -am 'modified repo a bit'
	[master ab1afef] modified repo a bit
	 1 files changed, 1 insertions(+), 0 deletions(-)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Lines starting
	# with '#' will be ignored, and an empty message aborts the commit.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Lines starting
	# with '#' will be ignored, and an empty message aborts the commit.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git log --pretty=format:'%h %s' --graph
	* 734713b fixed refs handling, added gc auto, updated tests
	*   d921970 Merge commit 'phedders/rdocs'
	|\
	| * 35cfb2b Some rdoc changes
	* | 1c002dd added some blame and merge stuff
	|/
	* 1c36188 ignore *.gem
	* 9b29157 add open3_detach to gemspec file list</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T113803Z" changeid="juan">
        <seg>$ git log --pretty=format:'%h %s' --graph
	* 734713b fixed refs handling, added gc auto, updated tests
	*   d921970 Merge commit 'phedders/rdocs'
	|\
	| * 35cfb2b Some rdoc changes
	* | 1c002dd added some blame and merge stuff
	|/
	* 1c36188 ignore *.gem
	* 9b29157 add open3_detach to gemspec file list</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The apply option only tries to apply the stashed work — you continue to have it on your stack.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T093950Z" changeid="juan">
        <seg>Los comandos `git stash apply` tan solo recuperan cambios almacenados en la pila de guardado rápido, sin afectar al estado de la pila. Es decir, los cambios siguen estando guardados en la pila.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You’ll often want to do two basic things to your last commit: change the commit message, or change the snapshot you just recorded by adding, changing and removing files.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120728T080207Z" changeid="juan">
        <seg>Dos suelen ser los cambios básicos a realizar: cambiar el mensaje o cambiar los archivos añadidos, modificados o borrados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Notice that the first field is the partial SHA-1 of the commit that last modified that line.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120827T143942Z" changeid="juan">
        <seg>Merece destacar que el primer campo mostrado en cada línea es el código SHA-1 parcial de la confirmación de cambios en que se modificó dicha línea por última vez.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is a bit of a shortcut.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto es un poco como un atajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## Hosted Git ##</seg>
      </tuv>
      <tuv lang="ES">
        <seg>## Git en un alojamiento externo ##</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>So far, I’ve covered the basics of how Git works and how to use it, and I’ve introduced a number of tools that Git provides to help you use it easily and efficiently.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Hasta ahora, hemos visto los aspectos básicos del funcionamiento de Git y la manera de utilizarlo; además de haber presentado una serie de herramientas suministradas con Git para ayudarnos a usarlo de manera sencilla y eficiente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>After your super-important fix is deployed, you’re ready to switch back to the work you were doing before you were interrupted.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tras haber resuelto el problema urgente que te habia interrumpido tu trabajo, puedes volver a donde estabas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In addition to knowing how to effectively contribute to a project, you’ll likely need to know how to maintain one.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Además de conocer cómo contribuir de forma efectiva a un proyecto, es posible que desees saber tambien cómo mantener uno.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Also, as long as you stay out of contact with your origin server, your `origin/master` pointer doesn’t move (see Figure 3-23).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Además, mientras no tengas contacto con el servidor, tu apuntador a tu rama 'origin/master' no se moverá (ver Figura 3/23).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git diff master</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git diff master</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git clone git://git.kernel.org/pub/scm/git/git.git
	$ cd git/
	$ make GITWEB_PROJECTROOT=&quot;/opt/git&quot; \
	        prefix=/usr gitweb/gitweb.cgi
	$ sudo cp -Rf gitweb /var/www/</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git clone git://git.kernel.org/pub/scm/git/git.git
	$ cd git/
	$ make GITWEB_PROJECTROOT=&quot;/opt/git&quot; \
	        prefix=/usr gitweb/gitweb.cgi
	$ sudo cp -Rf gitweb /var/www/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Perhaps your main branch has diverged too far from the branch the patch was built from, or the patch depends on another patch you haven’t applied yet.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Es posible que tu rama principal diverja demasiado respecto de la rama sobre la que se construyó el parche; o que el parche tenga dependencias respecto de algún otro parche anterior que aún no hayas incorporado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In this scenario, you have two long-running branches, `master` and `develop`, in which you determine that `master` is updated only when a very stable release is cut and all new code is integrated into the `develop` branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En este escenario, se dispone de dos ramas de largo recorrido: 'master' y 'develop'. La primera de ellas, 'master', será actualizada únicamente por los lanzamientos de código muy estable. La segunda rama, 'develop', es donde iremos integrando todo el código nuevo. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Because it’s reachable from the history, it will always be there.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T134324Z" changeid="juan">
        <seg>Porque en algún momento formó parte del proyecto, siempre permanecerá ahí.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Suppose you decide that you want to merge your client-side changes into your mainline for a release, but you want to hold off on the server-side changes until it’s tested further.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Imagina que decides incorporar tus cambios de la parte cliente sobre el proyecto principal, para hacer un lanzamiento de versión; pero no quieres lanzar aún los cambios de la parte server porque no están aún suficientemente probados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git gc
	Counting objects: 17, done.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110810T231543Z" changeid="juan">
        <seg>$ git gc
	Counting objects: 17, done.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git will detect these issues when you run a `git diff` command and try to color them so you can possibly fix them before you commit.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Git detectará posibles problemas cuando lance un comando 'git diff', e intentará destacarlos en otro color para que puedas corregirlos antes de confirmar cambios (commit).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The next line is 0000, meaning the server is done with its references listing.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T074133Z" changeid="juan">
        <seg>Y la última linea comienza con 0000, indicando así que la lista de referencias ha terminado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When you land on a project page that looks interesting and you want to hack on it a bit, you can click the &quot;fork&quot; button in the project header to have GitHub copy that project to your user so you can push to it.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cuando aterrizas en la página de un proyecto que te parece interesante y con el que deseas trastear un poco, puedes clicar sobre el botón &quot;fork&quot; de la cabecera del proyecto; de tal forma que GitHub haga una copia del proyecto a tu cuenta de usuario y puedas así enviar (push) cambios sobre él.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can also specify a number after the `^` — for example, `d921970^2` means &quot;the second parent of d921970.&quot; This syntax is only useful for merge commits, which have more than one parent.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T085914Z" changeid="juan">
        <seg>También es posible indicar un número detras de '^'. Por ejemplo `d921970^2`, para indicar &quot;el segundo padre de d921970&quot; . Aunque esta sentencia es útil tan solo en confirmaciones de fusiones (merge), los únicos tipos de confirmación de cambios que pueden tener más de un padre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Your change is now in the snapshot of the commit pointed to by the `master` branch, and you can deploy your change (see Figure 3-14).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Ahora, los cambios realizados están ya en la instantánea (snapshot) de la confirmación (commit) apuntada por la rama 'master'. Y puedes desplegarlos (ver Figura 3-14)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Private Managed Team ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Grupo Privado Gestionado ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The committing-workflow client-side scripts can be used in just about any workflow.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Los scripts del lado cliente relacionados con la confirmación de cambios pueden ser utilizados en prácticamente cualquier flujo de trabajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git lets you put the string `$Format:$` in any file with any of the `--pretty=format` formatting shortcodes, many of which you saw in Chapter 2.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Git te permite poner la cadena '$Format:$' en cualquier archivo, con cualquiera de las claves de formateo de '--pretty=format' que vimos en el capítulo 2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git commit -am 'small tweak'
	[featureA ed774b3] small tweak
	 1 files changed, 1 insertions(+), 1 deletions(-)
	$ git push origin featureA
	...
	To jessica@githost:simplegit.git
	   3300904..ed774b3  featureA -&gt; featureA</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git commit -am 'small tweak'
	[featureA ed774b3] small tweak
	 1 files changed, 1 insertions(+), 1 deletions(-)
	$ git push origin featureA
	...
	To jessica@githost:simplegit.git
	   3300904..ed774b3  featureA -&gt; featureA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The answer is the HEAD file.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T192056Z" changeid="juan">
        <seg>La respuesta a esta pregunta es el archivo HEAD (CABEZA).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ ssh -x git@github.com &quot;git-upload-pack 'schacon/simplegit-progit.git'&quot;</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T080002Z" changeid="juan">
        <seg>$ ssh -x git@github.com &quot;git-upload-pack 'schacon/simplegit-progit.git'&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>I’ll cover aspects of each of these in a series of use cases, moving from simple to more complex; you should be able to construct the specific workflows you need in practice from these examples.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Vamos a cubrir ciertos aspectos de todo esto, en una serie de casos de uso; desde los más sencillos hasta los más complejos. A partir de dichos ejemplos, tendrías que ser capaz de construir la forma de trabajo específica que necesites para cada caso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now Jessica merges in John’s work (`origin/master`):</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tras esto, jessica fusiona el trabajo de John ('origin/master'):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If anyone wants to verify a tag, they can directly import your PGP key by pulling the blob directly out of the database and importing it into GPG:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cualquiera que desee verificar la autenticidad de una etiqueta, no tiene más que importar tu clave PGP, sacando el objecto directamente de la base de datos e importandolo en GPG:, </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git push origin :serverfix
	To git@github.com:schacon/simplegit.git
	 - [deleted]         serverfix</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git push origin :serverfix
	To git@github.com:schacon/simplegit.git
	 - [deleted]         serverfix</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Finally, you don’t need to be in interactive add mode to do the partial-file staging — you can start the same script by using `git add -p` or `git add --patch` on the command line.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120712T202202Z" changeid="juan">
        <seg>Por último, cabe comentar que no es necesario entrar expresamente en el modo interactivo para preparar archivos parcialmente. También se puede acceder a ese script con los comandos 'git add -p' o con 'git add --patch', directamente desde la línea de comandos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>updated the gemspec to hopefully work better</seg>
      </tuv>
      <tuv lang="ES">
        <seg>updated the gemspec to hopefully work better</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>First, you don’t want to submit any whitespace errors.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En primer lugar, no querrás enviar ningún error de espaciado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can exclude commits in the master branch by adding the `--not` option before the branch name.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes excluir de la lista las confirmaciones de tu rama principal añadiendo la opción '--not' delante del nombre de la rama.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If, instead of &quot;pick&quot; or &quot;edit&quot;, you specify &quot;squash&quot;, Git applies both that change and the change directly before it and makes you merge the commit messages together.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T190027Z" changeid="juan">
        <seg>Si, en lugar de 'pick' o de 'edit', se indica 'squash' delante de alguna de las confirmaciones de cambio, Git aplicará simultáneamente dicha confirmación y la que esté inmediatamente delante de ella.  Permitiendo también combinar los mensajes de ambas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In the 1.6 series of Git, you can also use a macro that is provided that means `-crlf -diff`:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>A partir de la versión 1.6 de Git, puedes utilizar una macro en lugar de las dos opciones '-crlf -diff':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The “smudge” filter is run on checkout.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El filtro &quot;smudge&quot; se usa al extraer (checkout).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You’re looking for any commit that is reachable from the last commit on the remote and that isn’t reachable from any parent of any of the SHAs you’re trying to push up — meaning it’s a fast-forward.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Estas mirando por cualquier confirmación que se pueda alcanzar desde la última en la parte remota, pero que no se pueda alcanzar desde ninguno de los padres de cualquiera de las claves SHA que estás intentando enviar. Es decir, confirmaciones de avance-rápido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This command shows you only the work your current topic branch has introduced since its common ancestor with master.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Este comando mostrará únicamente el trabajo en tu actual rama puntual que haya sido introducido a partir de su ancestro común con la rama 'master'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git clone (url)
	$ cd project
	$ git checkout -b featureA
	$ (work)
	$ git commit
	$ (work)
	$ git commit</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git clone (url)
	$ cd project
	$ git checkout -b featureA
	$ (work)
	$ git commit
	$ (work)
	$ git commit</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Your working directory is clean:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120712T202700Z" changeid="juan">
        <seg>Con ello, se limpia el área de trabajo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When your work has been pushed up to your fork, you need to notify the maintainer.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tras enviar (push) tu trabajo a tu copia bifurcada (fork), has de notificarselo al gestor del proyecto. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>So, in the following file</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Poniendo en el siguiente archivo: </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To begin, you should check your commit message just before each commit is recorded, so you know the server won’t reject your changes due to badly formatted commit messages.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para empezar, se necesita chequear el mensaje de confirmación inmediatamente antes de cada confirmación de cambios, para segurarse de que el servidor no los rechazará debido a un mensaje mal formateado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is common if you’re coming from CVS or Subversion, where you’ve defined a module or collection of subdirectories, and you want to keep this type of workflow.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T172204Z" changeid="juan">
        <seg>Se da frecuentemente en equipos procedentes de CVS o de Subversion (donde se define una colección de módulos o carpetas), cuando desean mantener ese mismo tipo de flujo de trabajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Here’s an example.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T083813Z" changeid="juan">
        <seg>Un ejemplo concreto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The whole method looks like this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El método completo será algo así como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To e-mail this to a mailing list, you can either paste the file into your e-mail program or send it via a command-line program.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para enviar estos archivos a la lista de correo,puedes tanto pegar directamente el archivo en tu programa de correo electrónico, como enviarlo a través de algún programa basado en línea de comandos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ vim lib/simplegit.rb
	$ git commit -am 'made the ls-tree function recursive'
	[featureB e5b0fdc] made the ls-tree function recursive
	 1 files changed, 1 insertions(+), 1 deletions(-)
	$ vim lib/simplegit.rb
	$ git commit -am 'add ls-files'
	[featureB 8512791] add ls-files
	 1 files changed, 5 insertions(+), 0 deletions(-)</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ vim lib/simplegit.rb
	$ git commit -am 'made the ls-tree function recursive'
	[featureB e5b0fdc] made the ls-tree function recursive
	 1 files changed, 1 insertions(+), 1 deletions(-)
	$ vim lib/simplegit.rb
	$ git commit -am 'add ls-files'
	[featureB 8512791] add ls-files
	 1 files changed, 5 insertions(+), 0 deletions(-)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Then, you can send a request to the maintainer of the main project to pull in your changes.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Después, enviarás una petición a la persona gestora del proyecto principal, para que recupere y consolide (pull) en él tus cambios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git config --system receive.denyNonFastForwards true</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git config --system receive.denyNonFastForwards true</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git show d921970^
	commit 1c002dd4b536e7479fe34593e72e6c6c1819e53b
	Author: Scott Chacon &lt;schacon@gmail.com&gt;
	Date:   Thu Dec 11 14:58:32 2008 -0800</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T114308Z" changeid="juan">
        <seg>$ git show d921970^
	commit 1c002dd4b536e7479fe34593e72e6c6c1819e53b
	Author: Scott Chacon &lt;schacon@gmail.com&gt;
	Date:   Thu Dec 11 14:58:32 2008 -0800</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can’t record a submodule at `master` or some other symbolic reference.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T104843Z" changeid="juan">
        <seg>No es posible almacenar un submódulo en `master` o en cualquier otra referencia simbólica.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>So, to create a tree object, you first have to set up an index by staging some files.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110801T121920Z" changeid="juan">
        <seg>Por tanto, para crear un objeto árbol, previamente has de crear un índice preparando algunos archivos para ser almacenados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For the sake of simplicity we’ll simply run it as the same 'git' user that Gitosis is running as.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para simplificar, en estos ejemplos vamos a lanzar el demonio Git bajo el mismo usuario 'git' con el que hemos lanzado Gitosis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Some people have full access, and others only have access to push changes to certain subdirectories or specific files.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Algunas personas tendrán acceso completo, y otras tan solo acceso a ciertas carpetas o a ciertos archivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git status
	# On branch master
	# Changes to be committed:
	#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)
	#
	#	modified:   index.html
	#</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git status
	# On branch master
	# Changes to be committed:
	#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)
	#
	#	modified:   index.html
	#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git checkout experiment
	$ git rebase master
	First, rewinding head to replay your work on top of it...
	Applying: added staged command</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git checkout experiment
	$ git rebase master
	First, rewinding head to replay your work on top of it...
	Applying: added staged command</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can also create a zip archive in much the same way, but by passing the `--format=zip` option to `git archive`:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>También puedes crear un archivo zip de la misma manera, tan solo indicando la opción '--format=zip' al comando 'git archive':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ rm text.txt
	$ git checkout -- text.txt
	$ cat test.txt
	$Id: 42812b7653c7b88933f8a9d6cad0ca16714b9bb3 $</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ rm text.txt
	$ git checkout -- text.txt
	$ cat test.txt
	$Id: 42812b7653c7b88933f8a9d6cad0ca16714b9bb3 $</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>History after cherry-picking a commit on a topic branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Historial tras entresacar una confirmación de cambios de una rama puntual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It’s almost identical to running a `patch -p1` command to apply the patch, although it’s more paranoid and accepts fewer fuzzy matches then patch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Es prácticamente idéntico a lanzar el comando 'patch -p1', aunque es más paranoico y acepta menos coincidencias aproximadas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can enable push access; but given the lack of authentication, if you turn on push access, anyone on the internet who finds your project’s URL could push to your project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Aunque realmente si que puedes habilitar el envio, si lo haces, dada la total falta de ningún mecanismo de autentificación, cualquiera que encuentre la URL a tu proyecto en Internet, podrá enviar (push) contenidos a él.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>These protocols have a process on the remote end that is intelligent about Git — it can read local data and figure out what the client has or needs and generate custom data for it.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T131519Z" changeid="juan">
        <seg>Estos protocolos suelen tener procesos en el lado remoto y conocen acerca de la estructura de datos Git en ese lado, --pueden leer datos localmente y determinar lo que el cliente tiene ya o necesita a continuación, para generar automáticamente datos expresamente preparados para él--.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To do that, you must run the `git stash apply` command with a `--index` option to tell the command to try to reapply the staged changes.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T093826Z" changeid="juan">
        <seg>Para conseguir esto último, es necesario emplear la opción `--index` del comando `git stash apply`. Con ella se le indica que debe intentar reaplicar también el estado de preparación de los archivos. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>:040000 040000 40ee3e7821b895e52c1695092db9bdc4c61d1730
	f24d3c6ebcfc639b1a3814550e62d60b8e68a8e4 M  config</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T072733Z" changeid="juan">
        <seg>:040000 040000 40ee3e7821b895e52c1695092db9bdc4c61d1730
	f24d3c6ebcfc639b1a3814550e62d60b8e68a8e4 M  config</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>After two more commits, your history might look something like Figure 3-2.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tras un par de confirmaciones más, el registro ha de ser algo parecido a la Figura 3-2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>#### core.autocrlf ####</seg>
      </tuv>
      <tuv lang="ES">
        <seg>#### core.autocrlf ####</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You’ll follow these steps:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Imagina que sigues los siquientes pasos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you run `git checkout test`, Git updates the file to look like this:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T201903Z" changeid="juan">
        <seg>Si lanzas el comando `git checkout test`, Git actualiza el contenido del archivo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Suppose your repository contains the following branches and tags:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T092441Z" changeid="juan">
        <seg>Por ejemplo, suponiendo que tienes las siguientes ramas y etiquetas en tu repositorio:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>`HEAD~2` means &quot;the first parent of the first parent,&quot; or &quot;the grandparent&quot; — it traverses the first parents the number of times you specify.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T114558Z" changeid="juan">
        <seg>`HEAD~2` significa &quot;el primer padre del primer padre&quot;, es decir, &quot;el abuelo&quot;. Y así según el número de veces que se indique.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The idea of the subtree merge is that you have two projects, and one of the projects maps to a subdirectory of the other one and vice versa.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T173135Z" changeid="juan">
        <seg>La idea subyacente tras toda fusión subarborea es la de que se tienen dos proyectos; y uno de ellos está relacionado con una subcarpeta en el otro, y viceversa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can run something like `git log 1a410e` to look through your whole history, but you still have to remember that `1a410e` is the last commit in order to walk that history to find all those objects.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T145953Z" changeid="juan">
        <seg>Puedes utilizar algo así como `git log 1a410e` para hechar un vistazo a lo largo de toda tu historia, recorriendola y encontrando todos tus objetos. Pero para ello has necesitado recordar que la última confirmación de cambios es `1a410e`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is often used if everyone on your team has access to a shared filesystem such as an NFS mount, or in the less likely case that everyone logs in to the same computer.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Se utiliza habitualmente cuando todos los miembros del equipo tienen acceso a un mismo sistema de archivos, como por ejemplo un punto de montaje NFS, o en los casos en que todos se conectan al mismo ordenador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Total 15 (delta 5), reused 0 (delta 0)
	To git@github.com:schacon/simplegit.git
	 * [new branch]      serverfix -&gt; serverfix</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Total 15 (delta 5), reused 0 (delta 0)
	To git@github.com:schacon/simplegit.git
	 * [new branch]      serverfix -&gt; serverfix</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git log origin/master..HEAD</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T120819Z" changeid="juan">
        <seg>$ git log origin/master..HEAD</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now you can switch back to your work-in-progress branch on issue #53 and continue working on it (see Figure 3-15):</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y, con esto, ya estas dispuesto para regresar al trabajo sobre el problema #53 (ver Figura 3-15):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>#
	# Commands:
	#  p, pick = use commit
	#  e, edit = use commit, but stop for amending
	#  s, squash = use commit, but meld into previous commit
	#
	# If you remove a line here THAT COMMIT WILL BE LOST.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120728T091345Z" changeid="juan">
        <seg>#
	# Commands:
	#  p, pick = use commit
	#  e, edit = use commit, but stop for amending
	#  s, squash = use commit, but meld into previous commit
	#
	# If you remove a line here THAT COMMIT WILL BE LOST.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Then, John, Josie, or Jessica can push the first version of their project into that repository by adding it as a remote and pushing up a branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y John, Josie o Jessica podrán enviar (push) la primera versión de su proyecto a dicho repositorio, añadiendolo como remoto y enviando (push) una rama (branch).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0703.png
Figure 7-3.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0703.png
Figura 7-3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>However, because no alternates are listed in this case, your object must be in a packfile.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110817T223851Z" changeid="juan">
        <seg>Pero, en este caso, no hay altenativas. Por lo que el objeto debe encontrarse dentro de un empaquetado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For example, to see a specific commit, suppose you run a `git log` command and identify the commit where you added certain functionality:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120712T195329Z" changeid="juan">
        <seg>Por ejemplo, a la hora de localizar una confirmación de cambios, supongamos que se lanza el comando 'git log' e intentamos localizar la confirmación de cambios concreta donde se añadió una cierta funcionalidad: </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Creating a new branch is as quick and simple as writing 41 bytes to a file (40 characters and a newline).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Crear una nueva rama es tan rápido y simple como escribir 41 bytes en un archivo, (40 caracteres y un retorno de carro).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can also run something like `make` or `make tests` or whatever you have that runs automated tests for you.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T075516Z" changeid="juan">
        <seg>También se puede emplear algo como `make` o como `make tests` o cualquier otro método que se tenga para lanzar pruebas automatizadas sobre el sistema.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The useful `--merged` and `--no-merged` options have been available in Git since version 1.5.6 for this purpose.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para ello, Git dispone, desde la versión 1.5.6, las opciones '--merged' y '--no-merged'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Because hooks aren’t transferred with a clone of a project, you must distribute these scripts some other way and then have your users copy them to their `.git/hooks` directory and make them executable.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Debido a que estos enganches no se transfieren junto con el clonado de un proyecto, tendrás que distribuirlos de alguna otra manera. Y luego pedir a tus usuarios que se los copien a sus carpetas '.git/hooks' y los hagan ejecutables.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If the maintainers merge, rebase, or cherry-pick your work, you’ll eventually get it back via pulling from their repository anyhow:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si el gestor del proyecto fusiona (merge), reorganiza (rebase) o integra solo parcialmente tu trabajo, aún podrás recuperarlo de vuelta a través de su repositorio:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When that is committed and pushed up, your running daemon should start serving requests for the project to anyone who has access to port 9418 on your server.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cuando confirmes (commit) y envies (push) estos cambios, el demonio que está en marcha en el servidor comenzará a responder a peticiones de cualquiera que solicite dicho proyecto a través del puerto 9418 de tu servidor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ ssh git@gitserver
	fatal: What do you think I am?</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ ssh git@gitserver
	fatal: What do you think I am?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When a topic branch has finally been merged into `master`, it’s removed from the repository.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Una rama puntual se borra del repositorio cuando, finalmente, es fusionada en la rama 'master'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0523.png
Figure 5-23.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0523.png
Figura 5-23.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## The Refspec ##</seg>
      </tuv>
      <tuv lang="ES" changedate="20110815T215157Z" changeid="juan">
        <seg>## Las especificaciones para hacer referencia a...  (refspec) ##</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>HEAD file pointing to the branch you’re on.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Apuntador HEAD a la rama donde estás actualmente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If some of the changes modify the same file, try to use `git add --patch` to partially stage files (covered in detail in Chapter 6).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si algunos de los cambios modifican un mismo archivo, utiliza el comando 'git add --patch' para almacenar parcialmente los archivos (tal y como se verá detalladamente en el Capítulo 6).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Object Storage ###</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T180634Z" changeid="juan">
        <seg>### Almacenamiento de los objetos ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now, `gc` your database and see how much space you’re using:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T134723Z" changeid="juan">
        <seg>Ahora, puedes limpiar `gc` tu base de datos y comprobar cuánto espacio estás ocupando:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git push origin featureB:featureBee
	...
	To jessica@githost:simplegit.git
	   fba9af8..cd685d1  featureB -&gt; featureBee</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git push origin featureB:featureBee
	...
	To jessica@githost:simplegit.git
	   fba9af8..cd685d1  featureB -&gt; featureBee</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>First, the ACL file is in a different place, because this script runs from your working directory, not from your Git directory.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La primera es que el archivo ACL está en otra ubicación, debido a que el script corre desde tu carpeta de trabajo y no desde la carpeta de Git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git log origin/master
	$ git log remotes/origin/master
	$ git log refs/remotes/origin/master</seg>
      </tuv>
      <tuv lang="ES" changedate="20110815T220258Z" changeid="juan">
        <seg>$ git log origin/master
	$ git log remotes/origin/master
	$ git log refs/remotes/origin/master</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To pull the `master` branch on the remote down to `origin/mymaster` locally, you can run</seg>
      </tuv>
      <tuv lang="ES" changedate="20110815T220916Z" changeid="juan">
        <seg>Para recuperar la rama `master` del servidor remoto a tu rama `origin/mymaster` local, puedes lanzar el comando  </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0333.png
Figure 3-33.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0333.png
Figura 3-33.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git branch iss53
	$ git checkout iss53</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git branch iss53
	$ git checkout iss53</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>+    @git_dir = File.expand_path(git_dir)XX
	lib/simplegit.rb:7: trailing whitespace.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>+    @git_dir = File.expand_path(git_dir)XX
	lib/simplegit.rb:7: trailing whitespace.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>=&gt; GET info/refs
	ca82a6dff817ec66f44342007202690a93763949     refs/heads/master</seg>
      </tuv>
      <tuv lang="ES" changedate="20110817T155730Z" changeid="juan">
        <seg>=&gt; GET info/refs
	ca82a6dff817ec66f44342007202690a93763949     refs/heads/master</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It must run its own daemon, which is custom — we’ll look at setting one up in the “Gitosis” section of this chapter — it requires `xinetd` configuration or the like, which isn’t always a walk in the park.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Necesita activar su propio demonio, (tal y como se explica en la sección &quot;Gitosis&quot;, más adelante, en este capítulo); y necesita configurar 'xinetd' o similar, lo cual no suele estar siempre disponible en el sistema donde estés trabajando.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>commit d921970aadf03b3cf0e71becdaab3147ba71cdef
	Reflog: master@{1} (Scott Chacon &lt;schacon@gmail.com&gt;)
	Reflog message: merge phedders/rdocs: Merge made by recursive.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T103003Z" changeid="juan">
        <seg>commit d921970aadf03b3cf0e71becdaab3147ba71cdef
	Reflog: master@{1} (Scott Chacon &lt;schacon@gmail.com&gt;)
	Reflog message: merge phedders/rdocs: Merge made by recursive.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is generally good policy; but in the case of the rebase, you may determine that you know what you’re doing and can force-update the remote branch with a `-f` flag to your push command.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Habitualmente, este es el comportamiento más adecuado. Pero, en el caso de las reorganizaciones, cuando estás totalmente seguro de lo que haces, puedes forzar el envio, utilizando la opción '-f' en el comando 'git push' a la rama remota.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## Distributed Workflows ##</seg>
      </tuv>
      <tuv lang="ES">
        <seg>## Flujos de trabajo distribuidos ##</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In addition, each of these has subsettings you can use to set specific colors for parts of the output, if you want to override each color.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Además, cada uno de ellos tiene parámetros adiccionales para asignar colores a partes específicas, por si quieres precisar aún más.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Resolving deltas: 100% (1951/1951), done.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T105825Z" changeid="juan">
        <seg>Resolving deltas: 100% (1951/1951), done.Resolving deltas: 100% (1951/1951), done.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The maintainer pushes merged changes to the main repository.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La gestora envia (push) los cambios fusionados al repositorio principal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can accomplish the same task with `--tree-filter` if you want.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T134044Z" changeid="juan">
        <seg>Aunque también puedes hacer lo mismo con la opción`--tree-filter`, si así lo prefieres. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Local Protocol ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Procolo Local ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Run `git push (remote) (branch)`:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Con el comando 'git push (remoto) (rama)':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Notice that you printed that out to stdout at the very beginning of your update script.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Precisamente, lo enviado a la salida estandar stdout justo al principio del script de actualización.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Looking at your Git status again, you can see that you’ve unstaged the TODO file:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T213027Z" changeid="juan">
        <seg>Volviendo a mirar el estado de Git, se comprueba que se ha sacado el archivo TODO del área de preparación:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Furthermore, if the ref marker isn’t there in any of your commits, you’ll see the error message you’re printing out for that.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Es más, si la referencia (ref marker) no se encuentra presente para alguna de las confirmaciones de cambio, verás el mensaje de error previsto para ello:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0326.png
Figure 3-26.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0326.png
Figura 3-26.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>John’s repository after merging origin/master.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El repositorio de John tras fusionar origin/master.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The update script is very similar to the `pre-receive` script, except that it’s run once for each branch the pusher is trying to update.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El punto de enganche 'update' es muy similar a 'pre-receive', pero con la diferencia de que se activa una vez por cada rama que se está intentando actualizar con el envio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git tag -s &lt;tag-name&gt;</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git tag -s &lt;tag-name&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This resolution has a little of each section, and I’ve fully removed the `&lt;&lt;&lt;&lt;&lt;&lt;&lt;`, `=======`, and `&gt;&gt;&gt;&gt;&gt;&gt;&gt;` lines.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esta corrección contiene un poco de ambas partes. Y se han eliminado completamente las líneas `&lt;&lt;&lt;&lt;&lt;&lt;&lt;` , `=======` y `&gt;&gt;&gt;&gt;&gt;&gt;&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In this particular case, we’re using the `/var/www/htdocs` path that is common for Apache setups, but you can use any static web server — just put the bare repository in its path.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En este caso particular, estamos usando el camino '/var/www/htdocs', habitual en las configuraciones de Apache. Pero puedes utilizar cualquier servidor web estático, sin más que poner el repositorio en su camino.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Your first challenge is to enforce that each commit message must adhere to a particular format.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tu primer reto es asegurarte que todos y cada uno de los mensajes de confirmación de cambios se ajustan a un determinado formato.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The next type you’ll look at is the tree object, which solves the problem of storing the filename and also allows you to store a group of files together.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T143800Z" changeid="juan">
        <seg>El siguiente tipo de objeto a revisar serán los objetos tipo arbol. Estos se encargan de resolver el problema de guardar un nombre de archivo, a la par que guardamos conjuntamente un grupo de archivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you pass `--abbrev-commit` to the `git log` command, the output will use shorter values but keep them unique; it defaults to using seven characters but makes them longer if necessary to keep the SHA-1 unambiguous:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T184958Z" changeid="juan">
        <seg>Con la opción '--abbrev-commit' del comando 'git log', en su salida se mostrarán valores acortados, pero únicos de SHA. Habitualmente suelen resultar valores de siete caracteres, pero alguno puede ser más largo si es necesario para preservar la unicidad de todos los valores SHA-1 mostrados:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git reflog
	1a410ef HEAD@{0}: 1a410efbd13591db07496601ebc7a059dd55cfe9: updating HEAD
	ab1afef HEAD@{1}: ab1afef80fac8e34258ff41fc1b867c702daa24b: updating HEAD</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T143116Z" changeid="juan">
        <seg>$ git reflog
	1a410ef HEAD@{0}: 1a410efbd13591db07496601ebc7a059dd55cfe9: updating HEAD
	ab1afef HEAD@{1}: ab1afef80fac8e34258ff41fc1b867c702daa24b: updating HEAD</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you place a `^` at the end of a reference, Git resolves it to mean the parent of that commit.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T113742Z" changeid="juan">
        <seg>Colocando un '^' al final de una referencia, Git interpreta que se refiere al padre de dicha referencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Running this command gives you a list of commits in your text editor that looks something like this:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120728T084602Z" changeid="juan">
        <seg>Al lanzar este comando, se verán una lista de confirmaciones de cambio en la pantalla del editor de textos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you can find or write a Word-to-plain-text converter that works well enough, that solution will likely be incredibly effective.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si pudieras encontrar o escribir un conversor suficientemente bueno de-Word-a-texto-plano, esta solución sería terriblemente efectiva.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It tells you the SHA-1 of the first bad commit and show some of the commit information and which files were modified in that commit so you can figure out what happened that may have introduced this bug:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T075303Z" changeid="juan">
        <seg>Git reporta el código SHA-1 de la primera confirmación de cambios problemática y muestra una parte de la información relativa a esta y a los archivos modificados en ella. Así podemos irnos haciendo una idea de lo que ha podido suceder para que se haya introducido un error en el código:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The really nice thing about this is that it can be repacked at any time.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110815T213651Z" changeid="juan">
        <seg>Lo verdaderamente interesante de todo este proceso es que podemos reempaquetar en cualquier momento</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You no longer have to manually create a bare repository for new projects on the server — Gitosis creates them automatically when it sees the first push:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Ya no necesitarás crear manualmente repositorios básicos vacios para los nuevos proyectos en el servidor. Gitosis se encargará de hacerlo por tí, en cuanto realices el primer envio (push) de un nuevo proyecto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You may have skipped to this chapter from a previous chapter, or you may have gotten here after reading the rest of the book — in either case, this is where you’ll go over the inner workings and implementation of Git.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes que hayas llegado a este capítulo saltando desde alguno previo o puede que hayas llegado tras leer todo el resto del libro. --En uno u otro caso, aquí es donde aprenderás acerca del funcionamiento interno y la implementación de Git--.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>First, you choose which protocols you want your server to communicate with.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Lo primero, has de elegir el/los protocolo/s que deseas para comunicarte con el servidor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Many larger projects have established procedures for accepting patches — you’ll need to check the specific rules for each project, because they will differ.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Muchos grandes proyectos suelen tener establecidos los procedimientos para aceptar parches; --es necesario que compruebes las normas específicas para cada proyecto, ya que pueden variar de uno a otro--.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Here, you’ll look at a few interactive commands that can help you easily craft your commits to include only certain combinations and parts of files.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T091745Z" changeid="juan">
        <seg>Se van a mostrar unos pocos comandos interactivos que suelen ser de gran utilidad a la hora de recoger en una confirmación de cambios solo ciertas combinaciones y partes de archivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git checkout featureA
	$ git rebase origin/master
	$ git push –f myfork featureA</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git checkout featureA
	$ git rebase origin/master
	$ git push –f myfork featureA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You do this by telling Git how to convert your binary data to a text format that can be compared via the normal diff.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Se consigue diciendole a Git la forma de convertir los datos binarios en texto, consiguiendo así que puedan ser comparado con la herramienta habitual de comparación textual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ find .git/objects -type f
	.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ find .git/objects -type f
	.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Because the commit on the branch you’re on isn’t a direct ancestor of the branch you’re merging in, Git has to do some work.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Debido a que la confirmación en la rama actual no es ancestro directo de la rama que pretendes fusionar, Git tiene cierto trabajo extra que hacer.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you run a `git push` and your current branch is tracking `origin/master`, the commits listed by `git log origin/master..HEAD` are the commits that will be transferred to the server.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T121157Z" changeid="juan">
        <seg>Si se lanza el comando 'git push' (y la rama activa actual esta relacionada con 'origin/master'), las confirmaciones de cambio mostradas por `git log origin/master..HEAD` serán las que serán transferidas al servidor. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you had run that instead, you’d have gotten back to your original position:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T093917Z" changeid="juan">
        <seg>Y asi se puede conseguir volver exactamente al punto original:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>We covered how to generate a new key earlier, in the &quot;Simple Setups&quot; section.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Veremos cómo generar una de estas claves, más adelante, en la sección &quot;Ajustes Simples&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0332.png
Figure 3-32.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0332.png
Figura 3-32.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>After all this is set, if you run diff commands such as this:

	$ git diff 32d1776b1^ 32d1776b1</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tras ajustar todo esto, si lanzas comandos tales como:  $ git diff 32d1776b1 ^ 32d1776b1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Jessica e-mails John to tell him that she’s pushed some work into a branch named `featureA` and he can look at it now.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Jessica notifica a John por correo electrónico que ha enviado trabajo a una rama denominada 'featureA' y que puede hecharle un vistazo allí.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To demonstrate, you’ll add a large file into your test repository, remove it in the next commit, find it, and remove it permanently from the repository.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T134658Z" changeid="juan">
        <seg>Para probarlo por tí mismo, puedes añadir un archivo enorme a tu repositorio de pruebas y retirarlo en la siguiente confirmación de cambios. Así podrás practicar la busqueda y borrado permanente del repositorio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git instaweb --httpd=webrick --stop</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git instaweb --httpd=webrick --stop</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0319.png
Figure 3-19.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0319.png
Figura 3-19.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is fine if the whole thing is source code, because Git is highly optimized to compress that data efficiently.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T134204Z" changeid="juan">
        <seg>Todo suele ir bien si el contenido es únicamente código fuente. Ya que Git está tremendamente optimizado para comprimir eficientemente ese tipo de datos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0510.png
Figure 5-10.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0510.png
Figura 5-10.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git push origin master
	...
	To jessica@githost:simplegit.git
	   72bbc59..8059c15  master -&gt; master</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git push origin master
	...
	To jessica@githost:simplegit.git
	   72bbc59..8059c15  master -&gt; master</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>En muchas sistemas de control de versiones este proceso es costoso, pues a menudo requiere crear una nueva copia del código, lo cual puede tomar mucho tiempo cuando se trata de proyectos grandes.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En muchas sistemas de control de versiones este proceso es costoso, pues a menudo requiere crear una nueva copia del código, lo cual puede tomar mucho tiempo cuando se trata de proyectos grandes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git push myfork featureA</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git push myfork featureA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>First, you can inject the SHA-1 checksum of a blob into an `$Id$` field in the file automatically.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La primera, es inyectando automáticamente la suma de comprobación SHA-1 de un gran objeto binario (blob) en un campo '$Id$' dentro del archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The actual object transfer gives no output, but it does happen.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La copia de objetos no da ningún mensaje, pero también se realiza.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you would prefer to skip this patch, instead run &quot;git am --skip&quot;.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>If you would prefer to skip this patch, instead run &quot;git am --skip&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Checking out a local branch from a remote branch automatically creates what is called a _tracking branch_.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Activando (checkout) una rama local a partir de una rama remota, se crea automáticamente lo que podríamos denominar &quot;una rama de seguimiento&quot; (tracking branch).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The references won’t be the same on someone else’s copy of the repository; and right after you initially clone a repository, you'll have an empty reflog, as no activity has occurred yet in your repository.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120712T200230Z" changeid="juan">
        <seg>Las referencias de una cierta persona en su repositorio nunca seran las mismas que las de cualquier otra persona en su copia local del repositorio. Es más, justo tras terminar de clonar un repositorio lo que se tiene es un registro de referencia vacio, puesto que  aún no se ha realizado ningún trabajo sobre dicho repositorio recién clonado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0526.png
Figure 5-26.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0526.png
Figura 5-26.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you visit the Pricing and Signup page at `http://github.com/plans` and click the &quot;Sign Up&quot; button on the Free account (see figure 4-2), you’re taken to the signup page.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si visitas la página de Precios e Inicio de Sesión, en 'http://github.com/plans', y clicas sobre el botón &quot;Registro&quot; (&quot;Sign Up&quot;) de las cuentas gratuitas, verás una página de registro:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Another thing you can do for your archives is some simple keyword substitution.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Otra cosa que puedes realizar sobre tus archivos es algún tipo de sustitución simple de claves.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When you want to share that work, you merge it into your own master branch, then fetch and merge `origin/master` if it has changed, and finally push to the `master` branch on the server.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cuando deseas compartir ese trabajo, lo fusionas (merge) en tu propia rama 'master'; luego recuperas (fetch) y fusionas (merge) la rama 'origin/master', por si hubiera cambiado; y finalmente envias (push) la rama 'master' de vuelta al servidor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If that is different, you must set the `$user` variable manually.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si no fuera así, tendrás que ajustar manualmente la variable '$user'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>However, if there are too many loose objects (objects not in a packfile) or too many packfiles, Git launches a full-fledged `git gc` command.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T132557Z" changeid="juan">
        <seg>Pero, cuando hay demasiados objetos sueltos, (objetos fuera de un archivo empaquetador), o demasiados archivos empaquetadores, Git lanza un comando `git gc` completo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It has paused the process while you resolve the conflict.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Sino que hace una pausa en el proceso, esperando a que tu resuelvas el conflicto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can set your merge tool to kdiff3, opendiff, tkdiff, meld, xxdiff, emerge, vimdiff, or gvimdiff.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes utilizar kdiff3, opendiff, tkdiff, meld, xxdiff, emerge, vimdiff, o gvimdiff como herramientas de fusionado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git rebase -i HEAD~3
	Stopped at 7482e0d... updated the gemspec to hopefully work better
	You can amend the commit now, with</seg>
      </tuv>
      <tuv lang="ES" changedate="20120728T085918Z" changeid="juan">
        <seg>$ git rebase -i HEAD~3
	Stopped at 7482e0d... updated the gemspec to hopefully work better
	You can amend the commit now, with</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>These values are specific to that single repository.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Estos valores se aplicarán únicamente a dicho repositorio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This script uses a syntax that wasn’t covered in the Revision Selection section of Chapter 6.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Este script utiliza una sintaxis no contemplada en la sección de Selección de Revisiones del capítulo 6.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg># Distributed Git #</seg>
      </tuv>
      <tuv lang="ES">
        <seg># Git en entornos distribuidos #</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If your project’s `.git` directory contains a copy of the ACL file you used previously, then the following `pre-commit` script will enforce those constraints for you:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si la carpeta '.git' de tu proyecto contiene una copia del archivo de control de accesos (ACL) utilizada previamente, este script 'pre-commit' podrá comprobar los límites:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In any case, you can change e-mail addresses in multiple commits in a batch with `filter-branch` as well.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T180846Z" changeid="juan">
        <seg>En cualquier caso, se pueden cambiar de un golpe las direcciones de correo en multiples confirmaciones de cambio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can read the value of your HEAD via this command:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T192855Z" changeid="juan">
        <seg>Puedes leer el valor de HEAD a través de él:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can create a new tag as I discussed in Chapter 2.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes crear una nueva etiqueta tal y como se ha comentado en el capítulo 2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>At this point, she needs to share her work with John, so she pushes her `featureA` branch commits up to the server.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En ese punto, necesita compartir su trabajo con John, por lo que envia (push) al servidor las confirmaciones (commits) en su rama 'featureA'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Merge commit 'phedders/rdocs'</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T095049Z" changeid="juan">
        <seg>Merge commit 'phedders/rdocs'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git checkout --track origin/serverfix
	Branch serverfix set up to track remote branch refs/remotes/origin/serverfix.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git checkout --track origin/serverfix
	Branch serverfix set up to track remote branch refs/remotes/origin/serverfix.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Server-Side Hooks ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Puntos de enganche del lado servidor ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git as a content-addressable filesystem is a very powerful tool that you can easily use as more than just a VCS.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T135725Z" changeid="juan">
        <seg>Git, en su calidad de sistema de archivos indexador-de-contenidos, es una herramienta muy poderosa  que puedes usar facilmente para otras tareas ademas de la de gestión de versiones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You set up the information in that project; and when you push it, Gitosis reconfigures the server based on that, which is cool.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Preparas la información en ese proyecto especial, y cuando la envias (push), Gitosis reconfigura el servidor en base a ella. ¡Realmente interesante!.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If it does, then it was introduced sometime before this middle commit; if it doesn’t, then the problem was introduced sometime after the middle commit.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T072027Z" changeid="juan">
        <seg>Si este es el caso, el problema se introdujo en algún punto anterior a esta confirmación de cambios intermedia. Si no, el problema se introdujo en un punto posterior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This object type is called a blob.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Este tipo de objeto se denomina un blob (binary large object).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can easily check to see if you have a key already by going to that directory and listing the contents:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes verificar si tienes ya unas claves, simplemente situandote sobre dicha carpeta y viendo su contenido:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>One of the things you’ll want to do is create an archive of the latest snapshot of your code for those poor souls who don’t use Git.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Una de las cosas que desearas crear es un archivo con la más reciente imagen de tu código, para aquellas pobres almas que no utilizan Git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The merge goes smoothly — John’s commit history now looks like Figure 5-5.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si la fusión se realiza sin problemas, el historial de John será algo parecido a la Figura 5-5.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Compressing objects: 100% (5/5), done.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110810T224915Z" changeid="juan">
        <seg>Compressing objects: 100% (5/5), done.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Wrap it to about 72
	characters or so.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Limitando las líneas a 72 caracteres mas o menos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The content structure of your current Git data.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110807T145518Z" changeid="juan">
        <seg>La estructura del contenido Git para tus datos actuales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Doing so offers a number of advantages: a hosting site is generally quick to set up and easy to start projects on, and no server maintenance or monitoring is involved.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esta forma de trabajar tiene varias ventajas: un alberge externo suele ser rápido de configurar y sencillo de iniciar proyectos en él; además de no ser necesario preocuparte de su mantenimiento ni de su monitorización.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If that works well, you can fast-forward your `master` branch, and you’ll end up with a linear project history.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si funciona, se realizará un avance rápido (fast-forward) en tu rama 'master', y acabarás teniendo un historial lineal en tu proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>#### Large-Merging Workflows ####</seg>
      </tuv>
      <tuv lang="ES">
        <seg>#### Flujos de trabajo con grandes fusiones ####</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The nice thing about this is that applying a patch from an e-mail generated with `format-patch` preserves all the commit information properly, as you’ll see more of in the next section when you apply these commits:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Lo bonito de este procedimiento es que, al aplicar un parche desde un correo electrónico generado por `format-patch`, se preserva íntegramente la información de la confirmación de cambios (commit). Lo veremos más adelante, en la próxima sección, cuando veamos como aplicarlos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can either run `git submodule update` to reclone, or you can move your `/tmp/rack` directory back into the empty directory.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T140358Z" changeid="juan">
        <seg>Ante lo cual, será necesario lanzar`git submodule update` para volver a clonarla; o, si no,  volver a restaurar la carpeta  `/tmp/rack` de vuelta sobre la carpeta vacia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The `post-update` hook that comes with Git by default runs the appropriate command (`git update-server-info`) to make HTTP fetching and cloning work properly.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El enganche 'post-update' que viene de serie con Git se encarga de lanzar el comando adecuado ('git update-server-info') para hacer funcionar la recuperación (fetching) y el clonado (cloning) vía HTTP.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>With this method, you can quickly get a read/write Git server up and running for a handful of developers.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Con este método, puedes preparar rápidamente un servidor Git con acceso de lectura/escritura para un grupo de desarrolladores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If the topics still need work, they’re merged into `pu` instead.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si las funcionalidades necesitan ser más trabajadas, se fusionan (merge) en la rama 'pu'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This command is run when you push to this repository over SSH; then, other people can clone via something like</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Este comando se lanza automáticamente cuando envias (push) a este repositorio vía SSh; de tal forma que otras personas puedan clonarlo usando un comando tal que:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now you’ll explore a number of very powerful things that Git can do that you may not necessarily use on a day-to-day basis but that you may need at some point.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T084752Z" changeid="juan">
        <seg>En este capítulo se van a explorar unas cuantas tareas avanzadas de Git. Tareas que, aunque no se utilizan en el trabajo del día a día, en algún momento pueden ser necesarias. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To push a new stash onto your stack, run `git stash`:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120712T202642Z" changeid="juan">
        <seg>Utilizando el comando 'git stash' y enviando un nuevo grupo de cambios a la pila de guardado rápido:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>People can fork a project and push to it, and the main project maintainer can pull in those changes by adding them as remotes and merging in their work.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La gente puede bifurcar (fork) un proyecto y enviar (push) sobre su propia copia. El gestor del proyecto principal, puede recuperar (pull) esos cambios añadiendo las copias como remotos y fusionando (merge) el trabajo en ellas contenido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In Chapter Two we will go over basic Git usage - how to use Git for the 80%
	-s going on, modify stuff and contribute changes.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>In Chapter Two we will go over basic Git usage - how to use Git for the 80%
	-s going on, modify stuff and contribute changes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In this case, you remove a file called passwords.txt from every snapshot, whether it exists or not.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T174615Z" changeid="juan">
        <seg>En esta ocasión, se eliminará un archivo llamado passwords.txt de todas y cada una de las instantáneas (snapshot) almacenadas, tanto si este existe como si no.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git write-tree
	0155eb4229851634a0f03eb265b69f5a2d56f341
	$ git cat-file -p 0155eb4229851634a0f03eb265b69f5a2d56f341
	100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt
	100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T180328Z" changeid="juan">
        <seg>$ git write-tree
	0155eb4229851634a0f03eb265b69f5a2d56f341
	$ git cat-file -p 0155eb4229851634a0f03eb265b69f5a2d56f341
	100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt
	100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Let’s walk through setting up SSH access on the server side.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Vamos a avanzar en los ajustes de los accesos SSH en el lado del servidor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can use that incantation to grab the commit message from each commit that is trying to be pushed and exit if you see anything that doesn’t match.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes usar este &quot;hechizo mágico&quot; para coger el mensaje de cada confirmación de cambios que se está enviando y salir si localizas algo que no cuadra en alguno de ellos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you have more developers or a larger project, you’ll probably want to use at least a two-phase merge cycle.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Teniendo muchos desarrolladores o proyectos muy grandes, muy posiblemente desees utilizar un ciclo con por lo menos dos fases.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git send-email *.patch
	0001-added-limit-to-log-function.patch
	0002-changed-log-output-to-30-from-25.patch
	Who should the emails appear to be from?</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git send-email *.patch
	0001-added-limit-to-log-function.patch
	0002-changed-log-output-to-30-from-25.patch
	Who should the emails appear to be from?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>On Linux machines, `lighttpd` is often installed, so you may be able to get it to run by typing `git instaweb` in your project directory.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En las máquinas Linux, 'lighttpd' suele estar habitualmente instalado. Por lo que tan solo has de activarlo lanzando el comando 'git instaweb', estando en la carpeta de tu proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you have a branch named `serverfix` that you want to work on with others, you can push it up the same way you pushed your first branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si tienes una rama llamada 'serverfix', con la que vas a trabajar en colaboración; puedes llevarla al remoto de la misma forma que llevaste tu primera rama.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git add -i
	           staged     unstaged path
	  1:    unchanged        +0/-1 TODO
	  2:    unchanged        +1/-1 index.html
	  3:    unchanged        +5/-1 lib/simplegit.rb</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T211818Z" changeid="juan">
        <seg>$ git add -i
	           staged     unstaged path
	  1:    unchanged        +0/-1 TODO
	  2:    unchanged        +1/-1 index.html
	  3:    unchanged        +5/-1 lib/simplegit.rb</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>#### Changing E-Mail Addresses Globally ####</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T180356Z" changeid="juan">
        <seg>#### Cambiando direcciones de correo-e de forma global ####</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is because SSH access to servers is already set up in most places — and if it isn’t, it’s easy to do.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Debido a disponibilidad en la mayor parte de los servidores; (pero, si no lo estuviera disponible, además es sencillo habilitarlo).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Anything that has merge conflicts and hasn’t been resolved is listed as unmerged.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Todo aquello que sea conflictivo y no se haya podido resolver, se marca como &quot;sin fusionar&quot; (unmerged).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When you’ve decided to cut a release, you’ll probably want to drop a tag so you can re-create that release at any point going forward.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cuando decides dar por preparada una versión, probablemente querrás etiquetar dicho punto de algún modo; de tal forma que, más adelante, puedas volver a generar esa versión en cualquier momento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Next, you look for what the HEAD reference is so you know what to check out when you’re finished:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T130544Z" changeid="juan">
        <seg>Lo siguiente es mirar cual es la referencia a HEAD, de tal forma que puedas saber el punto a activar (checkout) cuando termines:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git will also automatically remove commits that did not affect the subdirectory.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T180336Z" changeid="juan">
        <seg>Y, además, Git elimina automáticamente todas las confirmaciones de cambio (commits) que no afectaban a  dicha subcarpeta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Then, you e-mail that guy and yell at him.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T111202Z" changeid="juan">
        <seg>Para enviarle un correo-e y avisarle de su despiste.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can turn on this functionality with the `core.autocrlf` setting.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes activar esta funcionalidad con el parámetro 'core.autocrlf'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Installing Gitosis isn’t the simplest task ever, but it’s not too difficult.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Instalar Gitosis no es precisamente sencillo. Pero tampoco demasiado complicado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In order to provide a public key, each user in your system must generate one if they don’t already have one.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y, para ello, cada usuario del sistema ha de generarse una, si es que no la tiene ya.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Also note the `^4832fe2` commit lines, which designate that those lines were in this file’s original commit.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T073914Z" changeid="juan">
        <seg>En el caso de las líneas con la confirmación de cambios  `^4832fe2`, merece comentar que son aquellas presentes en el archivo cuando se hizo la confirmación de cambios original; </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>So, if the Rack project updates, you can pull in upstream changes by switching to that branch and pulling:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T173507Z" changeid="juan">
        <seg>De tal forma que, si se actualiza el proyecto Rack, se pueden integrar los cambios aguas arriba simplemente cambiando a esa rama y recuperando:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Jessica’s history after committing on a feature branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El historial de Jessica después de confirmar cambios en una rama puntual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The last hook to run during a `git am` operation is `post-applypatch`.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El último punto de enganche que se activa durante una operación 'git am' es el punto 'post-applypatch'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Other possible settings are false, which never colors the output, and always, which sets colors all the time, even if you’re redirecting Git commands to a file or piping them to another command.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Otros ajustes posibles son &quot;false&quot;, para indicar a Git no colorear nunca ninguno de sus resultados; y &quot;always&quot;, para indicar colorear siempre, incluso cuando se redirija la salida a un archivo o a otro comando.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You’ll learn more about what this means in a bit.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T142056Z" changeid="juan">
        <seg>En breve lo veremos con más detalle.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>By default, a user’s SSH keys are stored in that user’s `~/.ssh` directory.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por defecto, las claves de cualquier usuario SSH se guardan en la carpeta `~/.ssh` de dicho usuario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>I’ll use the Mac path for the executable; in other systems, it will be where your `p4merge` binary is installed.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En estos ejemplos, voy a utilizar caminos y nombres Mac para los ejecutables; en otros sistemas, tendrás que sustituirlos por los correspondientes donde tengas instalado 'p4merge'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now, store some text in your Git database:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Luego, guarda algo de texto en la base de datos de Git:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The octopus merge can handle multiple branches but is more cautious to avoid difficult conflicts, so it’s chosen as the default strategy if you’re trying to merge more than two branches.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T141158Z" changeid="juan">
        <seg>La fusión-tipo-pulpo puede manejar multiples ramas, pero es mucho mas cuidadosa para evitar incurrir en complejos conflictos; y es por eso que se utiliza en los intentos de fusionar más de dos ramas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In more complex cases, the client supports `multi_ack` or `side-band` capabilities; but this example shows you the basic back and forth used by the smart protocol processes.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T090629Z" changeid="juan">
        <seg>En casos más complejos, el cliente explota las capacidades de `multi_ack` (multiples confirmaciones) o `side-band` (banda lateral). Pero este ejemplo muestra los intercambios básicos empleados en los protocolos inteligentes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now you have a new repository on GitHub (see Figure 4-6).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y ya tienes un nuevo repositorio en GitHub (ver Figura 4-6)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Further paragraphs come after blank lines.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Los siguientes párrafos van tras la línea en blanco.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg># Ramificaciones en Git #</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T141826Z" changeid="juan">
        <seg># Ramificaciones en Git #</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The configuration options recognized by Git fall into two categories: client side and server side.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Las opciones de configuración reconocidas por Git pueden distribuirse en dos grandes categorias: las del lado cliente y las del lado servidor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The `color.ui = true` setting is almost always what you’ll want to use.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Habitualmente, se trabajará con el ajuste 'color.ui = true'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The file is meant to be consumed by a machine.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Estos son archivos destinados a ser tratados de forma automatizada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git checkout master</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git checkout master</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0301.png
Figure 3-1.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0301.png
Figura 3-1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>An annotated tag is more complex, however.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T234100Z" changeid="juan">
        <seg>Sin embargo, una etiqueta anotativa es más compleja.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is called having a detached head — it means the HEAD file points directly to a commit, not to a symbolic reference.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T172218Z" changeid="juan">
        <seg>Es lo que se conoce como &quot;trabajar con cabecera desconectada&quot; --es decir, el archivo HEAD apunta directamente a una confirmación de cambios (commit), y no a una referencia simbólica--.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git log -g master
	commit 734713bc047d87bf7eac9674765ae793478c50d3
	Reflog: master@{0} (Scott Chacon &lt;schacon@gmail.com&gt;)
	Reflog message: commit: fixed refs handling, added gc auto, updated
	Author: Scott Chacon &lt;schacon@gmail.com&gt;
	Date:   Fri Jan 2 18:32:33 2009 -0800</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T102957Z" changeid="juan">
        <seg>$ git log -g master
	commit 734713bc047d87bf7eac9674765ae793478c50d3
	Reflog: master@{0} (Scott Chacon &lt;schacon@gmail.com&gt;)
	Reflog message: commit: fixed refs handling, added gc auto, updated
	Author: Scott Chacon &lt;schacon@gmail.com&gt;
	Date:   Fri Jan 2 18:32:33 2009 -0800</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is a relatively expensive operation and may add a lot of time to each push, depending on the size of the repository or the push.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Es una operación costosa, que, dependiendo del tamaño del repositorio, puede llegar a añadir mucho tiempo a cada operación de envio (push).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For example, the most recent tree in the simplegit project may look something like this:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T144024Z" changeid="juan">
        <seg>Por ejemplo, el árbol que hemos utilizado recientemente en el proyecto simplegit, puede resultar algo así como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Consider an example of doing some work (on `master`), branching off for an issue (`iss91`), working on it for a bit, branching off the second branch to try another way of handling the same thing (`iss91v2`), going back to your master branch and working there for a while, and then branching off there to do some work that you’re not sure is a good idea (`dumbidea` branch).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por ejemplo, puedes realizar cierto trabajo en la rama 'master', ramificar para un problema concreto (rama 'iss91'), trabajar en él un rato, ramificar a una segunda rama para probar otra manera de resolverlo (rama 'iss92v2'), volver a la rama 'master' y trabajar un poco más, y, por último, ramificar temporalmente para probar algo de lo que no estás seguro (rama 'dumbidea').</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The third type of reference that you’ll see is a remote reference.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110810T224545Z" changeid="juan">
        <seg>El tercer tipo de referencia que puedes observar es la referencia remota.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>What is the &quot;word&quot; filter?</seg>
      </tuv>
      <tuv lang="ES">
        <seg>¿Qué es el filtro &quot;word&quot;?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You must look at each commit being pushed up, see if that string is in the commit message, and, if the string is absent from any of the commits, exit non-zero so the push is rejected.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Has de mirar en cada confirmación de cambios (commit) recibida, para ver si contiene ese texto; y, si no lo trae, salir con un código distinto de cero, de tal forma que el envio (push) sea rechazado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You stick the bare repository copy somewhere everyone has shared access to and set the read/write permissions as you would for any other shared directory.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Simplemente pones el repositorio básico en algún lugar donde todos tengan acceso a él y ajustas los permisos de lectura/escritura según proceda, tal y como lo harías para preparar cualquier otra carpeta compartida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The GitHub plan page.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La página de planes GitHub.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To clone a repository like this or to add one as a remote to an existing project, use the path to the repository as the URL.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para clonar un repositorio como estos, o para añadirlo como remoto a un proyecto ya existente, usa el camino (path) del repositorio como su URL.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>files_modified = `git diff-index --cached --name-only HEAD`</seg>
      </tuv>
      <tuv lang="ES">
        <seg>files_modified = `git diff-index --cached --name-only HEAD`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ (fix the file)
	$ git add ticgit.gemspec
	$ git am --resolved
	Applying: seeing if this helps the gem</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ (fix the file)
	$ git add ticgit.gemspec
	$ git am --resolved
	Applying: seeing if this helps the gem</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>First, you’ll probably want to clone the main repository, create a topic branch for the patch or patch series you’re planning to contribute, and do your work there.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para empezar, problemente desees clonar el repositorio principal, crear una rama puntual para el parche con el que piensas contribuir, y ponerte a trabajar sobre ella.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This means `master` almost always moves forward, `next` is rebased occasionally, and `pu` is rebased even more often (see Figure 5-25).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto significa que 'master' prácticamente siempre avanza; 'next' se reorganiza (rebase) de vez en cuando; y 'pu' es reorganizada con más frecuencia (ver Figura 5-25).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git clone /opt/git/project.git</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git clone /opt/git/project.git</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Let’s take a minute to look at how Git stores its objects.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T180739Z" changeid="juan">
        <seg>Vamos a hechar un vistazo a cómo Git almacena sus objetos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Short (50 chars or less) summary of changes</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Un resumen de cambios, corto (50 caracteres o menos).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ mv rack /tmp/
	$ git checkout master
	Switched to branch &quot;master&quot;
	$ ls
	README	rack</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T140119Z" changeid="juan">
        <seg>$ mv rack /tmp/
	$ git checkout master
	Switched to branch &quot;master&quot;
	$ ls
	README	rack</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The hooks are all stored in the `hooks` subdirectory of the Git directory.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Los puntos de enganche se guardan en la subcarpeta 'hooks' de la carpeta Git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Submodule path 'rack': checked out '08d709f78b8c5b0fbeb7821e37fa53e69afcf433'</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T105827Z" changeid="juan">
        <seg>Submodule path 'rack': checked out '08d709f78b8c5b0fbeb7821e37fa53e69afcf433'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You should also be able to share your branches by pushing them to a shared server, working with others on shared branches and rebasing your branches before they are shared.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>También conocerás cómo compatir tus ramas enviandolas (push) a un servidor compartido, cómo trabajar colaborativamente en ramas compartidas, y cómo reorganizar (rebase) tus ramas antes de compartirlas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>At the bottom of the instructions page is a link to a Subversion import.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>All fondo de la página de instrucciones, tienes un enlace &quot;Subversion import&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It’s important to note that the reflog information is strictly local — it’s a log of what you’ve done in your repository.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T191219Z" changeid="juan">
        <seg>Es importante destacar la estricta localidad de la información en el registro de referencia. Es un registro que se va componiendo en cada repositorio según se va trabajando en él.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>#### Enforcing a User-Based ACL System ####</seg>
      </tuv>
      <tuv lang="ES">
        <seg>#### Implementando un sistema de control de accesos basado en usuario ####</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It’s easiest to push the remote branch you’re working on up to your repository, rather than merging into your master branch and pushing that up.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Es más sencillo enviar (push) directamente la rama puntual sobre la que estás trabajando, en lugar de fusionarla (merge) previamente con tu rama principal y enviar esta última.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It’s easiest to use a Linux server for it — these examples use a stock Ubuntu 8.10 server.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Es más sencillo hacerlo si utilizas un servidor Linux --estos ejemplos se han hecho sobre un servidor Ubuntu 8.10--.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>They can use that key to verify all your signed tags.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>De esta forma, pueden utilizar esa clave para verificar todas las etiquetas que firmes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git checkout master
	$ git merge server</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git checkout master
	$ git merge server</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You’ll learn more about `read-tree` and its friends in Chapter 9, but for now know that it reads the root tree of one branch into your current staging area and working directory.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T173413Z" changeid="juan">
        <seg>Se verá más en detalle el comando `read-tree` y sus acompañantes en el capítulo 9. Pero por ahora, basta con saber que este comando se encarga de leer el árbol raiz de una rama en el área de preparación (staging area) y carpeta de trabajo (working directory) actuales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>However, scripts and hosted services may make this easier — it depends largely on how you develop and how your contributors develop.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>De todas formas, los scripts y los servicios albergados pueden hacerte la vida más facil en esto, --todo depende de cómo desarrolles tú y de como desarrollan las personas que colaboran contigo--.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can see that Git re-modifies the files you uncommitted when you saved the stash.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120712T205310Z" changeid="juan">
        <seg>Como se ve en la salida del comando, Git vueve a aplicar los correspondientes cambios en los archivos que estaban modificados. Pero no conserva la información de lo que estaba o no estaba añadido al área de preparación. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Thus, I’ve made this discussion the last chapter in the book so you could read it early or later in your learning process.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T142043Z" changeid="juan">
        <seg>Por ello, lo he puesto al final del libro; de tal forma que puedas leerlo antes o después, en cualquier momento, a lo largo de tu proceso de aprendizaje.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you don’t want to go through all of the work involved in setting up your own Git server, you have several options for hosting your Git projects on an external dedicated hosting site.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si no quieres realizar todo el trabajo de preparar tu propio servidor Git, tienes varias opciones para alojar tus proyectos Git en una ubicación externa dedicada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The maintainer of the Git project has solved this issue by including their public key as a blob in the repository and then adding a tag that points directly to that content.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Los gestores del proyeto Git ha resuelto este problema incluyendo sus claves públicas como un objeto en el repositorio, añadiendo luego una etiqueta apuntando directamente a dicho contenido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git log
	commit 734713bc047d87bf7eac9674765ae793478c50d3
	Author: Scott Chacon &lt;schacon@gmail.com&gt;
	Date:   Fri Jan 2 18:32:33 2009 -0800</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T095033Z" changeid="juan">
        <seg>$ git log
	commit 734713bc047d87bf7eac9674765ae793478c50d3
	Author: Scott Chacon &lt;schacon@gmail.com&gt;
	Date:   Fri Jan 2 18:32:33 2009 -0800</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For example, if your contributor sends you two patches and you create a branch called `contrib` and applied those patches there, you can run this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por ejemplo, si la persona colaboradora te envia dos parches y tu creas una rama 'contrib' donde aplicar dichos parches; puedes lanzar algo como esto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>second commit</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T180409Z" changeid="juan">
        <seg>second commit</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git can handle this by auto-converting CRLF line endings into LF when you commit, and vice versa when it checks out code onto your filesystem.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Git la maneja autoconvirtiendo los finales CRLF en LF al hacer confirmaciones de cambios (commit); y, viceversa, al extraer código (checkout) a la carpeta de trabajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git log --abbrev-commit --pretty=oneline
	ca82a6d changed the version number
	085bb3b removed unnecessary test code
	a11bef0 first commit</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T095207Z" changeid="juan">
        <seg>$ git log --abbrev-commit --pretty=oneline
	ca82a6d changed the version number
	085bb3b removed unnecessary test code
	a11bef0 first commit</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Commit Ranges ###</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T090219Z" changeid="juan">
        <seg>### Referecias a un rango de confirmaciones de cambios ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>[rejected]        master -&gt; master (non-fast forward)
	error: failed to push some refs to 'john@githost:simplegit.git'</seg>
      </tuv>
      <tuv lang="ES">
        <seg>[rejected]        master -&gt; master (non-fast forward)
	error: failed to push some refs to 'john@githost:simplegit.git'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>*.pbxproj binary</seg>
      </tuv>
      <tuv lang="ES">
        <seg>*.pbxproj binary</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can set it to `more` or to your favorite pager (by default, it’s `less`), or you can turn it off by setting it to a blank string:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes ajustarlo para que utilice 'more' o tu paginador favorito, (por defecto, se utiliza 'less'); o puedes anular la paginación si le asignas una cadena vacia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git read-tree --prefix=bak d8329fc1cc938780ffdd9f94e0d364e0ea74f579
	$ git write-tree
	3c4e9cd789d88d8d89c1073707c3585e41b0e614
	$ git cat-file -p 3c4e9cd789d88d8d89c1073707c3585e41b0e614
	040000 tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579      bak
	100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt
	100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T180333Z" changeid="juan">
        <seg>$ git read-tree --prefix=bak d8329fc1cc938780ffdd9f94e0d364e0ea74f579
	$ git write-tree
	3c4e9cd789d88d8d89c1073707c3585e41b0e614
	$ git cat-file -p 3c4e9cd789d88d8d89c1073707c3585e41b0e614
	040000 tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579      bak
	100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt
	100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a      test.txt</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The blank
	line separating the summary from the body is critical (unless you omit
	the body entirely); tools like rebase can get confused if you run the
	two together.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La línea en blanco separando el resumen del cuerpo es crítica (a no ser que se omita totalmente el cuerpo); algunas herramientas como 'rebase' pueden tener problemas si no los separas adecuadamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## Git Daemon ##</seg>
      </tuv>
      <tuv lang="ES">
        <seg>## El demonio Git ##</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Normal merge conflict for 'index.html':
	  {local}: modified
	  {remote}: modified
	Hit return to start merge resolution tool (opendiff):</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Normal merge conflict for 'index.html':
	  {local}: modified
	  {remote}: modified
	Hit return to start merge resolution tool (opendiff):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To do so, you’ll likely have to edit your `/etc/passwd` file:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Has de editar el archivo '/etc/passwd':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You then need to add in this new repository URL as a second remote, in this case named `myfork`:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tendrás que añadir la URL a este nuevo repositorio como un segundo remoto, y en este caso lo denominaremos 'myfork':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>These options apply to the git rebase option as well.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Estas opciones se pueden aplicar también al comando 'git rebase'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you’re set up correctly, you can try to SSH into your server as the user for which you added the public key to initialize Gitosis.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si lo has configurado todo correctamente, puedes intentar conectarte, vía SSH, a tu servidor como el usuario con cuya clave pública has inicializado Gitosis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you want to place your repositories on a server that doesn’t have accounts for everyone on your team whom you want to have write access, then you must set up SSH access for them.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si deseas colocar los repositorios en un servidor donde no todas las personas de tu equipo tengan cuentas de acceso, tendrás que dar acceso SSH a aquellas que no lo tengan.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can set up three client-side hooks for an e-mail–based workflow.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tienes disponibles tres puntos de enganche en el lado cliente para interactuar con el flujo de trabajo de correo electrónico.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This effectively makes nice text-based versions of your Word files before attempting to diff them.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto prepara versiones texto de los archivos Word, antes de intentar compararlos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you have it available, this is a good time to add your public SSH key as well.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si la tuvieras, es también un buen momento para añadir tu clave pública SSH.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In this case, you’re still on master.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En este caso, en la rama 'master'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg># Rebase 710f0f8..a5f4a0d onto 710f0f8
	#
	# Commands:
	#  p, pick = use commit
	#  e, edit = use commit, but stop for amending
	#  s, squash = use commit, but meld into previous commit
	#
	# If you remove a line here THAT COMMIT WILL BE LOST.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120728T084607Z" changeid="juan">
        <seg># Rebase 710f0f8..a5f4a0d onto 710f0f8
	#
	# Commands:
	#  p, pick = use commit
	#  e, edit = use commit, but stop for amending
	#  s, squash = use commit, but meld into previous commit
	#
	# If you remove a line here THAT COMMIT WILL BE LOST.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### GitHub Summary ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Resumen de GitHub ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The Git project requires that the more detailed explanation include your motivation for the change and contrast its implementation with previous behavior — this is a good guideline to follow.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El proyecto Git obliga a incluir una explicación detallada; incluyendo tus motivaciones para los cambios realizados; y comentarios sobre las diferencias, tras su implementación, respecto del comportamiento anterior del programa. Esta recomendación es una buena regla a seguir.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>First, you again tell it the scope of the bisect by providing the known bad and good commits.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T075504Z" changeid="juan">
        <seg>Primero, como siempre, se indica el alcance de la búsqueda indicando las aquellas confirmaciones de cambio conocidas donde el proyecto estaba mal y donde estaba bien.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Every time anyone clones this repository, they will have to clone all 2MB just to get this tiny project, because you accidentally added a big file.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T134918Z" changeid="juan">
        <seg>A partir de este momento, cada vez que alguien haga un clón de este repositorio, se verá obligado a copiar 2 MB para un proyecto tan simple. Y todo porque tu añadiste accidentalmente un archivo enorme en algún momento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can run rebase interactively by adding the `-i` option to `git rebase`.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120728T082629Z" changeid="juan">
        <seg>Este modo interactivo se activa utilizando la opción `-i` en el comando `git rebase`. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git cat-file -p ca82a6dff817ec66f44342007202690a93763949
	tree cfda3bf379e4f8dba8717dee55aab78aef7f4daf
	parent 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
	author Scott Chacon &lt;schacon@gmail.com&gt; 1205815931 -0700
	committer Scott Chacon &lt;schacon@gmail.com&gt; 1240030591 -0700</seg>
      </tuv>
      <tuv lang="ES" changedate="20110817T222935Z" changeid="juan">
        <seg>$ git cat-file -p ca82a6dff817ec66f44342007202690a93763949
	tree cfda3bf379e4f8dba8717dee55aab78aef7f4daf
	parent 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
	author Scott Chacon &lt;schacon@gmail.com&gt; 1205815931 -0700
	committer Scott Chacon &lt;schacon@gmail.com&gt; 1240030591 -0700</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you aren’t working with a person consistently but still want to pull from them in this way, you can provide the URL of the remote repository to the `git pull` command.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si no trabajas habitualmente con una persona, pero deseas recuperar de ella por esta vía, puedes indicar directamente el URL del repositorio remoto en el comando 'git pull'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This way, you can export a snapshot or build and name it something understandable to people.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>De esta forma, puedes exportar una instantánea u obtener un nombre comprensible por cualquier persona.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Many options are useful only in edge cases that I won’t go over here.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>No vamos a revisar aquellas opciones utilizadas solo en casos muy especiales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You must rewrite all the commits downstream from `6df76` to fully remove this file from your Git history.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T135100Z" changeid="juan">
        <seg>Para borrar realmente ese archivo de tu historial Git, has de reescribir todas las confirmaciones de cambio aguas abajo de `6df76`. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>[remote &quot;origin&quot;]
	       url = git@github.com:schacon/simplegit-progit.git
	       fetch = +refs/heads/master:refs/remotes/origin/master
	       fetch = +refs/heads/experiment:refs/remotes/origin/experiment</seg>
      </tuv>
      <tuv lang="ES" changedate="20110815T221226Z" changeid="juan">
        <seg>[remote &quot;origin&quot;]
	       url = git@github.com:schacon/simplegit-progit.git
	       fetch = +refs/heads/master:refs/remotes/origin/master
	       fetch = +refs/heads/experiment:refs/remotes/origin/experiment</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You’ve decided that you’re going to work on issue #53 in whatever issue-tracking system your company uses.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Decides trabajar el problema #53, del sistema que tu compañia utiliza para llevar seguimiento de los problemas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The output can be sent to the maintainer—it tells them where the work was branched from, summarizes the commits, and tells where to pull this work from.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esta salida puede ser enviada al gestor del proyecto, --le indica el punto donde  se ramificó, resume las confirmaciones de cambio, y le dice desde dónde recuperar estos cambios--.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git request-pull origin/master myfork
	The following changes since commit 1edee6b1d61823a2de3b09c160d7080b8d1b3a40:
	  John Smith (1):
	        added a new function</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git request-pull origin/master myfork
	The following changes since commit 1edee6b1d61823a2de3b09c160d7080b8d1b3a40:
	  John Smith (1):
	        added a new function</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can set each value separately with a series of `git config` commands, or you can add them manually; but in the end, your config file should look something like this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes ir ajustando cada valor individualmente, a través de comandos `git config`; o puedes añadirlos todos manualmente. Pero, al final, tu archivo de configuración ha de quedar más o menos como esto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Generally, if you’re going to these lengths, it’s easier to use SSH public keys; but it may be a better solution in your specific case to use signed SSL certificates or other HTTP-based authentication methods for read-only access over HTTPS.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Aunque, si pretendes ir tan lejos, es más sencillo utilizar claves públicas SSH; pero ahí está la posibilidad, por si en algún caso concreto sea mejor solución el uso de certificados SSL u otros medios de autentificación HTTP para el acceso de solo-lectura a través de HTTPS.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This command looks up which server origin is (in this case, it’s `git.ourcompany.com`), fetches any data from it that you don’t yet have, and updates your local database, moving your `origin/master` pointer to its new, more up-to-date position (see Figure 3-24).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Este comando localiza en qué servidor está el origen (en este caso 'git.ourcompany.com'), recupera cualquier dato presente allí que tu no tengas, y actualiza tu base de datos local, moviendo tu rama 'origin/master' para que apunte a esta nueva y más reciente posición (ver Figura 3-24).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## Stashing ##</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T092917Z" changeid="juan">
        <seg>## Guardado rápido provisional ##</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>However, if you can’t find a reference in the `refs` directory, it’s probably in your `packed-refs` file.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T092934Z" changeid="juan">
        <seg>Cualquier referencia que no puedas encontrar en la carpeta `refs`, es muy posible que la encuentres en el archivo `packed-refs`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git log -1 rack
	commit 85a3eee996800fcfa91e2119372dd4172bf76678
	Author: Scott Chacon &lt;schacon@gmail.com&gt;
	Date:   Thu Apr 9 09:19:14 2009 -0700</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T110906Z" changeid="juan">
        <seg>$ git log -1 rack
	commit 85a3eee996800fcfa91e2119372dd4172bf76678
	Author: Scott Chacon &lt;schacon@gmail.com&gt;
	Date:   Thu Apr 9 09:19:14 2009 -0700</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg># Jessica's Machine
	$ git push origin master
	...
	To jessica@githost:simplegit.git
	   1edee6b..fbff5bc  master -&gt; master</seg>
      </tuv>
      <tuv lang="ES">
        <seg># Jessica's Machine
	$ git push origin master
	...
	To jessica@githost:simplegit.git
	   1edee6b..fbff5bc  master -&gt; master</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Because Git is very flexible, people can and do work together many ways, and it’s problematic to describe how you should contribute to a project — every project is a bit different.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por la gran flexibilidad de Git, la gente lo suele utilizar de multiples maneras; siendo problemático intentar describir la forma en que deberías contribuir a un proyecto --cada proyecto tiene sus peculiaridades--.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Understanding how Git works at a lower level should make it easier to understand why it’s doing what it’s doing and also to write your own tools and helping scripts to make your specific workflow work for you.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T135659Z" changeid="juan">
        <seg>Entendiendo cómo trabaja Git a bajo nivel, es más sencillo comprenderestán  por qué hace lo que hace. A la par que facilita la escritura de tus propias herramientas y scripts auxiliares para implementar flujos de trabajo tal y como necesites.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ cat LAST_COMMIT
	Last commit date: $Format:Tue Apr 21 08:38:48 2009 -0700$</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ cat LAST_COMMIT
	Last commit date: $Format:Tue Apr 21 08:38:48 2009 -0700$</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ sudo chmod 755 /opt/git/gitosis-admin.git/hooks/post-update</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ sudo chmod 755 /opt/git/gitosis-admin.git/hooks/post-update</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Change the commit message, and exit the editor.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120728T090025Z" changeid="juan">
        <seg>Cambiar el mensaje de la confirmación de cambios y salir del editor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>&lt;div id=&quot;footer&quot;&gt;
	please contact us at email.support@github.com
	&lt;/div&gt;</seg>
      </tuv>
      <tuv lang="ES">
        <seg>&lt;div id=&quot;footer&quot;&gt;
	please contact us at email.support@github.com
	&lt;/div&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Managing a complex series of parallel contributed topic branches.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Gestionando complejas series de ramas puntuales paralelas con funcionalidades varias.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you want to use a graphical tool to resolve these issues, you can run `git mergetool`, which fires up an appropriate visual merge tool and walks you through the conflicts:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si, en lugar de resolver directamente, prefieres utilizar una herramienta gráfica. Puedes usar el comando 'git mergetool'. Esto arrancará la correspondiente herramienta de visualización y te permirá ir resolviendo conflictos con ella.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>commit cac0cab538b970a37ea1e769cbbde608743bc96d
	Author: Scott Chacon &lt;schacon@gmail.com&gt;
	Date:   Fri May 22 18:14:29 2009 -0700</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T180407Z" changeid="juan">
        <seg>commit cac0cab538b970a37ea1e769cbbde608743bc96d
	Author: Scott Chacon &lt;schacon@gmail.com&gt;
	Date:   Fri May 22 18:14:29 2009 -0700</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0317.png
Figure 3-17.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0317.png
Figura 3-17.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Let’s say that John and Jessica are working together on one feature, while Jessica and Josie are working on a second.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Supongamos que John y Jessica trabajan conjuntamente en una funcionalidad, mientras que jessica y Josie trabajan en una segunda funcionalidad.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git pull git://github.com/onetimeguy/project.git
	From git://github.com/onetimeguy/project
	 * branch            HEAD       -&gt; FETCH_HEAD
	Merge made by recursive.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git pull git://github.com/onetimeguy/project.git
	From git://github.com/onetimeguy/project
	 * branch            HEAD       -&gt; FETCH_HEAD
	Merge made by recursive.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>#### Downloading Data ####</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T075049Z" changeid="juan">
        <seg>#### Descargando datos, (Downloading) ####</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This section will quickly cover how these two main protocols operate.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T130237Z" changeid="juan">
        <seg>En esta parte, se verán sucintamente cómo trabajan esos dos tipos de protocolo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Here you’ll configure Git to use the `strings` program to convert Word documents into readable text files, which it will then diff properly:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por ejemplo, puedes configurar Git para que utilice el programa 'strings' para convertir los documentos Word en archivos de texto planos, archivos sobre los que poder realizar comparaciones sin problemas:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>That starts up an HTTPD server on port 1234 and then automatically starts a web browser that opens on that page.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto arranca un servidor HTTPD en el puerto 1234, y luego arranca un navegador que abre esa página.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>That being said, many Git servers authenticate using SSH public keys.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tal y como se ha comentado, muchos servidores Git utilizan la autentificación a través de claves públicas SSH.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Staging the files checksums each one (the SHA-1 hash we mentioned in Chapter 1), stores that version of the file in the Git repository (Git refers to them as blobs), and adds that checksum to the staging area:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Al preparar los archivos, Git realiza una suma de control de cada uno de ellos (un resumen SHA-1, tal y como se mencionaba en el capítulo 1), almacena una copia de cada uno en el repositorio (estas copias se denominan &quot;blobs&quot;), y guarda cada suma de control en el área de preparación (staging area):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you run `git diff` normally, you only see something like this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si lanzas un comando 'git diff', lo único que verás será algo tal como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git commit -am 'test [ref: 132]'
	[master e05c914] test [ref: 132]
	 1 files changed, 1 insertions(+), 0 deletions(-)</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git commit -am 'test [ref: 132]'
	[master e05c914] test [ref: 132]
	 1 files changed, 1 insertions(+), 0 deletions(-)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>First, add a large object to your history:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T104617Z" changeid="juan">
        <seg>Para emprezar, añade un objeto enorme a tu historial:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>One of the interesting features of this is that you can ask it to figure out all sorts of code movement as well.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120827T145506Z" changeid="juan">
        <seg>Esto permite preguntar a Git acerca de todo tipo de movimientos en el código.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In this case, you can read an existing tree into your staging area as a subtree by using the `--prefix` option to `read-tree`:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110807T145026Z" changeid="juan">
        <seg>Y, en este caso, puedes hacerlo como si fuera una subcarpeta utilizando la opción `--prefix`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>There are two sets of processes for transferring data: a pair for uploading data and a pair for downloading data.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T131532Z" changeid="juan">
        <seg>Existen dos conjuntos de procesos para transferir datos: uno para para enviar y otro par para recibir.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git branch --no-merged
	  testing</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git branch --no-merged
	  testing</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It doesn’t take any parameters, but you can easily get the last commit by running `git log -1 HEAD`.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Este no recibe ningún parámetro, pero podemos obtener facilmente la última confirmación de cambios con el comando 'git log -1 HEAD'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This modifies the files in your working directory.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto modificará los archivos en tu carpeta de trabajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can see that it applied cleanly and automatically created the new commit for you.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Observarás que, tras incorporarlo limpiamente, crea automáticamente una nueva confirmación de cambios (commit).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Again, this generally does nothing.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T092135Z" changeid="juan">
        <seg>Y, habitualmente, no hará nada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can also serve your repositories read-only over HTTPS, which means you can encrypt the content transfer; or you can go so far as to make the clients use specific signed SSL certificates.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes también servir tus repositorios de solo lectura a través de HTTPS, teniendo así las transferencias encriptadas. O puedes ir más lejos aún, requiriendo el uso de certificados SSL específicos para cada cliente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Is it centralized, with each developer having equal write access to the main codeline?</seg>
      </tuv>
      <tuv lang="ES">
        <seg>¿Es centralizado, con iguales derechos de acceso en escritura para cada desarrollador?.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This way, projects don’t have to worry about adding users as collaborators to give them push access.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>De esta forma, los proyectos no han de preocuparse de añadir usuarios como colaboradores para darles acceso de envio (push).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>However, first you’ll delete the `hotfix` branch, because you no longer need it — the `master` branch points at the same place.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Pero antes, es interesante borrar la rama 'hotfix'. Ya que no la vamos a necesitar más, puesto que apunta exactamente al mismo sitio que la rama 'master'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Running a Git server is simple.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Disponer un servidor Git es simple.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now your new project root is what was in the `trunk` subdirectory each time.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T192357Z" changeid="juan">
        <seg>Tras este comando, la nueva raiz del proyecto pasa a ser el contenido de la carpeta `trunk`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git clone file:///opt/git/project.git</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git clone file:///opt/git/project.git</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git submodule update
	fatal: reference isn’t a tree: 6c5e70b984a60b3cecd395edd5b48a7575bf58e0
	Unable to checkout '6c5e70b984a60b3cecd395edd5ba7575bf58e0' in submodule path 'rack'</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T110836Z" changeid="juan">
        <seg>$ git submodule update
	fatal: reference isn’t a tree: 6c5e70b984a60b3cecd395edd5b48a7575bf58e0
	Unable to checkout '6c5e70b984a60b3cecd395edd5ba7575bf58e0' in submodule path 'rack'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You saw some simple Git configuration details in the first chapter, but I’ll go over them again quickly here.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Primeramente, vamos a repasar brevemente los detalles de configuración de Git que ya has visto en el primer capítulo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To start `instaweb` with a non-lighttpd handler, you can run it with the `--httpd` option.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para instalar 'instaweb' disponiendo de un controlador no-lighttpd, puedes lanzarlo con la opción '--httpd'.  </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When you save and close the editor, the editor writes a new commit containing that message and makes it your new last commit.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120728T080452Z" changeid="juan">
        <seg>Al guardar y cerrar en el editor, este escribe una nueva confirmación de cambios y reemplaza con ella la última confirmación existente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Client-Side Hooks ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Puntos de enganche del lado cliente ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git diff-tree -p rack_remote/master</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T164108Z" changeid="juan">
        <seg>$ git diff-tree -p rack_remote/master</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git fetch origin
	remote: Counting objects: 20, done.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git fetch origin
	remote: Counting objects: 20, done.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now, you can use the head reference you just created instead of the SHA-1 value in your Git commands:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T201522Z" changeid="juan">
        <seg>A partir de ese momento, puedes utilizar esa referencia principal que acabas de crear, en lugar del valor SHA-1, en todos tus comandos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>What happens if you create a new branch?</seg>
      </tuv>
      <tuv lang="ES">
        <seg>¿Qué sucede cuando creas una nueva rama?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In this case, it’s `http://github.com/testinguser/iphone_project`.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En este ejemplo, la URL es `http://github.com/testinguser/iphone_project`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git com
	git: 'com' is not a git-command.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git com
	git: 'com' is not a git-command.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now suppose you did that in a branch.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T172806Z" changeid="juan">
        <seg>Tras esto, y suponiendo que ese paso ha sido realizado en una rama.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>These instructions are similar to what we’ve already gone over.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Estas instrucciones son similares a las que ya hemos visto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This tab also shows a box with the latest commit information.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esta pestaña muestra también un cuadro con información sobre la última confirmación de cambio (commit) realizada en el proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can use this to make sure a commit message is properly formatted or to normalize the message by having the script edit it in place.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes utilizarlo para asegurarte de que el mensaje de confirmación esté correctamente formateado o para normalizar el mensaje permitiendo al script que lo edite sobre la marcha.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>First, you initialize a new Git repository and verify that there is nothing in the `objects` directory:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T142820Z" changeid="juan">
        <seg>Para empezar, inicializa un nuevo repositorio Git y comprueba que la carpeta 'objects' está vacia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Don’t judge me — it’s easier to demonstrate in this manner.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>No me juzgues por ello, --es más sencillo mostrarlo de esta manera--.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Figure 3-16 highlights the three snapshots that Git uses to do its merge in this case.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La figura 3-16 ilustra las tres instantáneas que Git utiliza para realizar la fusión en este caso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The `git-receive-pack` command immediately responds with one line for each reference it currently has — in this case, just the `master` branch and its SHA.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T073114Z" changeid="juan">
        <seg>El comando `git-receive-pack` responde con una linea por cada una de las referencias que tenga, --en este caso, la rama  `master` y su SHA--.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The other two network protocols (HTTP and Git) are generally read-only, so even if you have them available for the unwashed masses, you still need SSH for your own write commands.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Los otros dos protocolos de red (HTTP y Git) suelen ser normalmente protocolos de solo-lectura; de tal forma que, aunque los tengas disponibles para el público en general, sigues necesitando SSH para tu propio uso en escritura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>That is a very basic case of the transfer protocols.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T090452Z" changeid="juan">
        <seg>Este es un caso muy sencillo para ilustrar los protocolos de trasferencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The `Commit` information indicates the person who applied the patch and the time it was applied.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El campo 'Commit' muestra la persona que ha incorporado el parche y cuándo lo ha incorporado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0405.png
Figure 4-5.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0405.png
Figura 4-5.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Although you may have legitimate merge issues, you know where in your history their work is based; a proper three-way merge is the default rather than having to supply a `-3` and hope the patch was generated off a public commit to which you have access.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>A pesar de poder seguir teniendo los habituales problemas con la fusión, por lo menos conoces en qué punto de tu historial han basado su trabajo. Por defecto, se aplicará una genuina fusión a tres bandas, en lugar de tener que poner un '-3' y esperar que el parche haya sido generado a partir de una confirmación de cambios (commit) pública a la que tengas tú también acceso. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>One of the largest Git projects, the Linux kernel, is beginning to need 12 characters out of the possible 40 to stay unique.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120712T195350Z" changeid="juan">
        <seg>Aunque, en uno de los más grandes proyectos gestionados con Git, el kernel de Linux, están siendo necesarios unos 12 caracteres (de los 40 posibles) para garantizar la unicidad.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>http://git.or.cz/gitwiki/GitHosting</seg>
      </tuv>
      <tuv lang="ES">
        <seg>http://git.or.cz/gitwiki/GitHosting</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You start a new branch based off the current `origin/master` branch, squash the `featureB` changes there, resolve any conflicts, make the implementation change, and then push that up as a new branch:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para ello, inicias una nueva rama basada en la actual 'origin/master', aplicas (squash) sobre ella los cambios de 'featureB', resuelves los posibles conflictos que se pudieran presentar, realizas los cambios en los detalles, y la envias de vuelta como una nueva rama:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Example history for range selection.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T115808Z" changeid="juan">
        <seg>Ejemplo de historial para selección de rangos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0335.png
Figure 3-35.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0335.png
Figura 3-35.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can delete it and then manually close the ticket in your ticket-tracking system:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por lo que puedes borrarla. Y cerrar manualmente el problema en el sistema de seguimiento de problemas de tu empresa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Next, you have to tell your Gitosis server which repositories to allow unauthenticated Git server-based access to.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>A continuación, has de indicar en tu servidor Gitosis a cuales de tus repositorios ha de permitir acceso sin autentificar por parte del servidor Git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This command will apply the other two commits automatically, and then you’re done.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T122904Z" changeid="juan">
        <seg>Las otras dos confirmaciones de cambio serán reaplicadas automáticamene. Y ya estará completa la reorganización.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0339.png
Figure 3-39.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0339.png
Figura 3-39.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The objects that remain are the blobs that aren’t pointed to by any commit — in this case, the &quot;what is up, doc?&quot; example and the &quot;test content&quot; example blobs you created earlier.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T114144Z" changeid="juan">
        <seg>Solo han quedado aquellos objetos binarios no referenciados por ninguna confirmación de cambios --en este caso, el ejemplo de &quot;¿que hay de nuevo, viejo?&quot; y el ejemplo de &quot;contenido de pruebas&quot;--</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git update-ref refs/heads/test cac0ca</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T191423Z" changeid="juan">
        <seg>$ git update-ref refs/heads/test cac0ca</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0412.png
Figure 4-12.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0412.png
Figura 4-12.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you want to unstage the TODO file at this point, you use the `3` or `r` (for revert) option:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T092352Z" changeid="juan">
        <seg>Si se desea sacar el archivo TODO del área, se puede utilizar la opción '3' o 'r' (revert):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can delete it with the `-d` option to `git branch`:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto lo puedes hacer con la opción '-d' del comando 'git branch':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can make a lightweight tag by running something like this:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T234001Z" changeid="juan">
        <seg>Puedes crear una etiqueta ligera lanzando un comando tal como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It’s like a very small rebase — don’t amend your last commit if you’ve already pushed it.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T121942Z" changeid="juan">
        <seg>Es como si se realizara una pequeña reorganización (rebase). Y, por tanto, aquí también se aplica la regla de no modificar nunca una confirmación de cambios que ya haya sido enviada (push) a otros.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The main difficulty with describing this process is that there are a huge number of variations on how it’s done.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El mayor problema al intentar describir este proceso es el gran número de variaciones que se pueden presentar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Although Subversion automatically does such a merge on the server if different files are edited, in Git you must merge the commits locally.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Mientras que Subversion fusiona automáticamente en el servidor cuando los cambios han sido aplicados sobre archivos distintos, en Git has de fusionar (merge) los cambios localmente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In this case, Git does a simple three-way merge, using the two snapshots pointed to by the branch tips and the common ancestor of the two.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Git realizará una fusión a tres bandas, utilizando las dos instantáneas apuntadas por el extremo de cada una de las ramas y por el ancestro común a ambas dos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The Downloads tab allows you to upload project binaries and link to tarballs and zipped versions of any tagged points in your project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La pestaña &quot;Downloads&quot; permite cargar binarios del proyecto y enlaza con tarballs o versiones comprimidas de cualquier punto marcado (tagged) en tu proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This helps make the data more useful:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T202822Z" changeid="juan">
        <seg>Esto hace más util la información mostrada:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Or if someone tries to edit a file they don’t have access to and push a commit containing it, they will see something similar.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>O si alguien intenta editar un archivo sobre el que no tiene acceso y luego envia una confirmación de cambios con ello, verá también algo similar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>pick f7f3f6d changed my name a bit
	edit 310154e updated README formatting and added blame
	pick a5f4a0d added cat-file</seg>
      </tuv>
      <tuv lang="ES" changedate="20120728T092736Z" changeid="juan">
        <seg>pick f7f3f6d changed my name a bit
	edit 310154e updated README formatting and added blame
	pick a5f4a0d added cat-file</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>commit 1c002dd4b536e7479fe34593e72e6c6c1819e53b
	Author: Scott Chacon &lt;schacon@gmail.com&gt;
	Date:   Thu Dec 11 14:58:32 2008 -0800</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T095158Z" changeid="juan">
        <seg>commit 1c002dd4b536e7479fe34593e72e6c6c1819e53b
	Author: Scott Chacon &lt;schacon@gmail.com&gt;
	Date:   Thu Dec 11 14:58:32 2008 -0800</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you run `git diff` on that, you see something interesting:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T104206Z" changeid="juan">
        <seg>Si se lanza un `git diff` sobre ella, se puede apreciar algo muy interesante:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The HTTP method is simple but a bit inefficient.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T071918Z" changeid="juan">
        <seg>HTTP es un protocolo simple, pero ineficiente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is also a nice option for quickly grabbing work from someone else’s working repository.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Este camino es también util para recuperar rápidamente el contenido del repositorio de trabajo de alguna otra persona.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Each level overwrites values in the previous level, so values in `.git/config` trump those in `/etc/gitconfig`, for instance.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cada nivel sobreescribe los valores del nivel anterior; es decir lo configurado en '.git/config' tiene primacia con respecto a lo configurado en '/etc/gitconfig', por ejemplo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git apply --whitespace=warn &lt;patch&gt;</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git apply --whitespace=warn &lt;patch&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>At this point, you have 11 objects — 4 blobs, 3 trees, 3 commits, and 1 tag:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110810T225908Z" changeid="juan">
        <seg>En este momento, tienes 11 objetos --4 binarios, 3 árboles, 3 confirmaciones de cambios y 1 etiqueta--. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you run a mail client that can save several e-mails out in mbox format, you can save entire patch series into a file and then use git am to apply them one at a time.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si tienes un cliente de correo electrónico capaz de guardar varios mensajes en formato mbox, podrás guardar series completas de parches en un mismo archivo; y luego usar 'git am' para irlos incorporando secuencialmente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>&gt;&gt; path = '.git/objects/' + sha1[0,2] + '/' + sha1[2,38]
	=&gt; &quot;.git/objects/bd/9dbf5aae1a3862dd1526723246b20206e5fc37&quot;
	&gt;&gt; require 'fileutils'
	=&gt; true
	&gt;&gt; FileUtils.mkdir_p(File.dirname(path))
	=&gt; &quot;.git/objects/bd&quot;
	&gt;&gt; File.open(path, 'w') { |f| f.write zlib_content }
	=&gt; 32</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T182403Z" changeid="juan">
        <seg>&gt;&gt; path = '.git/objects/' + sha1[0,2] + '/' + sha1[2,38]
	=&gt; &quot;.git/objects/bd/9dbf5aae1a3862dd1526723246b20206e5fc37&quot;
	&gt;&gt; require 'fileutils'
	=&gt; true
	&gt;&gt; FileUtils.mkdir_p(File.dirname(path))
	=&gt; &quot;.git/objects/bd&quot;
	&gt;&gt; File.open(path, 'w') { |f| f.write zlib_content }
	=&gt; 32</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The `SHA^@` syntax resolves to all the parents of that commit.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La sintaxis 'SHA^@' recupera todos los padres de esa confirmación de cambios (commit).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Oops — it looks like that tree object isn’t in loose format on the server, so you get a 404 response back.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T130745Z" changeid="juan">
        <seg>Pero... ¡Ay!... parece que el objeto árbol no está suelto en el servidor. Por lo que obtienes una respuesta 404 (objeto no encontrado).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Here’s an example that hard-resets the master branch in your test repository to an older commit and then recovers the lost commits.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T133050Z" changeid="juan">
        <seg>Vamos a ver un ejemplo de un retroceso a una confirmación (commit) antigua en la rama principal de tu repositorio de pruebas, y cómo podriamos recuperar las confirmaciones perdidas en este caso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git stash apply --index
	# On branch master
	# Changes to be committed:
	#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)
	#
	#      modified:   index.html
	#
	# Changed but not updated:
	#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
	#
	#      modified:   lib/simplegit.rb
	#</seg>
      </tuv>
      <tuv lang="ES" changedate="20120728T074558Z" changeid="juan">
        <seg>$ git stash apply --index
	# On branch master
	# Changes to be committed:
	#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)
	#
	#      modified:   index.html
	#
	# Changed but not updated:
	#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
	#
	#      modified:   lib/simplegit.rb
	#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Even if you set up and run your own server internally, you may still want to use a public hosting site for your open source code — it’s generally easier for the open source community to find and help you with.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Incluso en el caso de que tengas tu propio servidor interno, puede resultar interesante utilizar también un lugar público; para albergar tu código abierto --normalmente, ahí suele ser más sencillo de localizar por parte de la comunidad--</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The Git data is served as basic static files (see Chapter 9 for details about exactly how it’s served).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Los contenidos Git se sirven como archivos estáticos básicos (ver el Capitulo 9 para más detalles sobre servicios).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is essentially what Git does when you run the `git add` and `git commit` commands — it stores blobs for the files that have changed, updates the index, writes out trees, and writes commit objects that reference the top-level trees and the commits that came immediately before them.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T145449Z" changeid="juan">
        <seg>Esto es básicamente lo que hace Git cada vez que utilizas los comandos `git add` y `git commit`: guardar objetos binarios (blobs) para los archivos modificados, actualizar el índice, escribir árboles (trees), escribir objetos de confirmación de cambios (commits) que los referencian y relacionar cada uno de ellos con su inmediato precedente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>How often do you contribute?</seg>
      </tuv>
      <tuv lang="ES">
        <seg>¿Con qué frecuencia?.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>A number of developers are nodes — consumers of that hub — and synchronize to that one place (see Figure 5-1).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Unos cuantos desarrolladores son nodos de trabajo --consumidores de dicho repositorio-- y se sincronizan con dicho punto central. (ver Figura 5-1).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>path old-file old-hex old-mode new-file new-hex new-mode</seg>
      </tuv>
      <tuv lang="ES">
        <seg>path old-file old-hex old-mode new-file new-hex new-mode</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can daemonize this process a number of ways, depending on the operating system you’re running.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Este proceso se puede demonizar de diferentes maneras, dependiendo del sistema operativo con el que trabajas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>By default, Git uses whatever you’ve set as your default text editor or else falls back to the Vi editor to create and edit your commit and tag messages.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por defecto, Git utiliza cualquier editor que hayas configurado como editor de texto por defecto de tu sistema. O, si no lo has configurado, utilizará Vi como editor para crear y editar las etiquetas y mensajes de tus confirmaciones de cambio (commit).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You also need to make sure these tools are executable:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Además has de asegurarte de que estas herramientas son ejecutables:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When that value is set, Git colors its output if the output goes to a terminal.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Ajustando así este parámetro, Git colorea sus resultados cuando estos se muestran en un terminal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can rebase the server branch onto the master branch without having to check it out first by running `git rebase [basebranch] [topicbranch]` — which checks out the topic branch (in this case, `server`) for you and replays it onto the base branch (`master`):</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes reorganizar (rebase) la rama 'server' sobre la rama 'master' sin necesidad siquiera de comprobarlo previamente, usando el comando 'git rebase [ramabase] [ramapuntual]'. El cual activa la rama puntual ('server' en este caso) y la aplica sobre la rama base ('master' en este caso):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Lieutenants merge the developers’ topic branches into their master branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Los tenienentes fusionan (merge) las ramas puntuales de los desarrolladores sobre su propia rama master.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can also set up a graphical merge conflict–resolution tool instead of having to resolve conflicts manually.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes incluso configurar una herramienta gráfica para la resolución de conflictos, en lugar de resolverlos manualmente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is an important point to remember: Git resets your working directory to look like the snapshot of the commit that the branch you check out points to.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Es importante recordar que Git revierte la carpeta de trabajo exactamente al estado en que estaba en la confirmación (commit)  apuntada por la rama que activamos (checkout) en cada momento. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When Git packs objects, it looks for files that are named and sized similarly, and stores just the deltas from one version of the file to the next.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T114800Z" changeid="juan">
        <seg>Cuando Git empaqueta objetos, va buscando archivos de igual nombre y tamaño similar. Almacenando únicamente las diferencias entre una versión de cada archivo y la siguiente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You need to edit the script so that it stops at the commit you want to edit.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T185506Z" changeid="juan">
        <seg>Para que el script se detenga en cada confirmación de cambios a modificar, hay que editarlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## Git Hooks ##</seg>
      </tuv>
      <tuv lang="ES">
        <seg>## Puntos de enganche Git ##</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When that is done, click the &quot;Create Repository&quot; button.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cuando lo hayas escrito, clica sobre el botón &quot;Crear Repositorio&quot; (&quot;Create Repository&quot;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can disable settings by either leaving them out of the setting string or prepending a `-` in front of the value.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes desactivarlos tanto dejandolos fuera de la cadena de ajustes, como añadiendo el prefijo '-' delante del valor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git push origin :topic</seg>
      </tuv>
      <tuv lang="ES" changedate="20110817T154445Z" changeid="juan">
        <seg>$ git push origin :topic</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This command gives you a diff, but it may be misleading.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Este comando te dará las diferencias, pero puede ser engañoso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The next thing you’ll notice is the error message.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Lo segundo que se puede apreciar es el mensaje de error:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is the SHA-1 hash — a checksum of the content you’re storing plus a header, which you’ll learn about in a bit.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T143037Z" changeid="juan">
        <seg>Este checksum hash SHA-1  es una suma de comprobación del contenido que estás guardando más una cabecera; cabecera sobre la que trataremos en breve.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This section has covered a number of common workflows for dealing with several very different types of Git projects you’re likely to encounter and introduced a couple of new tools to help you manage this process.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En esta sección hemos visto unos cuantos de los flujos de trabajo más habituales para lidiar con distintos tipos de proyectos Git. Y hemos introducido un par de nuevas herramientas para ayudarte a gestionar estos procesos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Compressing objects: 100% (13/13), done.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110810T231548Z" changeid="juan">
        <seg>Compressing objects: 100% (13/13), done.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git commit -m 'initial commit'
	$ git remote add origin git@gitserver:/opt/git/project.git
	$ git push origin master</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git commit -m 'initial commit'
	$ git remote add origin git@gitserver:/opt/git/project.git
	$ git push origin master</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>They’re often used to enforce certain policies, although it’s important to note that these scripts aren’t transferred during a clone.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>A menudo, se suelen utilizar para obligar a seguir ciertas reglas; aunque es importante indicar que estos script no se transfieren durante el clonado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It’s important to remember when you’re doing all this that these branches are completely local.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Es importante recordar que, mientras estás haciendo todo esto, todas las ramas son completamente locales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can use this to find your blob’s name:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T110158Z" changeid="juan">
        <seg>Puedes usar esta información para localizar el nombre del objeto binario:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Although Git can check to make sure each object still matches its SHA-1 checksum and points to valid objects, it doesn’t do that by default on every push.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Aunque Git tiene la capacidad para asegurarse de que cada objeto sigue casando con su suma de control SHA-1 y sigue apuntando a objetos válidos. No lo suele hacer en todos y cada uno de los envios (push).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>What gets interesting is that you can fairly easily merge changes from one of the branches to the other.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T163011Z" changeid="juan">
        <seg>Lo que hace interesante este método es la posibilidad que brinda de fusionar cambios de una rama sobre la otra de forma sencilla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you’ve committed and then you want to change the snapshot you committed by adding or changing files, possibly because you forgot to add a newly created file when you originally committed, the process works basically the same way.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T121750Z" changeid="juan">
        <seg>Si se desea cambiar la instantánea (snapshot) de archivos en la última confirmación de cambios, habitualmente por haber tenido algún descuido al añadir algún archivo de reciente creación. El proceso a seguir es básicamente el mismo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The only thing left is to enforce fast-forward-only pushes.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Lo único que nos queda por implementar es un mecanismo para limitar los envios a envios de avance rápido (Fast-Forward-Only pushes).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ cat gitosis.conf
	[gitosis]</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ cat gitosis.conf
	[gitosis]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you download and install the `exiftool` program, you can use it to convert your images into text about the metadata, so at least the diff will show you a textual representation of any changes that happened:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si te descargas e instalas el programa 'exiftool', puedes utilizarlo para convertir tus imagenes a textos (metadatos), de tal forma que diff podrá al menos mostrarte algo útil de cualquier cambio que se produzca:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>edit f7f3f6d changed my name a bit
	pick 310154e updated README formatting and added blame
	pick a5f4a0d added cat-file</seg>
      </tuv>
      <tuv lang="ES" changedate="20120728T085822Z" changeid="juan">
        <seg>edit f7f3f6d changed my name a bit
	pick 310154e updated README formatting and added blame
	pick a5f4a0d added cat-file</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The contributor pushes to their own public copy.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La persona colaboradora envia (push) a su propia copia pública.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For example, you can get the same results as in the previous example by typing `git log origin/master..` — Git substitutes HEAD if one side is missing.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T121350Z" changeid="juan">
        <seg>Por ejemplo, se pueden obtener los mismos resultados tecleando `git log origin/master..`, ya que git sustituye HEAD en la parte faltante. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now your project history has diverged (see Figure 3-9).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Ahora el registro de tu proyecto diverge (ver Figura 3-9).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It uses the same data-transfer mechanism as the SSH protocol but without the encryption and authentication overhead.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Utiliza los mismos mecanismos de transmisión de datos que el protocolo SSH, pero sin la sobrecarga de la encriptación ni de la autentificación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>One of the first things you did was set up your name and e-mail address:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Una de las primeras acciones que has realizado con Git ha sido el configurar tu nombre y tu dirección de correo-e.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$projects_list = &quot;/home/git/gitosis/projects.list&quot;;
	$projectroot = &quot;/home/git/repositories&quot;;
	$export_ok = &quot;git-daemon-export-ok&quot;;
	@git_base_url_list = ('git://gitserver');</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$projects_list = &quot;/home/git/gitosis/projects.list&quot;;
	$projectroot = &quot;/home/git/repositories&quot;;
	$export_ok = &quot;git-daemon-export-ok&quot;;
	@git_base_url_list = ('git://gitserver');</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In many instances, you’ll have two or three developers with a few commits a day, or possibly less for somewhat dormant projects.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En muchas ocasiones, tendrás dos o tres desarrolladores, con tan solo unas pocas confirmaciones de cambios (commits) diarias; e incluso menos en algunos proyectos durmientes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>*** Commands ***
	  1: status     2: update      3: revert     4: add untracked
	  5: patch      6: diff        7: quit       8: help
	What now&gt;</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T211820Z" changeid="juan">
        <seg>*** Commands ***
	  1: status     2: update      3: revert     4: add untracked
	  5: patch      6: diff        7: quit       8: help
	What now&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The `commit-msg` hook takes one parameter, which again is the path to a temporary file that contains the current commit message.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El punto de enganche 'commit-msg' recibe un parámetro: la ubicación (path) del archivo temporal que contiene el mensaje de confirmación actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git can color its output to your terminal, which can help you visually parse the output quickly and easily.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Git puede marcar con colores los resultados que muestra en tu terminal, ayudandote así a leerlos más facilmente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>I’ll demonstrate how to send a patch via Gmail, which happens to be the e-mail agent I use; you can read detailed instructions for a number of mail programs at the end of the aforementioned `Documentation/SubmittingPatches` file in the Git source code.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Voy a indicar cómo enviar un parche usando Gmail, que da la casualidad de que es el agente de correo utilizado por mí. En el final del anteriormente citado documento, `Documentation/SubmittingPatches`, puedes leer instrucciones detalladas para otros agentes de correo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you have Git version 1.6.2 or later, you can also use the `--track` shorthand:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si tienes la versión 1.6.2 de Git, o superior, puedes utilizar también el parámetro '--track':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git add README test.rb LICENSE
	$ git commit -m 'initial commit of my project'</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git add README test.rb LICENSE
	$ git commit -m 'initial commit of my project'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now that you have a bare copy of your repository, all you need to do is put it on a server and set up your protocols.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Ahora que ya tienes una copia básica de tu repositorio, todo lo que te resta por hacer es colocarlo en un servidor y ajustar los protocolos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This scenario often includes a canonical repository that represents the &quot;official&quot; project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Habitualmente, este escenario suele incluir un repositorio canónico, representante &quot;oficial&quot; del proyecto. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## Summary ##</seg>
      </tuv>
      <tuv lang="ES">
        <seg>## Recapitulación ##</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Most of the time, this command does nothing.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T091330Z" changeid="juan">
        <seg>La mayor parte de las veces, este comando no hace nada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Type the name of the tool you’d rather use.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tecleando el nombre de dicha herramienta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For security reasons, it is strongly encouraged to have this daemon run as a user with read-only permissions to the repositories – you can easily do this by creating a new user 'git-ro' and running the daemon as them.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por razones de seguridad, es recomendable lanzar este demonio con un usuario que tenga unicamente permisos de lectura en los repositorios --lo puedes hacer creando un nuevo usuario 'git-ro' y lanzando el demonio con él--.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you decide not to use Gitosis, but you want to set up a Git daemon, you’ll have to run this on each project you want the Git daemon to serve:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si decides no utilizar Gitosis, pero sigues queriendo utilizar un demonio Git, has de lanzar este comando en cada proyecto que desees servír vía el demonio Git:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can calculate the SHA-1 value of a string in Ruby by including the SHA1 digest library with the `require` command and then calling `Digest::SHA1.hexdigest()` with the string:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T145734Z" changeid="juan">
        <seg>En Ruby, para calcular el valor SHA-1 de una cadena de texto: has de incluir la libreria de generación SHA1 con el comando `require` y llamar luego a la orden `Digest::SHA1.hexdigest()`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0415.png
Figure 4-15.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0415.png
Figura 4-15.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When you have a Git repository locally, add GitHub as a remote and push up your master branch:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Una vez tengas un repositorio local Git, añadele el sitio GitHub como un remoto y envia (push) allí tu rama principal:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It takes the Git repository by itself, without a working directory, and creates a directory specifically for it alone.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Se coge el repositorio Git en sí mismo, sin la carpeta de trabajo, y se crea una copia en una nueva carpeta específica para él solo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Merge branch 'iss53'</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Merge branch 'iss53'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The difference is how you submit them to the project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La diferencia está en la forma de enviarlos al proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Remote branches act as bookmarks to remind you where the branches on your remote repositories were the last time you connected to them.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Las ramas remotas funcionan como marcadores, para recordarte en qué estado se encontraban tus repositorios remotos la última vez que conectaste con ellos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git update-ref refs/heads/master 1a410efbd13591db07496601ebc7a059dd55cfe9</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T191256Z" changeid="juan">
        <seg>$ git update-ref refs/heads/master 1a410efbd13591db07496601ebc7a059dd55cfe9</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Instead of getting the diff output on the command line, Git fires up P4Merge, which looks something like Figure 7-1.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En lugar de mostrar las diferencias por línea de comandos, Git lanzará P4Merge, que tiene una pinta como la de la Figura 7-1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When you save that, you have a single commit that introduces the changes of all three previous commits.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120728T092227Z" changeid="juan">
        <seg>Al guardar esto, se tendrá una sola confirmación de cambios que introducirá todos los cambios que estaban en las tres confirmaciones de cambios previamente existentes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Suppose you’re done with a remote branch — say, you and your collaborators are finished with a feature and have merged it into your remote’s `master` branch (or whatever branch your stable codeline is in).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Imagina que ya has terminado con una rama remota. Es decir, tanto tu como tus colaboradores habeis completado una determinada funcionalidad y la habeis incorporado (merge) a la rama 'master' en el remoto (o donde quiera que tengais la rama de código estable).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To git@gitserver:project.git
	 !</seg>
      </tuv>
      <tuv lang="ES">
        <seg>To git@gitserver:project.git
	 !</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can’t directly compare two versions unless you check them out and scan them manually, right?</seg>
      </tuv>
      <tuv lang="ES">
        <seg>No puedes comparar directamente dos versiones, a no ser que extraigas ambas y las compares manualmente, ¿no?.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This creates a new pointer at the same commit you’re currently on (see Figure 3-4).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto creará un nuevo apuntador apuntando a la misma confirmación donde estés actualmente (ver Figura 3-4).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can use `git merge -s subtree` and it will work fine; but Git will also merge the histories together, which you probably don’t want.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T173609Z" changeid="juan">
        <seg>Utilizando el comando `git merge -s subtree`, que funciona correctamente; pero fusionando también los historiales entre sí. Un efecto secundario que posiblemente no interese.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This command puts conflict markers in any files it has issues with, much like a conflicted merge or rebase operation.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Este comando pondrá marcadores de conflicto en cualquier archivo con problemas, de forma similar a como lo haría una operación de fusión (merge) o de reorganización (rebase).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Say you have your repositories in the `/opt/git` directory, and an Apache server is running on your machine.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>suponiendo que tengas los repositorios en la carpeta '/opt/git', y que hay un servidor Apache en marcha en tu máquina.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>A remote repository is generally a _bare repository_ — a Git repository that has no working directory.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Un repositorio remoto es normalmente un _repositorio básico mínimo_, un repositorio Git sin carpeta de trabajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This moves HEAD to point to the testing branch (see Figure 3-6).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto mueve el apuntador HEAD a la rama 'testing' (ver Figura 3-6).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4
	test content</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git cat-file -p d670460b4b4aece5915caf5c68d12f560a9fe3e4
	test content</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>First, you basically have to use it if you want authenticated write access to your repository over a network.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En primer lugar, necesitas usarlo si quieres un acceso de escritura autentificado a tu repositorio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>First, you need to get the Git source code, which GitWeb comes with, and generate the custom CGI script:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Primero, necesitas el código fuente de Git, que viene con GitWeb, para generar un script CGI personalizado:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git status
	# On branch master
	# Changes to be committed:
	#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)
	#
	#      modified:   index.html
	#
	# Changed but not updated:
	#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
	#
	#      modified:   lib/simplegit.rb
	#</seg>
      </tuv>
      <tuv lang="ES" changedate="20120702T085010Z" changeid="juan">
        <seg>$ git status
	# On branch master
	# Changes to be committed:
	#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)
	#
	#      modified:   index.html
	#
	# Changed but not updated:
	#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
	#
	#      modified:   lib/simplegit.rb
	#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>First it confirms where you want to save the key (`.ssh/id_rsa`), and then it asks twice for a passphrase, which you can leave empty if you don’t want to type a password when you use the key.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Como se vé, este comando primero solicita confirmación de dónde van a a guardarse las claves ('.ssh/id_rsa'), y luego solicita, dos veces, una contraseña (passphrase), contraseña que puedes dejar en blanco si no deseas tener que teclearla cada vez que uses la clave.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you merge in the other branch, instead of having merge conflicts with the database.xml file, you see something like this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Al fusionar con otra rama, en lugar de tener conflictos de fusión con el archivo database.xml, obtendrás algo como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Again, having multiple long-running branches isn’t necessary, but it’s often helpful, especially when you’re dealing with very large or complex projects.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Aunque no es obligatorio el trabajar con ramas de larga duración, realmente es práctico y útil. Sobre todo en proyectos largos o complejos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When you commit in Git, Git stores a commit object that contains a pointer to the snapshot of the content you staged, the author and message metadata, and zero or more pointers to the commit or commits that were the direct parents of this commit: zero parents for the first commit, one parent for a normal commit, and multiple parents for a commit that results from a merge of two or more branches.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En cada confirmación de cambios (commit), Git almacena un punto de control que conserva: un apuntador a la copia puntual de los contenidos preparados (staged), unos metadatos con el autor y el mensaje explicativo, y uno o varios apuntadores a las confirmaciones (commit) que sean padres directos de esta (un padre en los casos de confirmación normal, y múltiples padres en los casos de estar confirmando una fusión (merge) de dos o mas ramas).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Jessica first needs to merge those changes in with her own before she can push to the server.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Jessica necesita fusionar (merge) dichos cambios con los suyos antes de poder enviarlos al servidor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Probably the most common transport protocol for Git is SSH.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Probablemente, SSH sea el protocolo más habitual para Git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>As you initially make commits, you’re given a master branch that points to the last commit you made.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Con la primera confirmación de cambios que realicemos, se creará esta rama principal 'master' apuntando a dicha confirmación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Getting in the habit of creating quality commit messages makes using and collaborating with Git a lot easier.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si nos acostumbramos a poner siempre mensajes de calidad en las confirmaciones de cambios, facilitaremos en gran medida el trabajo y la colaboración con Git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now, each user that does this has to send their public key to you or whoever is administrating the Git server (assuming you’re using an SSH server setup that requires public keys).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tras generarla, cada usuario ha de encargarse de enviar su clave pública a quienquiera que administre el servidor Git (en el caso de que este esté configurado con SSH y así lo requiera).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>pick f7f3f6d changed my name a bit
	pick 310154e updated README formatting and added blame
	pick a5f4a0d added cat-file</seg>
      </tuv>
      <tuv lang="ES" changedate="20120728T090855Z" changeid="juan">
        <seg>pick f7f3f6d changed my name a bit
	pick 310154e updated README formatting and added blame
	pick a5f4a0d added cat-filepick f7f3f6d changed my name a bit
	pick 310154e updated README formatting and added blame
	pick a5f4a0d added cat-file</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Binary Files ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Archivos binarios ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now, you can use the `write-tree` command to write the staging area out to a tree object.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T195049Z" changeid="juan">
        <seg>Tras esto, puedes usar el comando `write-tree` para escribir el área de preparacón a un objeto tipo árbol.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This command shows you any commits in your current branch that aren’t in the `master` branch on your `origin` remote.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T192118Z" changeid="juan">
        <seg>Este comando muestra las confirmaciones de cambio de la rama activa que no están aún en la rama 'master' del repositorio remoto 'origin'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When you commit, you see something like this:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T104859Z" changeid="juan">
        <seg>Cuando se realiza una confirmación de cambios, se suele ver algo así como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Start by clicking the &quot;create a new one&quot; link next to Your Repositories on the user dashboard.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes empezar clicando sobre el enlace &quot;crear uno nuevo&quot; (&quot;create a new one&quot;), en la zona 'Tus repositorios' ('Your Repositories') del panel de control.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It summarizes all the commits in the range you give it; for example, the following gives you a summary of all the commits since your last release, if your last release was named v1.0.1:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Este comando resume todas las confirmaciones de cambios (commits) en el rango que le indiques. Por ejemplo, si tu último lanzamiento de versión lo fué de la v1.0.1:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The “clean” filter is run when files are staged.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El filtro &quot;clean&quot; se usa al almacenar (staged).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You’ve covered most of the major ways that you can customize your Git client and server to best fit your workflow and projects.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Se han visto las principales vías por donde puedes personalizar tanto tu cliente como tu servidor Git para que se ajusten a tu forma de trabajar y a tus proyectos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## Git Configuration ##</seg>
      </tuv>
      <tuv lang="ES">
        <seg>## Configuración de Git ##</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0308.png
Figure 3-8.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0308.png
Figura 3-8.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The command to do this is `git archive`:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El comando para hacerlo es 'git archive':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>A diferencia de otros sistemas de control de versiones, Git promueve un ciclo de desarrollo donde las ramas se crean y se unen ramas entre sí, incluso varias veces en el mismo día.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>A diferencia de otros sistemas de control de versiones, Git promueve un ciclo de desarrollo donde las ramas se crean y se unen ramas entre sí, incluso varias veces en el mismo día.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Let’s re-add the public keys for John, Josie, and Jessica:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por ejemplo, para añadir las claves públicas de John, Josie y Jessica:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>#### E-mail Workflow Hooks ####</seg>
      </tuv>
      <tuv lang="ES">
        <seg>#### Puntos en el flujo de trabajo del correo electrónico ####</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Putting that in your `update` script will reject updates that contain commits that have messages that don’t adhere to your rule.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Poniendo esto en tu script 'update', serán rechazadas todas las actualizaciones que contengan cambios con mensajes que no se ajusten a tus reglas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you don’t, people will hate you, and you’ll be scorned by friends and family.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Pero si no la sigues, la gente te odiará y serás despreciado por tus familiares y amigos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If one developer clones, makes changes, and then tries to push their changes while another developer has pushed in the meantime, the server will reject that developer’s changes.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si uno de los desarrolladores clona, hace cambios y luego intenta enviarlos; y otro desarrollador ha enviado otros cambios durante ese tiempo; el servidor rechazará los cambios del segundo desarrollador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Entender y manejar esta opción te proporciona una poderosa y exclusiva herramienta que puede, literalmente, cambiar la forma en la que desarrollas.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Entender y manejar esta opción te proporciona una poderosa y exclusiva herramienta que puede, literalmente, cambiar la forma en la que desarrollas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Some larger projects also have a `proposed` or `pu` (proposed updates) branch that has integrated branches that may not be ready to go into the `next` or `master` branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Algunos proyectos muy grandes suelen tener una rama denominada 'propuestas' o 'pu' (proposed updates). Donde suele estar todo aquello integrado desde otras ramas, pero que aún no está listo para ser incorporado a las ramas 'siguiente' o 'master'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>hahahahaha!</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T110926Z" changeid="juan">
        <seg>hahahahaha!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>However, before you do that, note that if your working directory or staging area has uncommitted changes that conflict with the branch you’re checking out, Git won’t let you switch branches.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Pero, antes de poder hacer eso, hemos de tener en cuenta  que teniendo cambios aún no confirmados en la carpeta de trabajo o en el área de preparación, Git no nos permitirá saltar a otra rama con la que podríamos tener conflictos. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The `bisect` command does a binary search through your commit history to help you identify as quickly as possible which commit introduced an issue.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T074659Z" changeid="juan">
        <seg>Este comando `bisect` realiza una búsqueda binaria por todo el historial de confirmaciones de cambio, para intentar localizar lo más rápido posible aquella confirmación de cambios en la que se pudieron introducir los problemas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Look back at the example commit history in Figure 6-1.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T202321Z" changeid="juan">
        <seg>Volviendo sobre la historia de proyecto mostrada en la figura 6-1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>That means Gitosis recognized you but shut you out because you’re not trying to do any Git commands.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Indicandote que Gitosis te ha reconocido, pero te está hechando debido a que no estás intentando lanzar ningún comando Git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is really useful.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T070010Z" changeid="juan">
        <seg>Lo cual es realmente útil.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Finally, `git apply` is an &quot;apply all or abort all&quot; model where either everything is applied or nothing is, whereas `patch` can partially apply patchfiles, leaving your working directory in a weird state.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por ultimo, citar que 'git apply' sigue un modelo de &quot;aplicar todo o abortar todo&quot;, incorporando todos los cambios o no incorporando ninguno. Mientras que 'patch' puede incorporar cambios parcialmente, dejando tu carpeta de trabajo en un estado inconsistente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## Contributing to a Project ##</seg>
      </tuv>
      <tuv lang="ES">
        <seg>## Contribuyendo a un proyecto ##</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If they want Git to do that automatically each time they run `git push origin`, they can add a `push` value to their config file:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T130130Z" changeid="juan">
        <seg>Y, para que se haga de forma automática cada vez que ejecute `git push origin`, puede añadir una entrada `push` a su archivo de configuración:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In the simplest terms, a bare repository is the contents of your project’s `.git` directory and nothing else.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Básicamente, un repositorio básico mínimo son los contenidos de la carpeta '.git', tal cual, sin nada más. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The author information is taken from the e-mail’s `From` and `Date` headers, and the message of the commit is taken from the `Subject` and body (before the patch) of the e-mail.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La información sobre el autor o autora la recoge de las cabeceras 'From' (Remitente) y 'Date' (Fecha). Y el mensaje para la confirmación (commit) lo recoge de 'Subject' (Asunto) y del cuerpo del correo electrónico.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The HEAD file is a symbolic reference to the branch you’re currently on.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T192135Z" changeid="juan">
        <seg>El archivo HEAD es una referencia simbólica a la rama donde te encuentras en cada momento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>By default, Git doesn’t check for consistency all the objects it receives during a push.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por defecto, Git no suele comprobar la consistencia de todos los objetos que recibe durante un envio (push).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ echo 'first commit' | git commit-tree d8329f
	fdf4fc3344e67ab068f836878b6c4951e3b15f3d</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T180337Z" changeid="juan">
        <seg>$ echo 'first commit' | git commit-tree d8329f
	fdf4fc3344e67ab068f836878b6c4951e3b15f3d</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Each time you commit or change branches, the reflog is updated.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T142842Z" changeid="juan">
        <seg>Cada vez que confirmas cambios o cambias de rama, el registro (reflog) es actualizado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>I put Chapter 1 of this book into Git, added some text to a paragraph, and saved the document.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>He puesto el capítulo 1 de este libro en Git, le he añadido algo de texto a un párrafo y he guardado el documento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can also verify that this is a tree object:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T195132Z" changeid="juan">
        <seg>También puedes comprobar si realmente es un objeto tipo árbol:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Instead of being primarily based on the project, GitHub is user centric.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En lugar de estar focalizado en los proyectos, GitHub gira en torno a los usuarios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>She runs a `git fetch` to pull down those changes:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Ella lanza un 'git fetch' para recuperar dichos cambios:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git operates slightly differently if you explicitly specify `file://` at the beginning of the URL.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Git trabaja ligeramente distinto si indicas 'file://' de forma explícita al comienzo de la URL.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git cat-file -p 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a &gt; test.txt
	$ cat test.txt
	version 2</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git cat-file -p 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a &gt; test.txt
	$ cat test.txt
	version 2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The process works as follow (see Figure 5-2):</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El proceso funciona de la siguiente manera (ver Figura 5-2):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Next, you’ll write the other two commit objects, each referencing the commit that came directly before it:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T200014Z" changeid="juan">
        <seg>Puedes seguir adelante, escribiendo los otros dos objetos de confirmación de cambios. Y relacionando cada uno de ellos con su inmediato anterior:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To remove a file named passwords.txt from your entire history, you can use the `--tree-filter` option to `filter-branch`:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T173610Z" changeid="juan">
        <seg>Por ejemplo, para quitar un archivo llamado passwords.txt del repositorio, se puede emplear la opción `--tree-filter` del comando `filter-branch`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can decide what files go into which commits right before you commit with the staging area, you can decide that you didn’t mean to be working on something yet with the stash command, and you can rewrite commits that already happened so they look like they happened in a different way.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T121456Z" changeid="juan">
        <seg>Las decisiones sobre qué archivos van en qué confirmaciones de cambio se toman justo inmediatamente antes de confirmar, utilizando para ello el área de preparación (staging area). En cualquier momento se puede decidir dejar de trabajar en una cierta vía y arrancar en otra, utilizando el comando de guardado rápido (stash). Y también es posible reescribir confirmaciones de cambio ya realizadas, para que se muestren como si hubieran sido realizadas de otra forma.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>What you really want to see are the changes added to the topic branch — the work you’ll introduce if you merge this branch with master.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y lo que realmente querías ver eran los cambios introducidos por la rama puntual, --el trabajo que vas a introducir si la fusionas con la rama 'master'--.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It turns out you can do this fairly well using Git attributes.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Pero resulta que puedes hacerlo bastante mejor utilizando los atributos Git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This can take several seconds or even minutes, depending on the size of the project, whereas in Git the process is always instantaneous.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Lo que puede llevar segundos o incluso minutos, dependiendo del tamaño del proyecto. Mientras que en Git el proceso es siempre instantáneo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Do as I say, not as I do.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Observa mis palabras, no mis hechos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Your staging area now has the new version of test.txt as well as the new file new.txt.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T195235Z" changeid="juan">
        <seg>El área de preparación contendrá ahora la nueva versión de test.txt, así como el nuevo archivo new.txt.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This doesn’t affect the commit data in any way — the SSH user you connect as doesn’t affect the commits you’ve recorded.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto no afecta a los datos de las confirmaciones (commit), ya que el usuario SSH con el que te conectes no es relevante para las confirmaciones de cambios que registres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Short SHA ###</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T095028Z" changeid="juan">
        <seg>### SHA corto ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Adding Collaborators ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Añadiendo colaboradores ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git gc --auto</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T092113Z" changeid="juan">
        <seg>$ git gc --auto</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>After a topic branch merge.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tras fusionar una rama puntual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The GitHub user dashboard.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El panel de control del usuario GitHub.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Because commits contain the SHA-1 values of their parents, this command changes every commit SHA in your history, not just those that have the matching e-mail address.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T200322Z" changeid="juan">
        <seg>Y, debido a que cada confirmación de cambios contiene el código SHA-1 de sus ancestros, este comando cambia también todos los códigos SHA del historial; no solamente los de las confirmaciones de cambio que contenian la dirección indicada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git commit -m 'initial commit'</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git commit -m 'initial commit'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This tells Git that any file that matches this pattern (.doc) should use the &quot;word&quot; filter when you try to view a diff that contains changes.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Así decimos a Git que sobre cualquier archivo coincidente con el patrón indicado, (.doc), ha de utilizar el filtro &quot;word&quot; cuando intentente hacer una comparación con él.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The server-side hooks are for Git server operations such as receiving pushed commits.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Los del lado servidor están relacionados con operaciones tales como la recepción de contenidos enviados (push) a un servidor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In the 1.6 series of Git, you can use the Git attributes functionality to effectively diff binary files.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>A partir de la versión 1.6, puedes utilizar los atributos Git para comparar archivos binarios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Commit Guidelines ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Reglas para las confirmaciones de cambios (commits) ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Because Git doesn’t have monotonically increasing numbers like 'v123' or the equivalent to go with each commit, if you want to have a human-readable name to go with a commit, you can run `git describe` on that commit.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Debido a que Git no dispone de una serie monótona ascendente de números para cada confirmación de cambios (commit), si deseas tener un nombre humanamente comprensible por cada confirmación, has de utilizar el comando 'git describe'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you do this immediately after an import, before anyone has started to base work on the commit, you’re fine — otherwise, you have to notify all contributors that they must rebase their work onto your new commits.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T134553Z" changeid="juan">
        <seg>No tendrás problemas si lo haces inmediatamente despues de una importación; o justo antes de que alguien haya comenzado a trabajar con la confirmación de cambios modificada. Pero si no es el caso, tendrás que avisar a todas las personas que hayan contribuido. Porque se verán obligadas a reorganizar su trabajo en base a tus nuevas confirmaciones de cambio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The most basic is the _Local protocol_, in which the remote repository is in another directory on disk.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El más básico es el _Protocolo Local_, donde el repositorio remoto es simplemente otra carpeta en el disco.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Jessica’s history now looks like Figure 5-8.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El historial de Jessica es en estos momentos como se muestra en la figura 5-8.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you set this as your 'git' user’s login shell, then the 'git' user can’t have normal shell access to your server.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si lo configuras como el shell de inicio de sesión de tu usuario 'git', dicho usuario no tendrá acceso al shell normal del servidor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The Git daemon checks that the command can be run and that the repository exists and has public permissions.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T132234Z" changeid="juan">
        <seg>El demonio Git realizará las comprobaciones de si el comando se puede lanzar, si el repositorio existe y si tenemos permisos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git checkout master
	$ git merge --squash -s subtree --no-commit rack_branch
	Squash commit -- not updating HEAD
	Automatic merge went well; stopped before committing as requested</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T163424Z" changeid="juan">
        <seg>$ git checkout master
	$ git merge --squash -s subtree --no-commit rack_branch
	Squash commit -- not updating HEAD
	Automatic merge went well; stopped before committing as requested</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The branch that HEAD points to moves forward with each commit.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La rama apuntada por HEAD avanza con cada confirmación de cambios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git status
	# On branch master
	# Changes to be committed:
	#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)
	#
	#      new file:   .gitmodules
	#      new file:   rack
	#</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T103638Z" changeid="juan">
        <seg>$ git status
	# On branch master
	# Changes to be committed:
	#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)
	#
	#      new file:   .gitmodules
	#      new file:   rack
	#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To tell Git to use it as the default message that appears in your editor when you run `git commit`, set the `commit.template` configuration value:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para indicar a Git que lo utilice como mensaje por defecto y que aparezca en tu editor cuando lances el comando 'git commit', tan solo has de ajustar 'commit.template':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The diff wrapper checks to make sure seven arguments are provided and passes two of them to your merge script.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El script para el comparador, ha de asegurarse de recibir siete argumentos y de pasar dos de ellos al script de fusion (merge).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Total 3 (delta 1), reused 0 (delta 0)
	Unpacking objects: 100% (3/3), done.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Total 3 (delta 1), reused 0 (delta 0)
	Unpacking objects: 100% (3/3), done.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Branches on this list without the `*` in front of them are generally fine to delete with `git branch -d`; you’ve already incorporated their work into another branch, so you’re not going to lose anything.</seg>
      </tuv>
      <tuv lang="ES">
        <seg> Y no lleva por delante el caracter '*' porque todo su contenido ya ha sido incorporado a otras ramas. Podemos borrarla tranquilamente con 'git branch -d', sin miedo a perder nada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you treat rebasing as a way to clean up and work with commits before you push them, and if you only rebase commits that have never been available publicly, then you’ll be fine.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si solo usas la reorganización como una vía para hacer limpieza y organizar confirmaciones de cambio antes de enviarlas, y si únicamente reorganizas confirmaciones que nunca han sido públicas. Entonces no tendrás problemas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The client initiates a `fetch-pack` process that connects to an `upload-pack` process on the remote side to negotiate what data will be transferred down.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T075245Z" changeid="juan">
        <seg>El cliente arranca un proceso `fetch-pack`, para conectar con un proceso `upload-pack` en el lado servidor y negociar con él los datos a transferir. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>We also assume you’re running a standard Linux distribution like Ubuntu.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Se asume que tienes un servidor en marcha, con una distribución estandar de Linux, tal como Ubuntu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You do that by having Git compare the last commit on your topic branch with the first common ancestor it has with the master branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Lo puedes hacer indicando a Git que compare la última confirmación  de cambios en la rama puntual, con el más reciente ancestro común que tenga esta respecto de la rama 'master'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now you have a topic branch that contains contributed work.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Ahora que tienes una rama puntual con trabajo aportado por otras personas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This chapter has covered a number of plumbing commands — commands that are lower level and simpler than the porcelain commands you’ve learned about in the rest of the book.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T135542Z" changeid="juan">
        <seg>En este capítulo se han visto unos cuantos comandos &quot;de fontanería&quot;. Comandos de menor nivel y más simples que los &quot;de porcelana&quot; que hemos estado viendo en el resto del libro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Notice that this tree has both file entries and also that the test.txt SHA is the &quot;version 2&quot; SHA from earlier (`1f7a7a`).</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T144657Z" changeid="juan">
        <seg>Aquí se vén las entradas para los dos archivos y también el que la suma de comprobación SHA-1 de test.txt es la &quot;segunda versión&quot; de la anterior (`1f7a7a`).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git clone http://github.com/schacon/simplegit-progit.git
	Initialized empty Git repository in /private/tmp/simplegit-progit/.git/
	got ca82a6dff817ec66f44342007202690a93763949
	walk ca82a6dff817ec66f44342007202690a93763949
	got 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
	Getting alternates list for http://github.com/schacon/simplegit-progit.git
	Getting pack list for http://github.com/schacon/simplegit-progit.git
	Getting index for pack 816a9b2334da9953e530f27bcac22082a9f5b835
	Getting pack 816a9b2334da9953e530f27bcac22082a9f5b835
	 which contains cfda3bf379e4f8dba8717dee55aab78aef7f4daf
	walk 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
	walk a11bef06a3f659402fe7563abf99ad00de2209e6</seg>
      </tuv>
      <tuv lang="ES" changedate="20110817T224906Z" changeid="juan">
        <seg>$ git clone http://github.com/schacon/simplegit-progit.git
	Initialized empty Git repository in /private/tmp/simplegit-progit/.git/
	got ca82a6dff817ec66f44342007202690a93763949
	walk ca82a6dff817ec66f44342007202690a93763949
	got 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
	Getting alternates list for http://github.com/schacon/simplegit-progit.git
	Getting pack list for http://github.com/schacon/simplegit-progit.git
	Getting index for pack 816a9b2334da9953e530f27bcac22082a9f5b835
	Getting pack 816a9b2334da9953e530f27bcac22082a9f5b835
	 which contains cfda3bf379e4f8dba8717dee55aab78aef7f4daf
	walk 085bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
	walk a11bef06a3f659402fe7563abf99ad00de2209e6</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In this case, you’re specifying a mode of `100644`, which means it’s a normal file.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110801T122802Z" changeid="juan">
        <seg>En este caso, indicas un modo `100644`, el modo que denota un archivo normal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>First, she switches back to her master branch to integrate all this work:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Primero, se posiciona de nuevo en su rama principal para integrar todo su trabajo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>How does Git do this?</seg>
      </tuv>
      <tuv lang="ES" changedate="20110815T212242Z" changeid="juan">
        <seg>¿Cómo consigue Git esto?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The HTTP protocol also isn’t very resource intensive on your server.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Además, el procolo HTTP no requiere de grandes recursos en tu servidor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git checks out a working copy of the `master` branch that was pointed to by the HEAD reference you downloaded at the beginning.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T131419Z" changeid="juan">
        <seg>Git activa una copia de trabajo de la rama  `master` señalada por la referencia HEAD que has descargado al principio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Your initial diverged commit history.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El registro de confirmaciones inicial.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git log master...experiment
	F
	E
	D
	C</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T202405Z" changeid="juan">
        <seg>$ git log master...experiment
	F
	E
	D
	C</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now you have the Rack project under a subdirectory named `rack` within your project.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T103447Z" changeid="juan">
        <seg>A partir de este momento, el proyecto Rack está dentro de nuestro proyecto; bajo una subcarpeta denominada `rack`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you’re using a version of Git earlier than 1.6, the `mv` command isn’t necessary — Git started naming the hooks examples with the .sample postfix only recently.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si utilizas una versión de Git anterior a la 1.6, el comando 'mv' no es necesario, ya que solo recientemente lleva Git los anclajes de ejemplo con el sufijo .sample</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can see this by creating an annotated tag (`-a` specifies that it’s an annotated tag):</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T112520Z" changeid="juan">
        <seg>Puedes comprobarlo creando una: (la opción `-a` indica que la etiqueta es anotativa)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In essence, you want to treat it like a binary file.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y es preferible tratarlos como si fueran archivos binarios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Although `rack` is a subdirectory in your working directory, Git sees it as a submodule and doesn’t track its contents when you’re not in that directory.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T170955Z" changeid="juan">
        <seg>Aunque `rack` es una subcarpeta de la carpeta de trabajo, git la contempla como un submódulo y no realiza seguimiento de sus contenidos si no se está situado directamente sobre ella. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In the meantime, Jessica has been working on a topic branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Mientras tanto, jessica ha seguido trabajando en una rama puntual (topic branch).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>`--reuseaddr` allows the server to restart without waiting for old connections to time out, the `--base-path` option allows people to clone projects without specifying the entire path, and the path at the end tells the Git daemon where to look for repositories to export.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El parámetro '--reuseaddr' permite al servidor reiniciarse sin esperar a que se liberen viejas conexiones; el parámetro '--base-path' permite a los usuarios clonar proyectos sin necesidad de indicar su camino completo; y el camino indicado al final del comando mostrará al demonio Git dónde buscar los repositorios a exportar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In the `.gitattributes` file, you can set a filter for particular paths and then set up scripts that will process files just before they’re committed (&quot;clean&quot;, see Figure 7-2) and just before they’re checked out (&quot;smudge&quot;, see Figure 7-3).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En el archivo '.gitattibutes', puedes indicar filtros para carpetas o archivos determinados y luego preparar tus propios scripts para procesarlos justo antes de confirmar cambios en ellos (&quot;clean&quot;, ver Figura 7-2), o justo antes de recuperarlos (&quot;smudge&quot;, ver Figura 7-3).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Generally, this script is used for notification or something similar.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Habitualmente, este script final se suele utilizar para realizar notificaciones o tareas similares.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This entire chapter basically deals with the stuff in this directory.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Todo este capítulo se encarga de repasar el contenido en dicha carpeta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Creating a Branch from a Stash ###</seg>
      </tuv>
      <tuv lang="ES" changedate="20120712T204022Z" changeid="juan">
        <seg>### Creando una rama desde un guardado rápido temporal ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git cat-file -p master^{tree}
	100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt
	100644 blob 9bc1dc421dcd51b4ac296e3e5b6e2a99cf44391e      repo.rb
	100644 blob e3f094f522629ae358806b17daf78246c27c007b      test.txt</seg>
      </tuv>
      <tuv lang="ES" changedate="20110810T230310Z" changeid="juan">
        <seg>$ git cat-file -p master^{tree}
	100644 blob fa49b077972391ad58037050f2a75f74e3671e92      new.txt
	100644 blob 9bc1dc421dcd51b4ac296e3e5b6e2a99cf44391e      repo.rb
	100644 blob e3f094f522629ae358806b17daf78246c27c007b      test.txt</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The double-dot syntax is useful as a shorthand; but perhaps you want to specify more than two branches to indicate your revision, such as seeing what commits are in any of several branches that aren’t in the branch you’re currently on.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T091007Z" changeid="juan">
        <seg>La sintaxis del doble-punto es util como atajo. Pero en algunas ocasiones interesa indicar mas de dos ramas para precisar la revisión. Como cuando se desea ver las confirmaciones de cambio presentes en cualquiera de varias ramas y no en la rama activa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Ahh, but the bliss of rebasing isn’t without its drawbacks, which can be summed up in a single line:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Ahh...., pero la dicha de la reorganización no la alcanzamos sin sus contrapartidas: </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Basic Client Configuration ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Configuración básica del cliente Git ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git config --system receive.fsckObjects true</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git config --system receive.fsckObjects true</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>#### export-ignore ####</seg>
      </tuv>
      <tuv lang="ES">
        <seg>#### export-ignore ####</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You’ve just done the low-level operations to build up a Git history without using any of the front ends.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110807T152615Z" changeid="juan">
        <seg>Acabas de confeccionar un historial Git utilizando solamente operaciones de bajo nivel, sin usar ninguno de los interfaces principales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## Submodules ##</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T083425Z" changeid="juan">
        <seg>## Submódulos ##</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>That’s all we’ll cover about GitHub, but it’s important to note how quickly you can do all this.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto es todo lo que vamos a ver aquí sobre GitHub, pero merece la pena destacar lo rápido que puedes hacer todo esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can also do `git push origin serverfix:serverfix`, which does the same thing — it says, “Take my serverfix and make it the remote’s serverfix.” You can use this format to push a local branch into a remote branch that is named differently.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>También puedes hacer 'git push origin serverfix:serverfix', que hace lo mismo; es decir: &quot;coge mi 'serverfix' y hazlo el 'serverfix' remoto&quot;. Puedes utilizar este último formato para llevar una rama local a una rama remota con otro nombre distinto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If this script exits non-zero, Git aborts the commit process, so you can use it to validate your project state or commit message before allowing a commit to go through.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si este script termina con un código de salida distinto de cero, Git aborta el proceso de confirmación de cambios; permitiendo así validar el estado del proyecto o el mensaje de confirmación antes de permitir continuar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0312.png
Figure 3-12.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0312.png
Figura 3-12.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now the first two commits aren’t reachable by anything:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T133720Z" changeid="juan">
        <seg>Con eso, perdemos completamente el acceso a las dos primeras confirmaciones de cambio:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ find .git/objects -type f
	.git/objects/71/08f7ecb345ee9d0084193f147cdad4d2998293
	.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4
	.git/objects/info/packs
	.git/objects/pack/pack-7a16e4488ae40c7d2bc56ea2bd43e25212a66c45.idx
	.git/objects/pack/pack-7a16e4488ae40c7d2bc56ea2bd43e25212a66c45.pack</seg>
      </tuv>
      <tuv lang="ES" changedate="20110810T231652Z" changeid="juan">
        <seg>$ find .git/objects -type f
	.git/objects/71/08f7ecb345ee9d0084193f147cdad4d2998293
	.git/objects/d6/70460b4b4aece5915caf5c68d12f560a9fe3e4
	.git/objects/info/packs
	.git/objects/pack/pack-7a16e4488ae40c7d2bc56ea2bd43e25212a66c45.idx
	.git/objects/pack/pack-7a16e4488ae40c7d2bc56ea2bd43e25212a66c45.pack</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>HEAD moves to another branch on a checkout.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>HEAD apunta a otra rama cuando hacemos un checkout.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>[merge]
	  tool = extMerge
	[mergetool &quot;extMerge&quot;]
	  cmd = extMerge &quot;$BASE&quot; &quot;$LOCAL&quot; &quot;$REMOTE&quot; &quot;$MERGED&quot;
	  trustExitCode = false
	[diff]
	  external = extDiff</seg>
      </tuv>
      <tuv lang="ES">
        <seg>[merge]
	  tool = extMerge
	[mergetool &quot;extMerge&quot;]
	  cmd = extMerge &quot;$BASE&quot; &quot;$LOCAL&quot; &quot;$REMOTE&quot; &quot;$MERGED&quot;
	  trustExitCode = false
	[diff]
	  external = extDiff</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In order to do that, you’ll merge in your `iss53` branch, much like you merged in your `hotfix` branch earlier.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para ello, de forma similar a como antes has hecho con la rama 'hotfix', vas a fusionar la rama 'iss53'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>*** Commands ***
	  1: status     2: update      3: revert     4: add untracked
	  5: patch      6: diff        7: quit       8: help
	What now&gt; 1
	           staged     unstaged path
	  1:    unchanged        +0/-1 TODO
	  2:        +1/-1      nothing index.html
	  3:    unchanged        +5/-1 lib/simplegit.rb</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T213029Z" changeid="juan">
        <seg>*** Commands ***
	  1: status     2: update      3: revert     4: add untracked
	  5: patch      6: diff        7: quit       8: help
	What now&gt; 1
	           staged     unstaged path
	  1:    unchanged        +0/-1 TODO
	  2:        +1/-1      nothing index.html
	  3:    unchanged        +5/-1 lib/simplegit.rb</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git fetch origin
	...
	From john@githost:simplegit
	 + 049d078...fbff5bc master     -&gt; origin/master</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git fetch origin
	...
	From john@githost:simplegit
	 + 049d078...fbff5bc master     -&gt; origin/master</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Another interesting problem you can solve this way involves diffing image files.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Otro problema donde puede ser util esta técnica, es en la comparación de imágenes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Since you have no code there yet, GitHub will show you instructions for how create a brand-new project, push an existing Git project up, or import a project from a public Subversion repository (see Figure 4-7).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Como aún no tienes código, GitHub mostrará instrucciones sobre cómo iniciar un nuevo proyecto, cómo enviar (push) un proyecto Git preexistente, o cómo importar un proyecto desde un repositorio público Subversion (ver Figura 4-7).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Your Git repository now contains five objects: one blob for the contents of each of your three files, one tree that lists the contents of the directory and specifies which file names are stored as which blobs, and one commit with the pointer to that root tree and all the commit metadata.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En este momento, el repositorio de Git contendrá cinco objetos: un &quot;blob&quot; para cada uno de los tres archivos, un árbol con la lista de contenidos de la carpeta (más sus respectivas relaciones con los &quot;blobs&quot;), y una confirmación de cambios (commit) apuntando a la raiz de ese árbol y conteniendo el resto de metadatos pertinentes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can tell Git not to export certain files or directories when generating an archive.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes indicar a Git que ignore y no exporte ciertos archivos o carpetas cuando genera un archivo de almacenamiento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>We’ll walk though installing GitWeb manually very quickly.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Enseguida vamos a revisar el proceso de instalar GitWeb manualmente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## Basic Branching and Merging ##</seg>
      </tuv>
      <tuv lang="ES">
        <seg>## Procedimientos básicos para ramificar y fusionar ##</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Or maybe you have a bunch of automated build servers or continuous integration servers that change a lot, and you don’t want to have to generate SSH keys all the time — you just want to add simple anonymous read access.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>O si tienes un grupo de servidores de integración automatizados o servidores de integración continua que cambian muy a menudo, y no quieres estar todo el rato generando claves SSH. Es posible que desees añadirles un simple acceso anónimo de lectura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>first commit with submodule rack
	$ cd rack/
	$ git log -1
	commit 08d709f78b8c5b0fbeb7821e37fa53e69afcf433
	Author: Christian Neukirchen &lt;chneukirchen@gmail.com&gt;
	Date:   Wed Mar 25 14:49:04 2009 +0100</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T105437Z" changeid="juan">
        <seg>first commit with submodule rack
	$ cd rack/
	$ git log -1
	commit 08d709f78b8c5b0fbeb7821e37fa53e69afcf433
	Author: Christian Neukirchen &lt;chneukirchen@gmail.com&gt;
	Date:   Wed Mar 25 14:49:04 2009 +0100</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You may see some other files in there, but this is a fresh `git init` repository — it’s what you see by default.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110801T115943Z" changeid="juan">
        <seg>Puede que veas algunos otros archivos en tu carpeta '.git', pero este es el contenido de un repositorio recién creado tras ejecutar 'git init', --es la estructura por defecto--.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git log origin/featureA ^featureA
	commit aad881d154acdaeb2b6b18ea0e827ed8a6d671e6
	Author: John Smith &lt;jsmith@example.com&gt;
	Date:   Fri May 29 19:57:33 2009 -0700</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git log origin/featureA ^featureA
	commit aad881d154acdaeb2b6b18ea0e827ed8a6d671e6
	Author: John Smith &lt;jsmith@example.com&gt;
	Date:   Fri May 29 19:57:33 2009 -0700</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>All the sample hook scripts distributed with Git are in either Perl or Bash scripting, so you can also see plenty of examples of hooks in those languages by looking at the samples.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Todos los script de ejemplo que vienen de serie con Git están escritos en Perl o en Bash shell, por lo que tienes bastantes ejemplos en esos lenguajes de scripting.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0413.png
Figure 4-13.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0413.png
Figura 4-13.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To demonstrate having multiple remote servers and what remote branches for those remote projects look like, let’s assume you have another internal Git server that is used only for development by one of your sprint teams.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para ilustrar mejor el caso de tener múltiples servidores y cómo van las ramas remotas para esos proyectos remotos. Supongamos que tienes otro servidor Git; utilizado solamente para desarrollo, por uno de tus equipos sprint.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Let’s use `gitserver` as the hostname of the server on which you’ve set up your 'git' user and repository.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Suponiendo, por ejemplo, que se llame 'gitserver' el servidor donde has puesto el usuario 'git' y los repositorios;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To clone a Git repository over SSH, you can specify ssh:// URL like this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para clonar un repositorio a través de SSH, puedes indicar una URL ssh:// tal como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The answer to this dilemma is to provide some client-side hooks that users can use to notify them when they’re doing something that the server is likely to reject.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La solución a este dilema es el proporcionarles algunos enganches (hook) del lado cliente, para que les avisen cuando están trabajando en algo que el servidor va a rechazarles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For example, if you’ve added a line in a file on the `master` branch, a direct comparison of the snapshots will look like the topic branch is going to remove that line.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por ejemplo, si en la rama 'master' habias añadido una línea a un archivo, la comparación directa de instantáneas te llevará a pensar que la rama puntual va a borrar dicha línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>A common issue arises in these scenarios: you want to be able to treat the two projects as separate yet still be able to use one from within the other.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T170146Z" changeid="juan">
        <seg>La preocupación típica en estos escenarios suele ser la de cómo conseguir tratar ambos proyectos separadamente. Pero conservando la habilidad de utilizar uno dentro del otro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git checkout featureA
	Switched to branch &quot;featureA&quot;
	$ git merge origin/featureA
	Updating 3300904..aad881d
	Fast forward
	 lib/simplegit.rb |   10 +++++++++-
	1 files changed, 9 insertions(+), 1 deletions(-)</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git checkout featureA
	Switched to branch &quot;featureA&quot;
	$ git merge origin/featureA
	Updating 3300904..aad881d
	Fast forward
	 lib/simplegit.rb |   10 +++++++++-
	1 files changed, 9 insertions(+), 1 deletions(-)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>#### Merging Workflows ####</seg>
      </tuv>
      <tuv lang="ES">
        <seg>#### Fusionando flujos de trabajo ####</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Let’s look at one more possible scenario: the maintainer has looked at work in your second branch and likes the concept but would like you to change an implementation detail.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Vamos a ver otro posible escenario: el gestor del proyecto ha revisado tu trabajo en la segunda rama y le ha gustado el concepto, pero desea que cambies algunos detalles de la implementación. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Next, you have a hotfix to make.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Volviendo al problema urgente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It turns out there is no issue here, and you tell Git that by typing `git bisect good` and continue your journey:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T075101Z" changeid="juan">
        <seg>Por ejemplo, si resultara que no se detecta el problema aquí, se indicaria esta circunstancia a Git tecleando `git bisect good`; para continuar la búsqueda:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To avoid this issue, create a branch when you work in a submodule directory with `git checkout -b work` or something equivalent.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T134259Z" changeid="juan">
        <seg>Para evitarlo, siempre se ha de crear una rama cuando se trabaje en la carpeta de un submódulo; usando  `git checkout -b trabajo` o algo similar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>That means when I host my `grit` project on GitHub, you won’t find it at `github.com/grit` but instead at `github.com/schacon/grit`.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto significa que, cuando alojo mi proyecto 'grit' en GitHub, no lo encontraras bajo 'github.com/grit', sino bajo 'github.com/schacon/grit'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can run auto gc manually as follows:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T092111Z" changeid="juan">
        <seg>También puedes lanzar &quot;auto gc&quot; manualmente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>One central hub, or repository, can accept code, and everyone synchronizes their work to it.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Un repositorio o punto central guarda el código fuente; y todo el mundo sincroniza su trabajo con él.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Public Large Project ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Proyecto Público Grande ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The first thing this command does is pull down the `info/refs` file.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T130407Z" changeid="juan">
        <seg>Lo primero que hace este comando es recuperar el archivo `info/refs`. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## Getting Git on a Server ##</seg>
      </tuv>
      <tuv lang="ES">
        <seg>## Poniendo Git en un Servidor ##</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Staging Patches ###</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T213637Z" changeid="juan">
        <seg>### Parches en la preparación ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can see a file in the `objects` directory.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T143116Z" changeid="juan">
        <seg>Como puedes ver, hay un archivo en la carpeta 'objects'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Basic Branching ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Procedimientos básicos de ramificación ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>#### The Cons ####</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Desventajas ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Or you can have Git try to automatically fix the issue before applying the patch:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>O puedes pedirle que intente corregir automáticamente los problemas antes de aplicar el parche:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Sometimes, developers want to get a combination of a large project’s subdirectories, depending on what team they’re on.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T172058Z" changeid="juan">
        <seg>Algunas veces, dependiendo del equipo de trabajo en que se encuentren, los desarrolladores suelen necesitar mantener una combinación de grandes carpetas de proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you’re applying a number of patches from an mbox, you can also run the `am` command in interactive mode, which stops at each patch it finds and asks if you want to apply it:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Al aplicar varios parches desde un mbox, puedes lanzar el comando 'am' en modo interactivo; haciendo que se detenga en cada parche y preguntandote si aplicarlo o no:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>So, let’s do an actual Git command — you’ll clone the Gitosis control repository:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por tanto, intentalo con un comando Git real --por ejemplo, clonar el propio repositorio de control de Gitosis </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If that happens, you see an error like this:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T110835Z" changeid="juan">
        <seg>En estos casos, se suele ver un error tal como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For instance, Xcode projects on the Mac contain a file that ends in `.pbxproj`, which is basically a JSON (plain text javascript data format) dataset written out to disk by the IDE that records your build settings and so on.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por ejemplo, los proyectos Xcode en un Mac contienen un archivo terminado en '.pbxproj'. Este archivo es básicamente una base de datos JSON (datos javascript en formato de texto plano), escrita directamente por el IDE para almacenar aspectos tales como tus ajustes de compilación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git cat-file -s 05408d195263d853f09dca71d55116663690c27c
	12908</seg>
      </tuv>
      <tuv lang="ES" changedate="20110810T230725Z" changeid="juan">
        <seg>$ git cat-file -s 05408d195263d853f09dca71d55116663690c27c
	12908</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ echo 'new file' &gt; new.txt
	$ git update-index test.txt
	$ git update-index --add new.txt</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T180322Z" changeid="juan">
        <seg>$ echo 'new file' &gt; new.txt
	$ git update-index test.txt
	$ git update-index --add new.txt</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Whether you maintain a canonical repository or want to help by verifying or approving patches, you need to know how to accept work in a way that is clearest for other contributors and sustainable by you over the long run.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tanto si gestionas un repositorio canónico, como si deseas colaborar verificando o aprobando parches, necesitas saber cómo aceptar trabajo de otros de la forma más clara para tus contribuyentes y más sostenible para tí a largo plazo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>[master]: created a0a41a9: &quot;More friendly message when locking the index fails.&quot;
	 3 files changed, 17 insertions(+), 3 deletions(-)</seg>
      </tuv>
      <tuv lang="ES">
        <seg>[master]: created a0a41a9: &quot;More friendly message when locking the index fails.&quot;
	 3 files changed, 17 insertions(+), 3 deletions(-)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In the following examples, and throughout most of this book, for the sake of brevity I don’t format messages nicely like this; instead, I use the `-m` option to `git commit`.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En los ejemplos siguientes, y a lo largo de todo este libro, por razones de brevedad no formatearé correctamente los mensajes; sino que emplearé la opción '-m' en los comandos 'git commit'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The repo.or.cz and GitHub hosting sites both support this, and many project maintainers expect this style of contribution.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Los sitios como repo.or.cz  ó GitHub permiten realizar esto, y muchos gestores de proyectos esperan este estilo de contribución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git will automatically add group write permissions to a repository properly if you run the `git init` command with the `--shared` option.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Git añadirá automáticamente permisos de escritura al grupo sobre cualquier repositorio donde lances el comando 'git init' con la opción '--shared'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you’re taking patches over e-mail prepared by `git format-patch`, then some of these may be helpful to you.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si recibes parches a través de corrreo-e preparados con 'git format-patch', es posible que parte de lo descrito en esta sección te pueda ser util.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Exiting non-zero from this hook aborts the commit, although you can bypass it with `git commit --no-verify`.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Saliendo con un valor de retorno distinto de cero, se aborta la confirmación de cambios. Aunque siempre puedes saltartelo con la orden 'git commit --no-verify'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>diff --git a/lib/simplegit.rb b/lib/simplegit.rb
	index 76f47bc..f9815f1 100644
	--- a/lib/simplegit.rb
	+++ b/lib/simplegit.rb
	@@ -14,7 +14,7 @@ class SimpleGit
	   end</seg>
      </tuv>
      <tuv lang="ES">
        <seg>diff --git a/lib/simplegit.rb b/lib/simplegit.rb
	index 76f47bc..f9815f1 100644
	--- a/lib/simplegit.rb
	+++ b/lib/simplegit.rb
	@@ -14,7 +14,7 @@ class SimpleGit
	   end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you really do want to delete the branch and lose that work, you can force it with `-D`, as the helpful message points out.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si realmente deseas borrar la rama, y perder el trabajo contenido en ella, puedes forzar el borrado con la opción '-D'; tal y como lo indica el mensaje de ayuda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0329.png
Figure 3-29.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0329.png
Figura 3-29.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This gives you a local branch that you can work on that starts where `origin/serverfix` is.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto sí te da una rama local donde puedes trabajar, comenzando donde 'origin/serverfix' estaba en ese momento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you have multiple submodules, you’ll have multiple entries in this file.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T103819Z" changeid="juan">
        <seg>En caso de haber múltipes submódulos, habrá multiples entradas en este archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For instance, you might resolve this conflict by replacing the entire block with this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por ejemplo, puedes optar por cambiar el bloque, dejandolo tal que:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>- Typically a hyphen or asterisk is used for the bullet, preceded by a
	   single space, with blank lines in between, but conventions vary here</seg>
      </tuv>
      <tuv lang="ES">
        <seg>- Habitualmente se emplea un guión o un asterisco como bolo, seguido de un espacio, con líneas en blanco intermedias; pero las convenciones pueden variar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Other maintainers prefer to rebase or cherry-pick contributed work on top of their master branch, rather than merging it in, to keep a mostly linear history.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Otros gestores de mantenimiento,  al procesar el trabajo recibido de las personas colaboradoras, en lugar de fusiones (merge), suelen preferir reorganizar (rebase) o entresacar (cherry-pick) sobre su propia rama principal; obteniendo así un historial prácticamente lineal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can tell Git which of these you want enabled by setting `core.whitespace` to the values you want on or off, separated by commas.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes decir a Git cuales de ellos deseas activar o desactivar, ajustando el parámetro 'core.whitespace' con los valores on/off separados por comas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For example, suppose you want to split the middle commit of your three commits.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T122927Z" changeid="juan">
        <seg>Por ejemplo, si se desea dividir la confirmación de cambios de enmedio de entre las tres citadas en ejemplos anteriores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Instead of &quot;updated README formatting and added blame&quot;, you want to split it into two commits: &quot;updated README formatting&quot; for the first, and &quot;added blame&quot; for the second.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T123334Z" changeid="juan">
        <seg>Es decir, si en lugar de &quot;updated README formatting and added blame&quot;, se desea separar esa confirmación en dos: &quot;updated README formatting&quot; y &quot;added blame&quot;. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>What is the significance of that?</seg>
      </tuv>
      <tuv lang="ES">
        <seg>¿Cuál es el significado de todo esto?.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Another simple option for public unauthenticated access is to start a Git daemon, although that requires you to daemonize the process - we’ll cover this option in the next section, if you prefer that route.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Otra opción simple para habilitar accesos públicos sin autentificar, es arrancar el demonio Git, aunque esto supone demonizar el proceso. (Se verá esta opción en la siguiente sección.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In order to clone your repository to create a new bare repository, you run the clone command with the `--bare` option.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tan solo has de utilizar el comando 'clone' con la opción '--bare'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You’ve just gone over Git’s three main object types, but there is a fourth.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T233535Z" changeid="juan">
        <seg>Acabas de conocer los tres principales tipos de objetos Git, pero hay un cuarto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When you save and exit the editor, Git rewinds you back to the last commit in that list and drops you on the command line with the following message:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120728T085916Z" changeid="juan">
        <seg>Cuando se guarde y cierre en el editor, Git hará un rebobinado hacia atras hasta la última de las confirmaciones de cambios en la lista, y mostrará algo así como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git checkout testing</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git checkout testing</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Let’s go through a simple example of branching and merging with a workflow that you might use in the real world.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Vamos a presentar un ejemplo simple de ramificar y de fusionar, con un flujo de trabajo que se podría presentar en la realidad.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>puts &quot;Enforcing Policies... \n(#{$refname}) (#{$oldrev[0,6]}) (#{$newrev[0,6]})&quot;</seg>
      </tuv>
      <tuv lang="ES">
        <seg>puts &quot;Enforcing Policies... \n(#{$refname}) (#{$oldrev[0,6]}) (#{$newrev[0,6]})&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can get a list of the SHA-1 values of all the commits that are being pushed by taking the `$newrev` and `$oldrev` values and passing them to a Git plumbing command called `git rev-list`.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes obtener la lista de las claves SHA-1 de todos las confirmaciones de cambios enviadas cogiendo los valores de '$newrev' y de '$oldrev', y pasandolos a comando de mantenimiento de Git llamado 'git rev-list'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Put the following line in your `.gitattributes` file:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Poniendo lo siguiente en tu archivo '.gitattributes':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>That’s basically what a branch in Git is: a simple pointer or reference to the head of a line of work.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T201659Z" changeid="juan">
        <seg>Esto es lo que es básicamente una rama en Git: un simple apuntador o referencia a la cabeza de una línea de trabajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Some of the variables involved are active contributor size, chosen workflow, your commit access, and possibly the external contribution method.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Algunas de las variables a considerar son: la cantidad de colaboradores activos, la forma de trabajo escogida, el nivel de acceso que tengas, y, posiblemente, el sistema de colaboración externa implantado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>On an Ubuntu machine, you use an Upstart script.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En una máquina Ubuntu, puedes usar un script de arranque.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To tell Git to treat all `pbxproj` files as binary data, add the following line to your `.gitattributes` file:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para indicar a Git que trate todos los archivos 'pbxproj' como binarios, puedes añadir esta línea a tu archivo '.gitattriutes':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Writing objects: 100% (15/15), 1.74 KiB, done.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Writing objects: 100% (15/15), 1.74 KiB, done.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If all your commit messages look like this, things will be a lot easier for you and the developers you work with.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si todas tus confirmaciones de cambio (commit) llevan mensajes de este estilo, facilitarás las cosas tanto para tí como para las personas que trabajen contigo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>After they integrate these branches into the mainline, a fetch will bring down the new merge commits, making the commit history look like Figure 5-14.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Despues de que dichas ramas sean integradas en la línea principal, una recuperación (fetch) traerá de vuelta las confirmaciones de cambios de las integraciones (merge commits), dejando un historial como el mostrado en la Figura 5-14.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Clicking the &quot;I agree, sign me up&quot; button takes you to your new user dashboard (see Figure 4-4).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Clicando sobre el botón de &quot;Estoy de acuerdo, registramé&quot; (&quot;I agree, sign me up&quot;), irás al panel de control de tu recién creado usuario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Notice the reverse order.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120728T084730Z" changeid="juan">
        <seg>Prestar atención al orden inverso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Let’s create a hotfix branch on which to work until it’s completed (see Figure 3-13):</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Vamos a crear una nueva rama 'hotfix', sobre la que trabajar hasta resolverlo (ver Figura 3-13):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This approach also makes it easier to pull out or revert one of the changesets if you need to later.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Además, esta manera de trabajar facilitará la integración o el descarte individual de alguno de los cambios, en caso de ser necesario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Suppose you clone from a central server and then do some work off that.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Imaginate que haces un clon desde un servidor central, y luego trabajas sobre él.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Because it contains work that isn’t merged in yet, trying to delete it with `git branch -d` will fail:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Debido a que contiene trabajos sin fusionar aún, al intentarla borrar con 'git branch -d', el comando nos dará un error:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git automatically creates a new commit object that contains the merged work.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Git crea automáticamente una nueva confirmación para la fusión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It’s best to have a clean working state when you switch branches.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Lo mejor es tener siempre un estado de trabajo limpio y despejado antes de saltar entre ramas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you’re running a Mac, Leopard comes preinstalled with Ruby, so `webrick` may be your best bet.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si tienes una máquina Mac, Leopard trae preinstalado Ruby, por lo que 'webrick' puede ser tu mejor apuesta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git comes preset to use a number of other merge-resolution tools without your having to set up the cmd configuration.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Git viene preparado para utilizar bastantes otras herramientas de resolución de conflictos, sin necesidad de andar ajustando la configuración de cdm.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You first add the Rack application to your project.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T141930Z" changeid="juan">
        <seg>Se comienza añadiendo la aplicación Rack al proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you try, you’ll see a login rejection like this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si pruebas a hacerlo, recibiras un rechazo de inicio de sesión:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is a special daemon that comes packaged with Git; it listens on a dedicated port (9418) that provides a service similar to the SSH protocol, but with absolutely no authentication.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>es un demonio (daemon) especial, que viene incorporado con Git. Escucha por un puerto dedicado (9418), y nos da un servicio similar al del protocolo SSH; pero sin ningún tipo de autentificación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git filter-branch --subdirectory-filter trunk HEAD
	Rewrite 856f0bf61e41a27326cdae8f09fe708d679f596f (12/12)
	Ref 'refs/heads/master' was rewritten</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T180153Z" changeid="juan">
        <seg>$ git filter-branch --subdirectory-filter trunk HEAD
	Rewrite 856f0bf61e41a27326cdae8f09fe708d679f596f (12/12)
	Ref 'refs/heads/master' was rewritten</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Behind big corporate firewalls, this obscure port is commonly blocked.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Normalmente, este oscuro puerto suele estar bloqueado detrás de los cortafuegos corporativos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>I’ll demonstrate setting up the Perforce Visual Merge Tool (P4Merge) to do your diffs and merge resolutions, because it’s a nice graphical tool and it’s free.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Lo voy a demostrar configurando Perforce Visual Merge como herramienta para realizar las comparaciones y resolver conflictos; ya que es una buena herramienta gráfica y es libre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Take a history like Figure 3-31, for example.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por ejemplo, sea un registro como el de la Figura 3-31.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>README
	lib/test.rb</seg>
      </tuv>
      <tuv lang="ES">
        <seg>README
	lib/test.rb</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Some rdoc changes</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T114318Z" changeid="juan">
        <seg>Some rdoc changes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ ls
	AUTHORS	       KNOWN-ISSUES   Rakefile      contrib	       lib
	COPYING	       README         bin           example	       test
	$ git checkout master
	Switched to branch &quot;master&quot;
	$ ls
	README</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T142139Z" changeid="juan">
        <seg>$ ls
	AUTHORS	       KNOWN-ISSUES   Rakefile      contrib	       lib
	COPYING	       README         bin           example	       test
	$ git checkout master
	Switched to branch &quot;master&quot;
	$ ls
	README</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you use the ACL structure returned from the `get_acl_access_data` method and check it against the listed files in each of the commits, you can determine whether the user has access to push all of their commits:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Utilizando la estructura ACL devuelta por el método 'get_acl_access_data' y comprobandola sobre la lista de archivos de cada confirmación de cambios, puedes determinar si el usuario tiene o no permiso para enviar dichos cambios:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The main reason to specify the `file://` prefix is if you want a clean copy of the repository with extraneous references or objects left out — generally after an import from another version-control system or something similar (see Chapter 9 for maintenance tasks).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La única razón que puedes tener para indicar expresamente el prefijo 'file://' puede ser el querer una copia limpia del repositorio, descartando referencias u objetos superfluos. Normalmente, tras haberlo importado desde otro sistema de control de versiones o algo similar (ver el Capítulo 9 sobre tareas de mantenimiento).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you run that command before committing, you can tell if you’re about to commit whitespace issues that may annoy other developers.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Lanzando este comando antes de confirmar cambios, puedes estar seguro de si vas o no a incluir problemas de espaciado que puedan molestar a otros desarrolladores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Then, Git spits out a bunch of log information looking something like this for each patch you’re sending:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tras esto, Git escupirá una serie de información de registro, con pinta más o menos como esta:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you run a `git log` when your history looks like this, you’ll see two commits that have the same author date and message, which will be confusing.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si lanzas un 'git log' en un registro como este, verás dos confirmaciones  con el mismo autor, misma fecha y mismo mensaje. Lo que puede llevar a confusiones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can also specify multiple refspecs for fetching in your configuration file.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T115833Z" changeid="juan">
        <seg>Es posible asimismo indicar referencias multiples en el archivo de configuración.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you type `2` or `u` at the `What now&gt;` prompt, the script prompts you for which files you want to stage:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T092448Z" changeid="juan">
        <seg>Tecleando '2' o 'u' (update) tras el indicador 'What now&gt;', el script interactivo preguntará cuales son los archivos que se quieren añadir al área de preparación:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now, your local branch sf will automatically push to and pull from origin/serverfix.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Así, tu rama local 'sf' va a llevar (push) y traer (pull) hacia o desde 'origin/serverfix'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Exporting Your Repository ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Exportación del repositorio ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>History with several topic branches.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Historial con varias ramas puntuales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Not nearly as many configuration options are available for the server side of Git, but there are a few interesting ones you may want to take note of.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>No hay tantas opciones de configuración en el lado servidor de Git. Pero hay unas pocas interesantes que merecen ser tenidas en cuenta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>lib/simplegit.rb |   10 +++++++++-
	 1 files changed, 9 insertions(+), 1 deletions(-)</seg>
      </tuv>
      <tuv lang="ES">
        <seg>lib/simplegit.rb |   10 +++++++++-
	 1 files changed, 9 insertions(+), 1 deletions(-)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git has initialized the `objects` directory and created `pack` and `info` subdirectories in it, but there are no regular files.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110717T113248Z" changeid="juan">
        <seg>Git ha inicializado la carpeta 'objects', creando en ella las subcarpetas 'pack' e 'info'; pero aún no hay archivos en ellas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>First you notice the `.gitmodules` file.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T103713Z" changeid="juan">
        <seg>Una: el archivo `.gitmodules`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>She chooses to merge in `issue54` first:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Elige fusionar primero 'issue54':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>check_fast_forward</seg>
      </tuv>
      <tuv lang="ES">
        <seg>check_fast_forward</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>On a project for which you’re not the maintainer, it’s generally easier to have a branch like `master` always track `origin/master` and to do your work in topic branches that you can easily discard if they’re rejected.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En un proyecto del que no seas gestor, suele ser más sencillo tener una rama tal como 'master' siguiendo siempre a la rama 'origin/master'; mientras realizas todo tu trabajo en otras ramas puntuales, que podrás descartar facilmente en caso de que alguna de ellas sea rechazada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you look at the resulting tree, you can see the SHA-1 value your repo.rb file got for the blob object:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110810T230308Z" changeid="juan">
        <seg>Si hechas un vistazo al árbol resultante, podrás observar el valor SHA-1 del objeto binario correspondiente a dicho archivo repo.rb:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>003fgit-upload-pack schacon/simplegit-progit.git\0host=myserver.com\0</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T075522Z" changeid="juan">
        <seg>003fgit-upload-pack schacon/simplegit-progit.git\0host=myserver.com\0</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Start with the first tree you wrote:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110807T150136Z" changeid="juan">
        <seg>Empezando por el primer árbol que has escrito:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>First, create a new file and save its contents in your database:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110717T113841Z" changeid="juan">
        <seg>Para ello, crea un archivo nuevo y guarda su contenido en tu base de datos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Your commit history will look something like Figure 3-20.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El registro de confirmaciones (commit history) será algo parecido a la Figura 3-20.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In fact, if you build Git from source code cloned from the Git repository, `git --version` gives you something that looks like this.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Es más, si compilas Git desde código fuente clonado desde el repositorio Git, el comando 'git --version' te dará algo parecido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>[ticket: X]</seg>
      </tuv>
      <tuv lang="ES">
        <seg>[ticket: X]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It adds, removes, and modifies files automatically to make sure your working copy is what the branch looked like on your last commit to it.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Git añade, quita y modifica archivos automáticamente. Para asegurarte que tu copia de trabajo es exactamente tal y como era la rama en la última confirmación de cambios realizada sobre ella.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git symbolic-ref HEAD test
	fatal: Refusing to point HEAD outside of refs/</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T193005Z" changeid="juan">
        <seg>$ git symbolic-ref HEAD test
	fatal: Refusing to point HEAD outside of refs/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Single Revisions ###</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T090113Z" changeid="juan">
        <seg>### Confirmaciones puntuales ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now that you can specify individual commits, let’s see how to specify ranges of commits.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T115425Z" changeid="juan">
        <seg>Una vez vistas las formas de referirse a confirmaciones concretas de cambios. Vamos a ver cómo referirse a un grupo de confirmaciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ echo &quot;1a410efbd13591db07496601ebc7a059dd55cfe9&quot; &gt; .git/refs/heads/master</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T191015Z" changeid="juan">
        <seg>$ echo &quot;1a410efbd13591db07496601ebc7a059dd55cfe9&quot; &gt; .git/refs/heads/master</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>There are a couple of interesting things here.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tenemos un para de aspectos interesantes aquí.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It’s not perfect — it adds a bunch of random stuff at the end — but it certainly works.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>No es perfecto, --añade bastante basura aleatoria al final--, pero realmente funciona.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Next, you clone and install Gitosis from the project’s main site:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>A continuación, has de clonar e instalar Gitosis desde el repositorio principal de su proyecto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>- print help</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T214134Z" changeid="juan">
        <seg>- print help</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git branch recover-branch ab1afef
	$ git log --pretty=oneline recover-branch
	ab1afef80fac8e34258ff41fc1b867c702daa24b modified repo a bit
	484a59275031909e19aadb7c92262719cfcdf19a added repo.rb
	1a410efbd13591db07496601ebc7a059dd55cfe9 third commit
	cac0cab538b970a37ea1e769cbbde608743bc96d second commit
	fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T143514Z" changeid="juan">
        <seg>$ git branch recover-branch ab1afef
	$ git log --pretty=oneline recover-branch
	ab1afef80fac8e34258ff41fc1b867c702daa24b modified repo a bit
	484a59275031909e19aadb7c92262719cfcdf19a added repo.rb
	1a410efbd13591db07496601ebc7a059dd55cfe9 third commit
	cac0cab538b970a37ea1e769cbbde608743bc96d second commit
	fdf4fc3344e67ab068f836878b6c4951e3b15f3d first commit</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you have a small team or are already comfortable with a centralized workflow in your company or team, you can easily continue using that workflow with Git.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si tienes un equipo pequeño o te sientes confortable con un flujo de trabajo centralizado, puedes continuar usando esa forma de trabajo con Git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Changes you submit may be rendered obsolete or severely broken by work that is merged in while you were working or while your changes were waiting to be approved or applied.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Los cambios que envies pueden quedar obsoletos o severamente afectados por otros trabajos que han sido integrados previamente mientras tú estabas trabajando o mientras tus cambios aguardaban a ser aprobados para su integración.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>People still won’t be able to log in, but Gitosis will control that for you.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Los usuarios no podrán todavia iniciar sesión, pero Gitosis se encargará de ello.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0331.png
Figure 3-31.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0331.png
Figura 3-31.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You get a list of commits that have already been pushed up by running this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La lista de confirmaciones de cambio previamente enviadas, se comprueba con:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0527.png
Figure 5-27.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0527.png
Figura 5-27.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Tom Preston-Werner (4):
	      fix dates in history
	      dynamic version method
	      Version bump to 1.0.2
	      Regenerated gemspec for version 1.0.2</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tom Preston-Werner (4):
	      fix dates in history
	      dynamic version method
	      Version bump to 1.0.2
	      Regenerated gemspec for version 1.0.2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The next time you check out this file, Git injects the SHA of the blob:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La próxima vez que extraigas el archivo, Git le habrá inyectado el SHA del objeto binario (blob):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When you’re done and want to shut down the server, you can run the same command with the `--stop` option:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cuando ya has terminado y quieras apagar el servidor, puedes lanzar el mismo comando con la opción '--stop'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>As you type, a helper pops up, showing you possible username matches.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Según  tecleas, aparecerá un cuadro de ayuda, mostrando posibles nombres de usuario que encajen con lo tecleado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git addresses this issue using submodules.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T084938Z" changeid="juan">
        <seg>Git resuelve estas problemáticas utilizando submódulos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>There is no difference in the end product of the integration, but rebasing makes for a cleaner history.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>No hay ninguna diferencia en el resultado final de la integración, pero el haberla hecho reorganizando nos deja un registro más claro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>access = get_acl_access_data('.git/acl')</seg>
      </tuv>
      <tuv lang="ES">
        <seg>access = get_acl_access_data('.git/acl')</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git rev-parse topic1
	ca82a6dff817ec66f44342007202690a93763949</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T205405Z" changeid="juan">
        <seg>$ git rev-parse topic1
	ca82a6dff817ec66f44342007202690a93763949</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>An alternative would be to push this new work to a different branch on the server (perhaps called `featureAv2`).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Una alternativa podría ser el enviar (push) este nuevo trabajo a una rama diferente del servidor (por ejemplo a 'featureAv2').</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>So, if you see that a method in your code is buggy, you can annotate the file with `git blame` to see when each line of the method was last edited and by whom.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T165029Z" changeid="juan">
        <seg>Así, cuando se está frente a una porción de código con problemas, se puede emplear el comando `git blame` para anotar ese archivo y ver así cuándo y por quién fue editada por última vez cada una de sus líneas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git cat-file -p fdf4fc3
	tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579
	author Scott Chacon &lt;schacon@gmail.com&gt; 1243040974 -0700
	committer Scott Chacon &lt;schacon@gmail.com&gt; 1243040974 -0700</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T180344Z" changeid="juan">
        <seg>$ git cat-file -p fdf4fc3
	tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579
	author Scott Chacon &lt;schacon@gmail.com&gt; 1243040974 -0700
	committer Scott Chacon &lt;schacon@gmail.com&gt; 1243040974 -0700</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The `-w` tells `hash-object` to store the object; otherwise, the command simply tells you what the key would be.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T142850Z" changeid="juan">
        <seg>La opción '-w' indica a 'hash-object' que ha de guardar el objeto; de otro modo, el comando solo te respondería cual sería su clave.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It takes only a few minutes to do.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En tan solo unos minutos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Finally, the `post-merge` hook runs after a successful `merge` command.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y, por último, el punto de enganche 'post-merge' se activa tras completarse la ejecución de un comando 'git merge'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now Git knows that if it tries to do a diff between two snapshots, and any of the files end in `.doc`, it should run those files through the &quot;word&quot; filter, which is defined as the `strings` program.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>A partir de ahora, Git sabe que si intenta realizar una comparación entre dos momentos determinados (snapshots), y si cualquiera de los archivos a comparar termina en '.doc', tiene que pasar antes esos archivos por el filtro &quot;word&quot;, es decir, por el programa 'strings'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>By default, Git populates this directory with a bunch of example scripts, many of which are useful by themselves; but they also document the input values of each script.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por defecto, esta carpeta contiene unos cuantos scripts de ejemplo. Algunos de ellos son útiles por sí mismos; pero su misión principal es la de documentar las variables de entrada para cada script.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ cat .gitmodules
	[submodule &quot;rack&quot;]
	      path = rack
	      url = git://github.com/chneukirchen/rack.git</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T103753Z" changeid="juan">
        <seg>$ cat .gitmodules
	[submodule &quot;rack&quot;]
	      path = rack
	      url = git://github.com/chneukirchen/rack.git</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Update&gt;&gt;
	updated 2 paths</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T212803Z" changeid="juan">
        <seg>Update&gt;&gt;
	updated 2 paths</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This process is similar across all operating systems.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El proceso para hacerlo es similar en casi cualquier sistema operativo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>People must have access to your machine over SSH to access it, even in a read-only capacity, which doesn’t make SSH access conducive to open source projects.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Todos han de tener configurado un acceso SSH al servidor, incluso aunque sea con permisos de solo lectura; lo que no lo hace recomendable para soportar proyectos abiertos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>On other systems, you may want to use `xinetd`, a script in your `sysvinit` system, or something else — as long as you get that command daemonized and watched somehow.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En otros sistemas operativos, puedes utilizar 'xinetd', un script en el sistema 'sysvinit', o alguna otra manera --siempre y cuando demonizes el comando y puedas monitorizarlo--.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Suppose you’ve decided that your issue #53 work is complete and ready to be merged into your `master` branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Supongamos que tu trabajo con el problema #53 está ya completo y listo para fusionarlo (merge) con la rama 'master'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Switching branches with submodules in them can also be tricky.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T135141Z" changeid="juan">
        <seg>Intercambiar ramas con submódulos tiene también sus peculiaridades.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ cd gitosis-admin
	$ find .</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ cd gitosis-admin
	$ find .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For instance, if Jessica sends you an e-mail saying that she has a great new feature in the `ruby-client` branch of her repository, you can test it by adding the remote and checking out that branch locally:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por ejemplo, si Jessica te envia un correo electrónico comentandote que tiene una nueva e interesante funcionalidad en la rama 'ruby-client' de su repositorio. Puedes probarla añadiendo el remoto correspondiente y recuperando localmente dicha rama.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>How does Git know what branch you’re currently on?</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y, ¿cómo sabe Git en qué rama estás en este momento?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Instead of</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En lugar de </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Algunas personas resaltan que uno de los puntos mas fuertes de Git es su sistema de ramificaciones y lo cierto es que esto le hace resaltar sobre los otros sistemas de control de versiones.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Algunas personas resaltan que uno de los puntos mas fuertes de Git es su sistema de ramificaciones y lo cierto es que esto le hace resaltar sobre los otros sistemas de control de versiones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>All the script does is get the latest commit date from the `git log` command, stick that into any `$Date$` strings it sees in stdin, and print the results — it should be simple to do in whatever language you’re most comfortable in.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Simplemente, utiliza el comando 'git log' para obtener la fecha de la última confirmación de cambios, y  sustituye con ella todas las cadenas '$Date$' que encuentre en el flujo de entrada stdin; imprimiendo luego los resultados. --Debería de ser sencillo de implementarlo en cualquier otro lenguaje que domines.--</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ cat .git/refs/tags/v1.1
	9585191f37f7b0fb9444f35a9bf50de191beadc2</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T234314Z" changeid="juan">
        <seg>$ cat .git/refs/tags/v1.1
	9585191f37f7b0fb9444f35a9bf50de191beadc2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In Chapter 7, we’ll discuss how you can change this default value for your environment.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En el capítulo 7 se verá cómo cambiar este valor por defecto de tu entorno de trabajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>I hope you can use your newfound knowledge of Git internals to implement your own cool application of this technology and feel more comfortable using Git in more advanced ways.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T141741Z" changeid="juan">
        <seg>Espero que uses este nuevo conocimiento profundo de las entrañas de Git para implementar tus propias aplicaciones y para que te encuentres más confortable trabajando con Git de forma avanzada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0514.png
Figure 5-14.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0514.png
Figura 5-14.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Everyone knows that Word is the most horrific editor around; but, oddly, everyone uses it.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Todo el mundo conoce el hecho de que Word es el editor más horroroso de cuantos hay; pero, desgraciadamente, todo el mundo lo usa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg># Jessica's Machine
	$ git checkout -b featureA
	Switched to a new branch &quot;featureA&quot;
	$ vim lib/simplegit.rb
	$ git commit -am 'add limit to log function'
	[featureA 3300904] add limit to log function
	 1 files changed, 1 insertions(+), 1 deletions(-)</seg>
      </tuv>
      <tuv lang="ES">
        <seg># Jessica's Machine
	$ git checkout -b featureA
	Switched to a new branch &quot;featureA&quot;
	$ vim lib/simplegit.rb
	$ git commit -am 'add limit to log function'
	[featureA 3300904] add limit to log function
	 1 files changed, 1 insertions(+), 1 deletions(-)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Or you can do this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>O como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To phrase that another way, when you try to merge one commit with a commit that can be reached by following the first commit’s history, Git simplifies things by moving the pointer forward because there is no divergent work to merge together — this is called a &quot;fast forward&quot;.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Dicho de otro modo: cuando intentas fusionar una confirmación con otra confirmación accesible siguiendo directamente el registro de la primera; Git simplifica las cosas avanzando el puntero, ya que no hay ningûn otro trabajo divergente a fusionar. Esto es lo que se denomina &quot;avance rápido&quot; (&quot;fast forward&quot;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### The SSH Protocol ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### El Procotolo SSH ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Integration-Manager Workflow ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Flujo de trabajo del Gestor-de-Integraciones ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In most projects, that’s `.git/hooks`.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En la mayoría de proyectos, estará en '.git/hooks'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In this case, choose `1c002dd....` If you `git show` that commit, the following commands are equivalent (assuming the shorter versions are unambiguous):</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T184804Z" changeid="juan">
        <seg>En este caso, escogiendo '1c002dd....', para lanzar el comando 'git show' sobre esa confirmación de cambios concreta, serían equivalentes todos estos comandos (asumiendo la no ambiguedad de todas las versiones cortas indicadas):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The process works like this (see Figure 5-3):</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El proceso funciona como sigue (ver Figura 5-3):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git shortlog --no-merges master --not v1.0.1
	Chris Wanstrath (8):
	      Add support for annotated tags to Grit::Tag
	      Add packed-refs annotated tag support.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git shortlog --no-merges master --not v1.0.1
	Chris Wanstrath (8):
	      Add support for annotated tags to Grit::Tag
	      Add packed-refs annotated tag support.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For instance, you can add a remote called `origin` and push your `master` branch to it:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110810T224858Z" changeid="juan">
        <seg>Por ejemplo, puedes añadir un remoto denominado `origin` y enviar a él tu rama  `master`:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When you restart Apache, you should be able to clone your repositories under that directory by specifying the URL for your project:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Una vez reinicies Apache, ya deberias ser capaz de clonar tus repositorios bajo dicha carpeta, simplemente indicando la URL de tu projecto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>These are the &quot;clean&quot; and &quot;smudge&quot; filters.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esos son los filtros &quot;clean&quot; y &quot;smudge&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git show HEAD^^^
	commit 1c3618887afb5fbcbea25b7c013f4e2114448b8d
	Author: Tom Preston-Werner &lt;tom@mojombo.com&gt;
	Date:   Fri Nov 7 13:47:59 2008 -0500</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T114833Z" changeid="juan">
        <seg>$ git show HEAD^^^
	commit 1c3618887afb5fbcbea25b7c013f4e2114448b8d
	Author: Tom Preston-Werner &lt;tom@mojombo.com&gt;
	Date:   Fri Nov 7 13:47:59 2008 -0500</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now, you need to make Apache use CGI for that script, for which you can add a VirtualHost:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>A continuación, tienes que preparar Apache para que utilice dicho script, Para ello, puedes añadir un VirtualHost:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you’re programming on Windows or using another system but working with people who are programming on Windows, you’ll probably run into line-ending issues at some point.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si estás programando en Windows o utilizando algún otro sistema, pero colaborando con gente que programa en Windows. Es muy posible que alguna vez te topes con problemas de finales de línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This shows your other branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto nos muestra la otra rama en el proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To use this, specify `git-shell` instead of bash or csh for your user’s login shell.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para especificar el 'git-shell' en lugar de bash o de csh como el shell de inicio de sesión de un usuario,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git merge origin/master
	Auto-merging lib/simplegit.rb
	Merge made by recursive.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git merge origin/master
	Auto-merging lib/simplegit.rb
	Merge made by recursive.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## Public Access ##</seg>
      </tuv>
      <tuv lang="ES">
        <seg>## Acceso público ##</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The `keydir` directory is where you store the public keys of all the users who have any sort of access to your repositories — one file per user.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La carpeta 'keydir' es donde almacenarás las claves públicas para los usuarios con acceso a tus repositorios --un archivo por usuario--.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In this case, you’d do your work in a branch and then rebase your work onto `origin/master` when you were ready to submit your patches to the main project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En casos como esos, puedes trabajar sobre una rama y luego reorgainzar lo realizado en la rama 'origin/master' cuando lo tengas todo listo para enviarlo al proyecto principal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It’s generally used by huge projects with hundreds of collaborators; one famous example is the Linux kernel.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Se utiliza generalmente en proyectos muy grandes, con cientos de colaboradores. Un ejemplo muy conocido es el del kernel de Linux.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you look in your objects directory, you’ll find that most of your objects are gone, and a new pair of files has appeared:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T114125Z" changeid="juan">
        <seg>Tras esto, si miras los objetos presentes en la carpeta, veras que han desaparecido la mayoria de los que habia anteriormente. Apareciendo un par de objetos nuevos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>remote: Total 3184 (delta 1952), reused 2770 (delta 1675)
	Receiving objects: 100% (3184/3184), 677.42 KiB | 4 KiB/s, done.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T142019Z" changeid="juan">
        <seg>remote: Total 3184 (delta 1952), reused 2770 (delta 1675)
	Receiving objects: 100% (3184/3184), 677.42 KiB | 4 KiB/s, done.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now you can revert the file back to the first version</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Podrás revertir el archivo a su primera versión:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>secure this thing</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T072731Z" changeid="juan">
        <seg>secure this thing</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The `git branch` command does more than just create and delete branches.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El comando 'git branch' tiene más funciones que las de crear y borrar ramas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It’s generally a good idea to do this in a testing branch and then hard-reset your master branch after you’ve determined the outcome is what you really want.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120827T142413Z" changeid="juan">
        <seg>Una recomendación: en general, suele ser buena idea lanzar cualquiera de estas operaciones primero sobre una rama de pruebas y luego reinicializar (hard-reset) la rama maestra (master), una vez se haya comprobado que el resultado de las operaciones es el esperado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The GitHub user signup form.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El formulario de registro en GitHub.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git branch --merged
	  iss53
	* master</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git branch --merged
	  iss53
	* master</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>As you’re working, Git silently records what your HEAD is every time you change it.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T142810Z" changeid="juan">
        <seg>Según trabajas, Git suele guardar un silencioso registro de donde está HEAD en cada momento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For example, to modify only the third commit message, you change the file to look like this:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T185643Z" changeid="juan">
        <seg>Por ejemplo, para modificar solo el mensaje de la tercera confirmación de cambios, el script quedaria:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You’ll be able to watch Git rewriting trees and commits and then move the branch pointer at the end.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120827T142300Z" changeid="juan">
        <seg>Y se iria viendo como Git reescribe árboles y confirmaciones de cambio, hasta que el apuntador de la rama llegue al final.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git config --system receive.denyDeletes true</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git config --system receive.denyDeletes true</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Let’s switch back to the master branch:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Volvamos ahora a la rama 'master':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You have two nearly identical 12K objects on your disk.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T113821Z" changeid="juan">
        <seg>Y, así, tienes en tu disco dos objetos de 12 Kbytes prácticamente idénticos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The first thing you need to do is set up a free user account.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El primer paso es dar de alta una cuenta gratuita.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>are available in the git repository at:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>are available in the git repository at:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When you specify a subtree merge, Git is smart enough to figure out that one is a subtree of the other and merge appropriately — it’s pretty amazing.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T173244Z" changeid="juan">
        <seg>Cuando se solicita una fusión subarborea, Git es lo suficientemente inteligente como para imaginarse por si solo que uno de los proyectos es un subárbol del otro y obrar en consecuencia. Es realmente sorprendente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>added some blame and merge stuff</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T095200Z" changeid="juan">
        <seg>added some blame and merge stuff</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ cat .git/packed-refs
	# pack-refs with: peeled
	cac0cab538b970a37ea1e769cbbde608743bc96d refs/heads/experiment
	ab1afef80fac8e34258ff41fc1b867c702daa24b refs/heads/master
	cac0cab538b970a37ea1e769cbbde608743bc96d refs/tags/v1.0
	9585191f37f7b0fb9444f35a9bf50de191beadc2 refs/tags/v1.1
	^1a410efbd13591db07496601ebc7a059dd55cfe9</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T092605Z" changeid="juan">
        <seg>$ cat .git/packed-refs
	# pack-refs with: peeled
	cac0cab538b970a37ea1e769cbbde608743bc96d refs/heads/experiment
	ab1afef80fac8e34258ff41fc1b867c702daa24b refs/heads/master
	cac0cab538b970a37ea1e769cbbde608743bc96d refs/tags/v1.0
	9585191f37f7b0fb9444f35a9bf50de191beadc2 refs/tags/v1.1
	^1a410efbd13591db07496601ebc7a059dd55cfe9</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Also, because we’re recording the parents when we commit, finding a proper merge base for merging is automatically done for us and is generally very easy to do.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y, además, debido a que se almacenan tambien los nodos padre para cada confirmación, el encontrar las bases adecuadas para realizar una fusión entre ramas es un proceso automático y generalmente sencillo de realizar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>She’s ready to push up her work, but gets an e-mail from Josie that a branch with some initial work on it was already pushed to the server as `featureBee`.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cuando está preparada para enviar (push) su trabajo, recibe un correo-e de Josie de que ha puesto en el servidor una rama denominada 'featureBee', con algo de trabajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now you can fast-forward your master branch (see Figure 3-33):</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y, tras esto, ya puedes avanzar la rama principal (ver Figura 3-33):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>That command did two things.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Este comando realiza dos acciones:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If John, Josie, and Jessica all sign up for accounts on GitHub, and you want to give them push access to your repository, you can add them to your project as collaborators.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si tanto John, como Josie, como Jessica, todos ellos registran sus respectivas cuentas en GitHub. Y deseas darles acceso de escritura a tu repositorio. Puedes incluirlos en tu proyecto como colaboradores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Everything is set up.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Una vez esté todo listo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Deleting References ###</seg>
      </tuv>
      <tuv lang="ES" changedate="20110817T154132Z" changeid="juan">
        <seg>### Borrando referencias ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git log -1 --name-only --pretty=format:'' 9f585d</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git log -1 --name-only --pretty=format:'' 9f585d</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you want to do something one time, you can specify the refspec on the command line, too.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T115430Z" changeid="juan">
        <seg>Para hacerlo puntualmente en un momento concreto, puedes especificar la referencia directamente en la linea de comando.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You’ll use a Perl expression to clean that up on commit:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes utilizar una expresión Perl para limpiarlos (clean) al almacenarlos (commit):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>From git@github.com:schacon/rack
	 * [new branch]      build      -&gt; rack_remote/build
	 * [new branch]      master     -&gt; rack_remote/master
	 * [new branch]      rack-0.4   -&gt; rack_remote/rack-0.4
	 * [new branch]      rack-0.9   -&gt; rack_remote/rack-0.9
	$ git checkout -b rack_branch rack_remote/master
	Branch rack_branch set up to track remote branch refs/remotes/rack_remote/master.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T142024Z" changeid="juan">
        <seg>From git@github.com:schacon/rack
	 * [new branch]      build      -&gt; rack_remote/build
	 * [new branch]      master     -&gt; rack_remote/master
	 * [new branch]      rack-0.4   -&gt; rack_remote/rack-0.4
	 * [new branch]      rack-0.9   -&gt; rack_remote/rack-0.9
	$ git checkout -b rack_branch rack_remote/master
	Branch rack_branch set up to track remote branch refs/remotes/rack_remote/master.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The ability of smaller subgroups of a team to collaborate via remote branches without necessarily having to involve or impede the entire team is a huge benefit of Git.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La habilidad para que pequeños subgrupos de un equipo colaboren a través de ramas remotas, sin necesidad de tener en cuenta o de perturbar el equipo completo, es un gran beneficio de trabajar con Git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git filter-branch --index-filter \
	   'git rm --cached --ignore-unmatch git.tbz2' -- 6df7640^..</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T110439Z" changeid="juan">
        <seg>$ git filter-branch --index-filter \
	   'git rm --cached --ignore-unmatch git.tbz2' -- 6df7640^..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>&gt;&gt; require 'zlib'
	=&gt; true
	&gt;&gt; zlib_content = Zlib::Deflate.deflate(store)
	=&gt; &quot;x\234K\312\311OR04c(\317H,Q\310,V(-\320QH\311O\266\a\000_\034\a\235&quot;</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T181747Z" changeid="juan">
        <seg>&gt;&gt; require 'zlib'
	=&gt; true
	&gt;&gt; zlib_content = Zlib::Deflate.deflate(store)
	=&gt; &quot;x\234K\312\311OR04c(\317H,Q\310,V(-\320QH\311O\266\a\000_\034\a\235&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The nice thing about this wrapper setup is that you can change your diff and merge tools easily.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Lo bonito de estos ajustes con scripts, es que puedes cambiar facilmente tus herramientas de comparación (diff) y de fusión (merge).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This example uses the `-L` option to limit the output to lines 12 through 22:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120827T143645Z" changeid="juan">
        <seg>En este ejemplo, se ha utilizado la opción `-L` para limitar la salida a las líneas desde la 12 hasta la 22: </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ ssh-keygen
	Generating public/private rsa key pair.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ ssh-keygen
	Generating public/private rsa key pair.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It’s important to note that anything your script prints to stdout will be transferred to the client.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cabe destacar que todo lo que se envie a la salida estandar stdout, será transferido al cliente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>However, `strings` is available on most Mac and Linux systems, so it may be a good first try to do this with many binary formats.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Sin embargo, ya que 'strings' está disponible para la mayor parte de los sistemas Mac y Linux, es buena idea probar primero con él para trabajar con formatos binarios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When you’re finished adding collaborators, you should see a list of them in the Repository Collaborators box (see Figure 4-12).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cuando termines de añadir colaboradores, podrás ver a todos ellos en la lista &quot;Repository Collaborators&quot; (ver Figura 4-12).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you created a working directory from the new tree you just wrote, you would get the two files in the top level of the working directory and a subdirectory named `bak` that contained the first version of the test.txt file.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110807T145256Z" changeid="juan">
        <seg>Si crearas una carpeta de trabajo a partir de este nuevo árbol que acabas de escribir, obtendrías los dos archivos en el nivel principal de la carpeta de trabajo y una subcarpeta llamada `bak` conteniendo la primera versión del archivo test.txt. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The answer to this issue is the `git stash` command.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120712T202337Z" changeid="juan">
        <seg>Y su solución es el comando 'git stash'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can also have modified and uncommitted files in your working directory when you apply a stash — Git gives you merge conflicts if anything no longer applies cleanly.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T093632Z" changeid="juan">
        <seg>Es posible incluso aplicar de vuelta cambios sobre un espacio de trabajo inconsistente, donde haya otros cambios o algunos archivos añadidos al área de preparación. (Git notificará de los correspondientes conflictos de fusión si todo ello no se puede aplicar limpiamente.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0320.png
Figure 3-20.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0320.png
Figura 3-20.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### File Annotation ###</seg>
      </tuv>
      <tuv lang="ES" changedate="20120827T143239Z" changeid="juan">
        <seg>### Anotaciones en los archivos ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>#### pre-receive and post-receive ####</seg>
      </tuv>
      <tuv lang="ES">
        <seg>#### 'pre-receive' y 'post-receive' ####</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can take that output, loop through each of those commit SHAs, grab the message for it, and test that message against a regular expression that looks for a pattern.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes coger esta salida, establecer un bucle para recorrer cada una de esas confirmaciones de cambios, coger el mensaje de cada una y comprobarlo contra una expresión regular de búsqueda del patrón deseado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The key fingerprint is:
	43:c5:5b:5f:b1:f1:50:43:ad:20:a6:92:6a:1f:9a:3a schacon@agadorlaptop.local</seg>
      </tuv>
      <tuv lang="ES">
        <seg>The key fingerprint is:
	43:c5:5b:5f:b1:f1:50:43:ad:20:a6:92:6a:1f:9a:3a schacon@agadorlaptop.local</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you want to make the `trunk` subdirectory be the new project root for every commit, `filter-branch` can help you do that, too:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120827T142914Z" changeid="juan">
        <seg>`filter-branch` puede ser de utilidad para que, por ejemplo, la subcarpeta `trunk` sea la nueva carpeta raiz del proyecto en todas y cada una de las confirmaciones de cambios:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Another way to do it is to have your SSH server authenticate from an LDAP server or some other centralized authentication source that you may already have set up.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y una tercera forma es el preparar un servidor SSH autenficado desde un servidor LDAP o desde alguna otra fuente de autenficación externa ya disponible.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This combination effectively filters all C source code files through `indent` before committing.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El efecto final de esta combinación es el de filtrar todo el código fuente C a través de 'indent' antes de confirmar cambios en él.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git checks for any listed alternates first:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T130854Z" changeid="juan">
        <seg>Git comprueba primero a ver si en el listado hay alguna alternativa:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>So, if you want to make a single commit from these three commits, you make the script look like this:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120728T091848Z" changeid="juan">
        <seg>Por ejemplo, si se desea hacer una única confirmación de cambios fusionando las tres, el script quedaría en algo como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg># This is the 2nd commit message:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120728T092012Z" changeid="juan">
        <seg># This is the 2nd commit message:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The pros of using SSH are many.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El uso de SSH tiene múltiples ventajas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>First you have to find it.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T105248Z" changeid="juan">
        <seg>Lo primero es localizar el archivo enorme.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Furthermore, what overall workflow do you want to use to maintain your project?</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Yendo aún más lejos, ?cual es el sistema de trabajo que deseas utilizar para el mantenimiento de tu proyecto?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>[remote &quot;origin&quot;]
	       url = git@github.com:schacon/simplegit-progit.git
	       fetch = +refs/heads/master:refs/remotes/origin/master
	       fetch = +refs/heads/qa/*:refs/remotes/origin/qa/*</seg>
      </tuv>
      <tuv lang="ES" changedate="20110815T221756Z" changeid="juan">
        <seg>[remote &quot;origin&quot;]
	       url = git@github.com:schacon/simplegit-progit.git
	       fetch = +refs/heads/master:refs/remotes/origin/master
	       fetch = +refs/heads/qa/*:refs/remotes/origin/qa/*</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Because that server is a subset of the data your `origin` server has right now, Git fetches no data but sets a remote branch called `teamone/master` to point to the commit that `teamone` has as its `master` branch (see Figure 3-26).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Debido a que dicho servidor es un subconjunto de de los datos del servidor 'origin' que tienes actualmente, Git no recupera (fetch) ningún  dato; simplemente prepara una rama remota llamada 'teamone/master' para apuntar a la confirmación (commit) que 'teamone' tiene en su rama 'master'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg># John's Machine
	$ git push origin master
	To john@githost:simplegit.git
	 !</seg>
      </tuv>
      <tuv lang="ES">
        <seg># John's Machine
	$ git push origin master
	To john@githost:simplegit.git
	 !</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Here you can do a number of things, including staging files, unstaging files, staging parts of files, adding untracked files, and seeing diffs of what has been staged.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T092157Z" changeid="juan">
        <seg>Aquí se pueden lanzar acciones tales como: añadir archivos en el area de preparación (staging), sacar archivos de ella (unstaging), poner solo parte de algún archivo, añadir archivos nuevos que estaban fuera del sistema de control o mostrar diferencias en aquello que se ha añadido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Fast-forwarding the master branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Avance rápido de la rama 'master'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Again, the public keys look something like this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y recordando que las claves públicas son algo así como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To upload data to a remote process, Git uses the `send-pack` and `receive-pack` processes.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110820T073723Z" changeid="juan">
        <seg>Para enviar datos a un proceso remoto, Git utliza  `send-pack` (enviar paquete) y `receive-pack` (recibir paquete). </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ cd /opt/git
	$ mkdir project.git
	$ cd project.git
	$ git --bare init</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ cd /opt/git
	$ mkdir project.git
	$ cd project.git
	$ git --bare init</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now, someone else does more work that includes a merge, and pushes that work to the central server.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Ahora, otra persona trabaja también sobre ello, realiza una fusión (merge) y lleva (push) su trabajo al servidor central.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git cat-file -p 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0
	100644 blob 47c6340d6459e05787f644c2447d2595f5d3a54b      simplegit.rb</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T180301Z" changeid="juan">
        <seg>$ git cat-file -p 99f1a6d12cb4b6f19c8655fca46c3ecf317074e0
	100644 blob 47c6340d6459e05787f644c2447d2595f5d3a54b      simplegit.rb</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>A GitHub main project page.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Una página principal de proyecto GitHub.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git has a few configuration options to help with these issues.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Git dispone de algunas opciones de configuración para ayudarnos con estos problemas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It’s also possible for Git to stage certain parts of files and not the rest.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120712T201715Z" changeid="juan">
        <seg>También es posible añadir solo ciertas partes de algunos archivos y no otras.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can create your own tree.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110801T121605Z" changeid="juan">
        <seg>Puedes crear tu propio árbol.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Each time you have a new topic branch to merge in (Figure 5-21), you merge it into `develop` (Figure 5-22); then, when you tag a release, you fast-forward `master` to wherever the now-stable `develop` branch is (Figure 5-23).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cada vez que tengas una nueva rama puntual lista para integrar (Figura 5-21), la fusionarás en la rama 'develop'. Y  cuando marques el lanzamiento de una versión estable, avanzarás la rama 'master' hasta el punto donde la rama 'develop' se encuentre en ese momento (Figura 5-23). </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This technique only works for data that’s still in your reflog, so you can’t use it to look for commits older than a few months.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T191020Z" changeid="juan">
        <seg>Esta técnica tan solo funciona para información presente en el registro de referencia. No se puede emplear para confirmaciones de cambio de antiguedad superior a unos pocos meses.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Here is a method that gives you an associative array where the key is the user name and the value is an array of paths to which the user has write access:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Este es un método que te devuelve un array asociativo cuya clave es el nombre del usuario y su valor es un array de ubicaciones (paths) donde ese usuario tiene acceso de escritura:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Generally, you’ll pair it with SSH access for the few developers who have push (write) access and have everyone else use `git://` for read-only access.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Habitualmente, lo combinarás con un acceso SSH para los pocos desarrolladores con acceso de escritura que envien (push) material. Usando 'git://' para los accesos solo-lectura del resto de personas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>I leave it up to you to decide.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Lo dejo en tus manos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Working in Topic Branches ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Trabajando con Ramas Puntuales ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>First, let’s review where your repository is at this point:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T133112Z" changeid="juan">
        <seg>Lo primero es revisar el estado de tu repositorio en ese momento:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In this case, I was trying to apply a patch I had already applied.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En este caso, estamos intentando incorporar un parche que ya tenemos incorporado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It shows you a list of your staged files, and you can select the ones for which you would like to see the staged diff.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T092622Z" changeid="juan">
        <seg>Esta muestra una lista de los archivos preparados en el área de preparación, permitiendo la seleccion de aquellos sobre los que  se desean ver diferencias.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The reason to do it this way is speed — because Git doesn’t have to check out each revision to disk before running your filter, the process can be much, much faster.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T135213Z" changeid="juan">
        <seg>Con eso conseguimos aumentar la velocidad. El proceso es mucho más rápido, porque Git no ha de activar cada revisión a disco antes de procesar tu filtro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The Git project also has a `maint` branch that is forked off from the last release to provide backported patches in case a maintenance release is required.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El proyecto Git dispone también de una rama 'maint' que se bifurca (fork) a partir de la última versión ya lanzada; para trabajar en parches, en caso de necesitarse alguna versión intermedia de mantenimiento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You’ll learn a few of the common uses so you can get an idea of some of the things it’s capable of.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T191643Z" changeid="juan">
        <seg>Se van a ilustrar unas cuantas de las ocasiones donde se podría utilizar,  para dar así una idea de sus capacidades.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Also, running `git pull` while on one of these branches fetches all the remote references and then automatically merges in the corresponding remote branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Igualmente, tecleando 'git pull' mientras estamos en una de esas ramas, recupera (fetch) todas las referencias remotas y las fusiona (merge) automáticamente en la correspondiente rama remota.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The first hook that is run is `applypatch-msg`.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El primer punto de enganche que se activa es 'applypatch-msg'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>[Jessica Smith &lt;jessica@example.com&gt;]
	Emails will be sent from: Jessica Smith &lt;jessica@example.com&gt;
	Who should the emails be sent to?</seg>
      </tuv>
      <tuv lang="ES">
        <seg>[Jessica Smith &lt;jessica@example.com&gt;]
	Emails will be sent from: Jessica Smith &lt;jessica@example.com&gt;
	Who should the emails be sent to?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To exit the script and reject the push, exit non-zero.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para salir del script y rechazar el envio, recuerda que debes salir con un código distinto de cero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git show HEAD@{5}</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T102347Z" changeid="juan">
        <seg>$ git show HEAD@{5}</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git provides an easy way to check for this — before you commit, run `git diff --check`, which identifies possible whitespace errors and lists them for you.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Git nos permite buscarlos facilmente. Previamente a realizar una confirmación de cambios, lanzar el comando 'git diff --check' para identificar posibles errores de espaciado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git read-tree --prefix=rack/ -u rack_branch</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T142611Z" changeid="juan">
        <seg>$ git read-tree --prefix=rack/ -u rack_branch</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If the apply tries to modify a file that you’ve since modified, you’ll get a merge conflict and will have to try to resolve it.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T094141Z" changeid="juan">
        <seg>Si  para recuperar esos cambios se ha de modificar un archivo que también haya sido modificado en los trabajos posteriores, se dará un conflicto de fusión (merge conflict) y será preciso resolverlo manualmente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Binary Search ###</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T070425Z" changeid="juan">
        <seg>### Búsqueda binaria ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0521.png
Figure 5-21.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0521.png
Figura 5-21.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Just for fun, you’ll add the first tree as a subdirectory into this one.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110807T144850Z" changeid="juan">
        <seg>Simplemente por diversión, puedes añadir el primer árbol como una subcarpeta de este otro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In this case, to keep the example simple, you’ll only enforce the `avail` directives.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En este caso, por razones de simplicidad, vamos a mostrar únicamente la forma de implementar las directivas 'avail' (permitir).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ apt-get install python-setuptools</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ apt-get install python-setuptools</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The `--no-commit` option tells Git not to automatically record a commit.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La opción '--no-commit' indica a Git que no debe registrar automáticamente una confirmación de cambios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>changed the version number</seg>
      </tuv>
      <tuv lang="ES">
        <seg>changed the version number</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Finally, she merges John’s work into her own `featureA` branch:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para terminar, fusiona el trabajo de John en su propia rama 'featureA':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Jessica’s commit history now looks something like Figure 5-13.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Quedando su historial como se muestra en la Figura 5-13.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git log --left-right master...experiment
	&lt; F
	&lt; E
	&gt; D
	&gt; C</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T202827Z" changeid="juan">
        <seg>$ git log --left-right master...experiment
	&lt; F
	&lt; E
	&gt; D
	&gt; C</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The next two fields are values extracted from that commit—the author name and the authored date of that commit — so you can easily see who modified that line and when.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T165055Z" changeid="juan">
        <seg>Los dos siguientes campos son sendos valores extraidos de dicha confirmación de cambios --el nombre del autor y la fecha--, mostrando quien y cuándo modifico esa línea.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It’s pretty easy on your part.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Es realmente sencillo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To create a commit object, you call `commit-tree` and specify a single tree SHA-1 and which commit objects, if any, directly preceded it.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T195653Z" changeid="juan">
        <seg>Para crearlos, tan solo has de llamar al comando `commit-tree`, indicando uno de los árboles SHA-1 y los objetos de confirmación de cambios que lo preceden (si es que lo precede alguno). </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The `pre-rebase` hook runs before you rebase anything and can halt the process by exiting non-zero.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El punto 'pre-rebase' se activa antes de cualquier reorganización y puede abortarla si retorna con un codigo de salida distinto de cero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If we have a repository with work in two branches named `ruby_client` and `php_client` that looks like Figure 5-19 and merge `ruby_client` first and then `php_client` next, then your history will end up looking like Figure 5-20.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si, tal y como se muestra en la Figura 5-19,  tenemos un repositorio con trabajos en dos ramas, denominadas 'ruby client' y 'php client'; y fusionamos primero la rama 'ruby client' y luego la 'php client', obtendremos un historial similar al de la Figura 5-20.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can see from the size value that the big object is still in your loose objects, so it’s not gone; but it won’t be transferred on a push or subsequent clone, which is what is important.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T135449Z" changeid="juan">
        <seg>Por el valor de &quot;size&quot;, puedes ver que el objeto enorme sigue estando entre tus objetos sueltos; es decir, no hemos acabado completamente con él. Pero lo importante es que ya no será considerado al transferir o clonar el proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you do sign your tags, you may have the problem of distributing the public PGP key used to sign your tags.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si firmas tus etiquetas, puedes tener un problema a la hora de distribuir la clave PGP pública utilizada en la firma.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git status
	# On branch master
	nothing to commit, working directory clean</seg>
      </tuv>
      <tuv lang="ES" changedate="20120702T085314Z" changeid="juan">
        <seg>$ git status
	# On branch master
	nothing to commit, working directory clean</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You’ll add a new section called `mobile` where you’ll list the developers on your mobile team and projects that those developers need access to.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por ejemplo, puedes añadir una nueva sección denominada 'mobile', donde poner la lista de los desarrolladores en tu equipo movil y los proyectos donde estos vayan a trabajar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Both of those changes are isolated in separate branches: you can switch back and forth between the branches and merge them together when you’re ready.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Los cambios realizados en ambas sesiones de trabajo están aislados en ramas independientes: puedes saltar libremente de una a otra según estimes oportuno.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>After you’ve resolved each of these sections in each conflicted file, run `git add` on each file to mark it as resolved.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tras resolver todos los bloques conflictivos, has de lanzar comandos 'git add' para marcar cada archivo modificado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To stage the TODO and index.html files, you can type the numbers:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T212547Z" changeid="juan">
        <seg>Para añadir los archivos TODO e index.html, se teclearian los números:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The update file runs once per branch being pushed and takes the reference being pushed to, the old revision where that branch was, and the new revision being pushed.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El script 'update' se lanza una vez por cada rama que se envia (push) al servidor; y recibe la referencia de la rama a la que se envia, la antigua revisión en que estaba la rama y la nueva revisión que se está enviando.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The `post-receive` hook runs after the entire process is completed and can be used to update other services or notify users.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El punto de enganche 'post-receive' se activa cuando termina todo el proceso, y se puede utilizar para actualizar otros servicios o para enviar notificaciones a otros usuarios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Recently, I was refactoring a file named `GITServerHandler.m` into multiple files, one of which was `GITPackUpload.m`.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T165220Z" changeid="juan">
        <seg>Por ejemplo, si se estaba refactorizando un archivo llamado `GITServerHandler.m`, para trocearlo en múltiples archivos, siendo uno de estos `GITPackUpload.m`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For instance, suppose you create a template file at `$HOME/.gitmessage.txt` that looks like this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por ejemplo, imagina que creas una plantilla en '$HOME/.gitmessage.txt'; con un contenido tal como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Long-Running Branches ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Ramas de largo recorrido ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>More detailed explanatory text, if necessary.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Seguido de un texto más detallado, si es necesario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>#### receive.denyNonFastForwards ####</seg>
      </tuv>
      <tuv lang="ES">
        <seg>#### receive.denyNonFastForwards ####</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you’re on a tracking branch and type git push, Git automatically knows which server and branch to push to.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si estás en una rama de seguimiento y tecleas el comando 'git push', Git sabe automáticamente a qué servidor y a qué rama ha de llevar los contenidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## Git Attributes ##</seg>
      </tuv>
      <tuv lang="ES">
        <seg>## Atributos de Git ##</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>One very useful option is to tell Git to not try to merge specific files when they have conflicts, but rather to use your side of the merge over someone else’s.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Una opción muy util es la que nos permite indicar a Git que no intente fusionar ciertos archivos concretos cuando tengan conflictos, manteniendo en su lugar tus archivos sobre los de cualquier otro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git cat-file -p 9585191f37f7b0fb9444f35a9bf50de191beadc2
	object 1a410efbd13591db07496601ebc7a059dd55cfe9
	type commit
	tag v1.1
	tagger Scott Chacon &lt;schacon@gmail.com&gt; Sat May 23 16:48:58 2009 -0700</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T234340Z" changeid="juan">
        <seg>$ git cat-file -p 9585191f37f7b0fb9444f35a9bf50de191beadc2
	object 1a410efbd13591db07496601ebc7a059dd55cfe9
	type commit
	tag v1.1
	tagger Scott Chacon &lt;schacon@gmail.com&gt; Sat May 23 16:48:58 2009 -0700</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Fast-forwarding your master branch to include the client branch changes.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Avance rápido de tu rama 'master', para incluir los cambios de la rama 'client'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Because the server will tell you that you can’t push a non-fast-forward anyway, and the hook prevents forced pushes, the only accidental thing you can try to catch is rebasing commits that have already been pushed.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>De todas formas, el único aspecto accidental que puede interesante capturar son los intentos de reorganizar confirmaciones de cambios ya enviadas. El servidor te avisará de que no puedes enviar ningún no-avance-rapido, y el enganche te impedirá cualquier envio forzado</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Using attributes, you can do things like specify separate merge strategies for individual files or directories in your project, tell Git how to diff non-text files, or have Git filter content before you check it into or out of Git.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por medio de los atributos, puedes hacer cosas tales como indicar diferentes estrategias de fusión para archivos o carpetas concretas de tu proyecto, decirle a Git cómo comparar archivos no textuales, o indicar a Git que filtre ciertos contenidos antes de guardarlos o de extraerlos del repositorio Git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you update a reference, Git doesn’t edit this file but instead writes a new file to `refs/heads`.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T132838Z" changeid="juan">
        <seg>Si actualizas alguna de las referencias, Git no modificará este archivo. Sino que, en cambio, escribirá uno nuevo en `refs/heads`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>avail|nickh,pjhyett,defunkt,tpw
	avail|usinclair,cdickens,ebronte|doc
	avail|schacon|lib
	avail|schacon|tests</seg>
      </tuv>
      <tuv lang="ES">
        <seg>avail|nickh,pjhyett,defunkt,tpw
	avail|usinclair,cdickens,ebronte|doc
	avail|schacon|lib
	avail|schacon|tests</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can set up your new repository by copying your bare repository over:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes colocar tu nuevo repositorio simplemente copiandolo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To really understand the way Git does branching, we need to take a step back and examine how Git stores its data.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para entender realmente cómo ramifica Git, previamente hemos de examinar la forma en que almacena sus datos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git log --no-merges origin/master ^issue54
	commit 738ee872852dfaa9d6634e0dea7a324040193016
	Author: John Smith &lt;jsmith@example.com&gt;
	Date:   Fri May 29 16:01:27 2009 -0700</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git log --no-merges origin/master ^issue54
	commit 738ee872852dfaa9d6634e0dea7a324040193016
	Author: John Smith &lt;jsmith@example.com&gt;
	Date:   Fri May 29 16:01:27 2009 -0700</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you received the patch from someone who generated it with the `git diff` or a Unix `diff` command, you can apply it with the `git apply` command.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si recibes un parche de alguien que lo ha generado con el comando 'git diff' o con un comando 'diff' de Unix, puedes incorporalo con el comando 'git apply'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For example, you can do some simple version control on a file.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por ejemplo, puedes realizar un control simple de versiones sobre un archivo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For instance, if Jessica wants to send John a pull request, and she’s done two commits on the topic branch she just pushed up, she can run this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por ejemplo, si Jessica quiere enviar a John una solicitud de recuperación, y ha realizado dos confirmaciones de cambios sobre la rama puntual que desea enviar, lanzará los siguientes comandos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you just specify the path, Git tries to use hardlinks or directly copy the files it needs.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si escribes simplemente el camino, Git intentará usar enlaces rígidos (hardlinks) o copiar directamente los archivos que necesita.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You use `git format-patch` to generate the mbox-formatted files that you can e-mail to the list — it turns each commit into an e-mail message with the first line of the commit message as the subject and the rest of the message plus the patch that the commit introduces as the body.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Utilizarás el comando `git format-patch` para generar archivos formateados para poder ser enviados por correo electrónico. Este comando convierte cada confirmación de cambios (commit) en un mensaje de correo; con la primera línea del mensaje de confirmación puesto como asunto, y el resto del mensaje mas el parche como cuerpo. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git normally creates a tree by taking the state of your staging area or index and writing a tree object from it.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T144148Z" changeid="juan">
        <seg>Habitualmente Git suele crear un árbol a partir del estado de tu área de preparación (staging area) o índice, escribiendo un objeto árbol con él.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Notice that you have to tell the command where to find your Git repositories with the `GITWEB_PROJECTROOT` variable.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Fijate que es necesario indicar la ubicación donde se encuentran los repositorios Git, utilizando la variable 'GITWEB_PROJECTROOT'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To enforce this, you’ll write those rules to a file named `acl` that lives in your bare Git repository on the server.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para implementar esto, has de escribir esas reglas de acceso en un archivo denominado 'acl' ubicado en tu repositorio git básico en el servidor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ vim index.html
	$ git commit -a -m 'added a new footer [issue 53]'</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ vim index.html
	$ git commit -a -m 'added a new footer [issue 53]'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git automatically expands the `serverfix` branchname out to `refs/heads/serverfix:refs/heads/serverfix`, which means, “Take my serverfix local branch and push it to update the remote’s serverfix branch.” We’ll go over the `refs/heads/` part in detail in Chapter 9, but you can generally leave it off.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Git expande automáticamente el nombre de rama 'serverfix' a 'refs/heads/serverfix:refs/heads/serverfix', que significa: &quot;coge mi rama local 'serverfix' y actualiza con ella la rama 'serverfix' del remoto&quot;. Volveremos más tarde sobre el tema de 'refs/heads/', viendolo en detalle en el capítulo 9; aunque puedes ignorarlo por ahora.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>These features help encourage developers to create and use branches often.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Animando así a los desarrolladores a utilizar ramificaciones frecuentemente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>There is another history-rewriting option that you can use if you need to rewrite a larger number of commits in some scriptable way — for instance, changing your e-mail address globally or removing a file from every commit.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T190548Z" changeid="juan">
        <seg>Existe una opción de reescritura del historial que se puede utilizar si se necesita reescribir un gran número de confirmaciones de cambio de forma mas o menos automatizada. Por ejemplo, para cambiar una dirección de correo electrónico globalmente, o para quitar un archivo de todas y cada una de las confirmaciones de cambios en una determinada rama.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Jessica’s history after merging John’s changes.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El historial de Jessica tras fusionar los cambios de John.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>No commit was completed in that instance.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y la confirmación no se llevará a cabo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>We assume that if you have a server with which to do this, you already have an SSH server installed, and that’s how you’re accessing the server.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Suponiendo que ya tengas el servidor, que el servicio SSH esté instalado y que sea esa la vía de acceso que tú estés utilizando para acceder a él.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>=&gt; GET objects/08/5bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
	(179 bytes of data)</seg>
      </tuv>
      <tuv lang="ES" changedate="20110817T223122Z" changeid="juan">
        <seg>=&gt; GET objects/08/5bb3bcb608e1e8451d4b2432f8ecbe6306e7e7
	(179 bytes of data)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Or, if you want to also switch to it immediately, you can use the `checkout -b` option:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>O, si deseas crearla y saltar inmediatamente a ella, puedes también utilizar la opción '-b' del comando 'checkout':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It often happens that while working on one project, you need to use another project from within it.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T170047Z" changeid="juan">
        <seg>Suele ser frecuente encontrarse con la necesidad de utilizar otro proyecto desde dentro del que se está trabajando.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you place your data on a hosted server, it’s easy to set up and maintain; however, you have to be able to keep your code on someone else’s servers, and some organizations don’t allow that.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si ubicas tus datos en un servidor albergado, será sencillo configurarlo y mantenerlo. Pero tienes que estar dispuesto a mantener tu código en servidores de terceros, cosa que no suele estar permitido en algunas organizaciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git object data for multiple commits.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Datos en el repositorio tras una serie de confirmaciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You must run two commands: `git submodule init` to initialize your local configuration file, and `git submodule update` to fetch all the data from that project and check out the appropriate commit listed in your superproject:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T105816Z" changeid="juan">
        <seg>Son necesarios otros dos comandos: `git submodule init` para inicializar el archivo de configuración local, y `git submodule update` para recuperar (fetch) todos los datos del proyecto y extraer (checkout) la confirmación de cambios adecuada desde el proyecto padre:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>#### Applying a Patch with apply ####</seg>
      </tuv>
      <tuv lang="ES">
        <seg>#### Incorporando un parche con apply ####</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Notice that the `lib` subdirectory isn’t a blob but a pointer to another tree:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T144055Z" changeid="juan">
        <seg>Fíjate en que la carpeta `lib` no es un objeto binario, sino un apuntador a otro objeto tipo árbol.  </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This means that if two developers clone from the hub and both make changes, the first developer to push their changes back up can do so with no problems.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto significa que, si dos desarrolladores clonan desde el punto central, y ambos hacen cambios; tan solo el primero de ellos en enviar sus cambios de vuelta lo podrá hacer limpiamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git cat-file -t d8329fc1cc938780ffdd9f94e0d364e0ea74f579
	tree</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T180317Z" changeid="juan">
        <seg>$ git cat-file -t d8329fc1cc938780ffdd9f94e0d364e0ea74f579
	tree</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git also provides a couple of tools to help you debug issues in your projects.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T164655Z" changeid="juan">
        <seg>Git dispone también de un par de herramientas muy útiles para tareas de depuración en los proyectos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now you get the call that there is an issue with the web site, and you need to fix it immediately.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Entonces, recibes una llamada avisandote de otro problema urgente en el sitio web. Problema que has de resolver inmediatamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Changing the Last Commit ###</seg>
      </tuv>
      <tuv lang="ES" changedate="20120728T075932Z" changeid="juan">
        <seg>### Modificar la última confirmación de cambios ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>John tries to push his change up, too:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>John intenta enviar también sus cambios:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Let’s go back to the objects database for your test Git repository.</seg>
      </tuv>
      <tuv lang="ES" changedate="20110810T225827Z" changeid="juan">
        <seg>Volviendo a los objetos en la base de datos de tu repositorio Git de pruebas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>def get_acl_access_data(acl_file)
	  # read in ACL data
	  acl_file = File.read(acl_file).split(&quot;\n&quot;).reject { |line| line == '' }
	  access = {}
	  acl_file.each do |line|
	    avail, users, path = line.split('|')
	    next unless avail == 'avail'
	    users.split(',').each do |user|
	      access[user] ||= []
	      access[user] &lt;&lt; path
	    end
	  end
	  access
	end</seg>
      </tuv>
      <tuv lang="ES">
        <seg>def get_acl_access_data(acl_file)
	  # read in ACL data
	  acl_file = File.read(acl_file).split(&quot;\n&quot;).reject { |line| line == '' }
	  access = {}
	  acl_file.each do |line|
	    avail, users, path = line.split('|')
	    next unless avail == 'avail'
	    users.split(',').each do |user|
	      access[user] ||= []
	      access[user] &lt;&lt; path
	    end
	  end
	  access
	end</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can do things like check for code style (run lint or something equivalent), check for trailing whitespace (the default hook does exactly that), or check for appropriate documentation on new methods.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puede ser util para realizar tareas tales como revisar el estilo del código (lanzando 'lint' o algo equivalente), revisar los espacios en blanco de relleno (el script de ejemplo hace exactamente eso), o revisar si todos los nuevos métodos llevan la adecuada documentación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To do so, you use `filter-branch`, which you used in Chapter 6:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T110437Z" changeid="juan">
        <seg>Y, para ello, puedes emplear el comando  `filter-branch` que se vió en el capítulo 6.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>These filters can be set to do all sorts of fun things.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Estos filtros pueden utilizarse para realizar todo tipo de acciones útiles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can get very specific about what you want colored and how; but to turn on all the default terminal coloring, set `color.ui` to true:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes ajustar con precisión cada una de las partes a colorear; pero si deseas activar de un golpe todos los colores por defecto, no tienes más que poner a &quot;true&quot; el parámetro 'color.ui'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Adding another server as a remote.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Añadiendo otro servidor como remoto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The Git project has well-formatted commit messages — I encourage you to run `git log --no-merges` there to see what a nicely formatted project-commit history looks like.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El proyecto Git tiene los mensajes adecuadamente formateados. Te animo a lanzar el comando 'git log --no-merges' en dicho proyecto, para que veas la pinta que tiene un historial de proyecto limpio y claro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now your project is hosted on GitHub, and you can give the URL to anyone you want to share your project with.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Así, tu proyecto estará alojado en GitHub; y podrás dar su URL a cualquiera con quien desees compartirlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is interesting, because now your testing branch has moved forward, but your master branch still points to the commit you were on when you ran `git checkout` to switch branches.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Observamos algo interesante: la rama 'testing' avanza, mientras que la rama 'master' permanece en la confirmación donde estaba cuando lanzaste el comando 'git checkout' para saltar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you try to check out that object again at some point, you’ll always get the data of the first object.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T185442Z" changeid="juan">
        <seg>Al intentar recuperar (check-out) el objeto más tarde, siempre se obtendrán los datos del primer objeto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is helpful if a branch in your project has diverged or is specialized, but you want to be able to merge changes back in from it, and you want to ignore certain files.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puede ser interesante si una rama de tu proyecto es divergente o esta especializada, pero deseas seguir siendo capaz de fusionar cambios de vuelta desde ella, e ignorar ciertos archivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It’s possible to make Git push over HTTP as well, although that technique isn’t as widely used and requires you to set up complex WebDAV requirements.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Es posible hacer que Git envie (push) a través de HTTP. Pero no se suele usar demasiado, ya que requiere lidiar con los complejos requerimientos de WebDAV.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Then, write some new content to the file, and save it again:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T143259Z" changeid="juan">
        <seg>A continuación, escribe algo más de contenido en el archivo y vuelvelo a guardar:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Next, the person who pushed the merged work decides to go back and rebase their work instead; they do a `git push --force` to overwrite the history on the server.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>A continuación, la persona que habia llevado cambios al servidor central decide retroceder y reorganizar su trabajo; haciendo un 'git push --force' para sobreescribir el registro en el servidor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg># John's Machine
	$ git clone john@githost:simplegit.git
	Initialized empty Git repository in /home/john/simplegit/.git/
	...
	$ cd simplegit/
	$ vim lib/simplegit.rb
	$ git commit -am 'removed invalid default value'
	[master 738ee87] removed invalid default value
	 1 files changed, 1 insertions(+), 1 deletions(-)</seg>
      </tuv>
      <tuv lang="ES">
        <seg># John's Machine
	$ git clone john@githost:simplegit.git
	Initialized empty Git repository in /home/john/simplegit/.git/
	...
	$ cd simplegit/
	$ vim lib/simplegit.rb
	$ git commit -am 'removed invalid default value'
	[master 738ee87] removed invalid default value
	 1 files changed, 1 insertions(+), 1 deletions(-)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In this case, you can try to rebase that branch on top of `origin/master`, resolve the conflicts for the maintainer, and then resubmit your changes:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En este caso, puedes intentar reorganizar (rebase) tu parche sobre 'origin/master', arreglar los conflictos y volver a enviar tus cambios:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you want to always fetch the master and experiment branches, add two lines:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110823T115848Z" changeid="juan">
        <seg>Si, por ejemplo, siempre recuperas las ramas 'master' y 'experiment', puedes poner dos lineas:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ cd /path/to/project.git
	$ touch git-daemon-export-ok</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ cd /path/to/project.git
	$ touch git-daemon-export-ok</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In this section, you’ll learn about some of the attributes you can set on your paths in your Git project and see a few examples of using this feature in practice.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En esta sección, aprenderas acerca de algunos atributos que puedes asignar a ciertos caminos (paths) dentro de tu proyecto Git, viendo algunos ejemplos de cómo utilizar sus funcionalidades de manera práctica.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you rebase commits that have already been pushed publicly, and people may have based work on those commits, then you may be in for some frustrating trouble.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si, por el contrario, reorganizas confirmaciones que alguna vez han sido públicas y otra gente ha basado su trabajo  en ellas. Entonces estarás en un aprieto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This section revisits a couple of commands so you can see how you can use them to review exactly what you’ll be introducing if you merge this into your main branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En esta sección revisaremos un par de comandos, que te ayudarán a ver exactamente los cambios que introducirás si fusionas dicha rama puntual con tu rama principal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can easily see what commits modified this file:</seg>
      </tuv>
      <tuv lang="ES" changedate="20110822T110305Z" changeid="juan">
        <seg>Es sencillo revisar cuales son las confirmaciones de cambios donde interviene ese archivo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Changing your last commit is probably the most common rewriting of history that you’ll do.</seg>
      </tuv>
      <tuv lang="ES" changedate="20120805T121644Z" changeid="juan">
        <seg>Modificar la última confirmación de cambios (commit) es probablemente el arreglo realizado con más frecuencia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>remote: Total 15 (delta 5), reused 0 (delta 0)
	Unpacking objects: 100% (15/15), done.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>remote: Total 15 (delta 5), reused 0 (delta 0)
	Unpacking objects: 100% (15/15), done.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This means that if you commit at this point, the `master` branch will be moved forward with your new work.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si hacemos una confirmación de cambios (commit), esa será la rama que avance.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git reflog
	734713b...</seg>
      </tuv>
      <tuv lang="ES" changedate="20120701T102019Z" changeid="juan">
        <seg>$ git reflog
	734713b...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is called a _refspec_.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto es lo que se denomina un _refspec_.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It’s also a good idea to use the imperative present tense in these messages.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Es también buena idea redactar los mensajes utilizando el imperativo, en tiempo presente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you run `git status` right after you add the submodule, you see two things:</seg>
      </tuv>
      <tuv lang="ES" changedate="20120830T170624Z" changeid="juan">
        <seg>Si se lanza `git status` nada mas añadir el submódulo, se aprecian dos cosas:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Importing from Subversion ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Importación desde Subversion ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ irb
	&gt;&gt; content = &quot;what is up, doc?&quot;
	=&gt; &quot;what is up, doc?&quot;</seg>
      </tuv>
      <tuv lang="ES" changedate="20110808T180945Z" changeid="juan">
        <seg>$ irb
	&gt;&gt; content = &quot;what is up, doc?&quot;
	=&gt; &quot;what is up, doc?&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This command is sort of a Swiss army knife for inspecting Git objects.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Este comando es algo así como una &quot;navaja suiza&quot; para inspeccionar objetos Git.</seg>
      </tuv>
    </tu>
  </body>
</tmx>
