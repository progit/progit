<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx11.dtd">
<tmx version="1.1">
  <header
    creationtool="OmegaT"
    creationtoolversion="2.0.5_2"
    segtype="sentence"
    o-tmf="OmegaT TMX"
    adminlang="EN-US"
    srclang="EN"
    datatype="plaintext"
  >
  </header>
  <body>
    <tu>
      <tuv lang="EN">
        <seg># Distributed Git #</seg>
      </tuv>
      <tuv lang="ES">
        <seg># Git en entornos distribuidos #</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now that you have a remote Git repository set up as a point for all the developers to share their code, and you’re familiar with basic Git commands in a local workflow, you’ll look at how to utilize some of the distributed workflows that Git affords you.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Ahora que ya tienes un repositorio Git, configurado como punto de trabajo para compartir código entre desarrolladores. Y ahora que ya conoces los comandos básicos de Git para flujos de trabajo locales. Puedes hechar un vistazo a algunos de los flujos de trabajo distribuidos que Git permite.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In this chapter, you’ll see how to work with Git in a distributed environment as a contributor and an integrator.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En este capítulo, verás cómo trabajar con Git en un entorno distribuido, bien como colaborador o bien como integrador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>That is, you’ll learn how to contribute code successfully to a project and make it as easy on you and the project maintainer as possible, and also how to maintain a project successfully with a number of developers contributing.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Es decir, aprenderás cómo contribuir adecuadamente a un proyecto; de la forma más efectiva posible, tanto para tí, como para quien gestione el proyecto. Y aprenderás también a gestionar proyectos en los que colaboren multiples desarrolladores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## Distributed Workflows ##</seg>
      </tuv>
      <tuv lang="ES">
        <seg>## Flujos de trabajo distribuidos ##</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Unlike Centralized Version Control Systems (CVCSs), the distributed nature of Git allows you to be far more flexible in how developers collaborate on projects.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Al contrario de otros Sistemas Centralizados de Control de Versiones, (CVCSs, Centralized Version Control Systems), la naturaleza distribuida de Git permite mucha más flexibilidad en la manera de colaborar en proyectos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In centralized systems, every developer is a node working more or less equally on a central hub.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En los sistemas centralizados, cada desarrollador es un nodo de trabajo; trabajando todos ellos, en pie de igualdad, sobre un mismo repositorio central.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In Git, however, every developer is potentially both a node and a hub — that is, every developer can both contribute code to other repositories and maintain a public repository on which others can base their work and which they can contribute to.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En Git, en cambio, cada desarrollador es potencialmente tanto un nodo como un repositorio --es decir, cada desarrollador puede tanto contribuir a otros repositorios, como servir de repositorio público sobre el que otros desarrolladores pueden basar su trabajo y contribuir a él--.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This opens a vast range of workflow possibilities for your project and/or your team, so I’ll cover a few common paradigms that take advantage of this flexibility.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto abre un enorme rango de posibles formas de trabajo en tu proyecto y/o en tu equipo. Aquí vamos a revisar algunos de los paradigmas más comunes diseñados para sacar ventaja a esta gran flexibilidad.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>I’ll go over the strengths and possible weaknesses of each design; you can choose a single one to use, or you can mix and match features from each.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Vamos a repasar las fortalezas y posibles debilidades de cada paradigma. En tu trabajo, podrás elegir solo uno concreto, o podrás mezclar escogiendo funcionalidades concretas de cada uno.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Centralized Workflow ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Flujo de trabajo centralizado ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In centralized systems, there is generally a single collaboration model—the centralized workflow.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En los sistemas centralizados, tenemos una única forma de trabajar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>One central hub, or repository, can accept code, and everyone synchronizes their work to it.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Un repositorio o punto central guarda el código fuente; y todo el mundo sincroniza su trabajo con él.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>A number of developers are nodes — consumers of that hub — and synchronize to that one place (see Figure 5-1).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Unos cuantos desarrolladores son nodos de trabajo --consumidores de dicho repositorio-- y se sincronizan con dicho punto central. (ver Figura 5-1).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0501.png 
Figure 5-1.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0501.png 
Figura 5-1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Centralized workflow.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Flujo de trabajo centralizado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This means that if two developers clone from the hub and both make changes, the first developer to push their changes back up can do so with no problems.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto significa que, si dos desarrolladores clonan desde el punto central, y ambos hacen cambios; tan solo el primero de ellos en enviar sus cambios de vuelta lo podrá hacer limpiamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The second developer must merge in the first one’s work before pushing changes up, so as not to overwrite the first developer’s changes.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El segundo desarrollador deberá fusionar previamente su trabajo con el del primero, antes de enviarlo, para evitar el sobreescribir los cambios del primero.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This concept is true in Git as it is in Subversion (or any CVCS), and this model works perfectly in Git.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Este concepto es también válido en Git, tanto como en Subversion (o cualquier otro CVCS), y puede ser perfectamente utilizado en Git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you have a small team or are already comfortable with a centralized workflow in your company or team, you can easily continue using that workflow with Git.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si tienes un equipo pequeño o te sientes confortable con un flujo de trabajo centralizado, puedes continuar usando esa forma de trabajo con Git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Simply set up a single repository, and give everyone on your team push access; Git won’t let users overwrite each other.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Solo necesitas disponer un repositorio único, y dar acceso en envio (push) a todo tu equipo. Git se encargará de evitar el que se sobreescriban unos a otros.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If one developer clones, makes changes, and then tries to push their changes while another developer has pushed in the meantime, the server will reject that developer’s changes.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si uno de los desarrolladores clona, hace cambios y luego intenta enviarlos; y otro desarrollador ha enviado otros cambios durante ese tiempo; el servidor rechazará los cambios del segundo desarrollador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>They will be told that they’re trying to push non-fast-forward changes and that they won’t be able to do so until they fetch and merge.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El sistema le avisará de que está intentando enviar (push) cambios no directos (non-fast-forward changes), y de que no podrá hacerlo hasta que recupere (fetch) y fusione (merge) los cambios preexistentes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This workflow is attractive to a lot of people because it’s a paradigm that many are familiar and comfortable with.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esta forma de trabajar es atractiva para mucha gente, por ser el paradigma con el que están familiarizados y se sienten confortables.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Integration-Manager Workflow ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Flujo de trabajo del Gestor-de-Integraciones ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Because Git allows you to have multiple remote repositories, it’s possible to have a workflow where each developer has write access to their own public repository and read access to everyone else’s.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Al permitir multiples repositorios remotos, en Git es posible tener un flujo de trabajo donde cada desarrollador tenga acceso de escritura a su propio repositorio público y acceso de lectura a los repositorios de todos los demás.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This scenario often includes a canonical repository that represents the &quot;official&quot; project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Habitualmente, este escenario suele incluir un repositorio canónico, representante &quot;oficial&quot; del proyecto. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To contribute to that project, you create your own public clone of the project and push your changes to it.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para contribuir en este tipo de proyecto, crearás tu propio clón público del mismo y enviarás (push) tus cambios a este.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Then, you can send a request to the maintainer of the main project to pull in your changes.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Después, enviarás una petición a la persona gestora del proyecto principal, para que recupere y consolide (pull) en él tus cambios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>They can add your repository as a remote, test your changes locally, merge them into their branch, and push back to their repository.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Ella podrá añadir tu repositorio como un remoto, chequear tus cambios localmente, fusionarlos (merge) con su rama y enviarlos (push) de vuelta a su repositorio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The process works as follow (see Figure 5-2):</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El proceso funciona de la siguiente manera (ver Figura 5-2):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>1.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The project maintainer pushes to their public repository.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La persona gestora del proyecto envia (push) a su repositorio público (repositorio principal).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>2.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>A contributor clones that repository and makes changes.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Una persona que desea contribuir, clona dicho repositorio y hace algunos cambios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>3.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The contributor pushes to their own public copy.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La persona colaboradora envia (push) a su propia copia pública.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>4.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>4.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The contributor sends the maintainer an e-mail asking them to pull changes.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esta persona colaboradora envia a la gestora un correo-e solicitándole recupere e integre los cambios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>5.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>5.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The maintainer adds the contributor’s repo as a remote and merges locally.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La gestora añade como remoto el repositorio de la colaboradora y fusiona (merge) los cambios localmente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>6.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>6.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The maintainer pushes merged changes to the main repository.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La gestora envia (push) los cambios fusionados al repositorio principal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0502.png 
Figure 5-2.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0502.png 
Figura 5-2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Integration-manager workflow.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Flujo de trabajo Gestor-de-Integración.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is a very common workflow with sites like GitHub, where it’s easy to fork a project and push your changes into your fork for everyone to see.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esta es una forma de trabajo muy común en sitios tales como GitHub, donde es sencillo bifurcar (fork) un proyecto y enviar tus cambios a tu copia, donde cualquiera puede verlos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>One of the main advantages of this approach is that you can continue to work, and the maintainer of the main repository can pull in your changes at any time.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La principal ventaja de esta forma de trabajar es que puedes continuar trabajando, y la persona gestora del repositorio principal podrá recuperar (pull) tus cambios en cualquier momento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Contributors don’t have to wait for the project to incorporate their changes — each party can work at their own pace.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Las personas colaboradoras no tienen por qué esperar a que sus cambios sean incorporados al proyecto, --cada cual puede trabajar a su propio ritmo--.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Dictator and Lieutenants Workflow ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Flujo de trabajo con Dictador y Tenientes ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is a variant of a multiple-repository workflow.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Es una variante del flujo de trabajo con multiples repositorios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It’s generally used by huge projects with hundreds of collaborators; one famous example is the Linux kernel.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Se utiliza generalmente en proyectos muy grandes, con cientos de colaboradores. Un ejemplo muy conocido es el del kernel de Linux.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Various integration managers are in charge of certain parts of the repository; they’re called lieutenants.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Unos gestores de integración se encargan de partes concretas del repositorio; y se denominan tenientes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>All the lieutenants have one integration manager known as the benevolent dictator.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Todos los tenientes rinden cuentas a un gestor de integración; conocido como el dictador benevolente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The benevolent dictator’s repository serves as the reference repository from which all the collaborators need to pull.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El repositorio del dictador benevolente es el repositorio de referencia, del que recuperan (pull) todos los colaboradores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The process works like this (see Figure 5-3):</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El proceso funciona como sigue (ver Figura 5-3):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Regular developers work on their topic branch and rebase their work on top of master.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Los desarrolladores habituales trabajan cada uno en su rama puntual y reorganizan (rebase) su trabajo sobre la rama master.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The master branch is that of the dictator.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La rama master es la del dictador benevolente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Lieutenants merge the developers’ topic branches into their master branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Los tenienentes fusionan (merge) las ramas puntuales de los desarrolladores sobre su propia rama master.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The dictator merges the lieutenants’ master branches into the dictator’s master branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El dictador fusiona las ramas master de los tenientes en su propia rama master.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The dictator pushes their master to the reference repository so the other developers can rebase on it.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El dictador envia (push) su rama master al repositorio de referencia, para permitir que los desarrolladores reorganicen (rebase) desde ella.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0503.png  
Figure 5-3.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0503.png  
Figura 5-3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Benevolent dictator workflow.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Fujo de trabajo del dictador benevolente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This kind of workflow isn’t common but can be useful in very big projects or in highly hierarchical environments, because as it allows the project leader (the dictator) to delegate much of the work and collect large subsets of code at multiple points before integrating them.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esta manera de trabajar no es muy habitual, pero es muy util en proyectos muy grandes o en organizaciónes fuertemente jerarquizadas. Permite al lider o a la lider del proyecto (el/la dictador/a) delegar gran parte del trabajo; recolectando el fruto de multiples puntos de trabajo antes de integrarlo en el proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>These are some commonly used workflows that are possible with a distributed system like Git, but you can see that many variations are possible to suit your particular real-world workflow.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Hemos visto algunos de los flujos de trabajo mas comunes permitidos por un sistema distribuido como Git. Pero seguro que habrás comenzado a vislumbrar multiples variaciones que puedan encajar con tu particular forma de trabajar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now that you can (I hope) determine which workflow combination may work for you, I’ll cover some more specific examples of how to accomplish the main roles that make up the different flows.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Espero que a estas alturas estés en condiciones de reconocer la combinación de flujos de trabajo que puede serte util. Vamos a ver algunos ejemplos más específicos, ilustrativos de los roles principales que se presentan en las distintas maneras de trabajar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## Contributing to a Project ##</seg>
      </tuv>
      <tuv lang="ES">
        <seg>## Contribuyendo a un proyecto ##</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You know what the different workflows are, and you should have a pretty good grasp of fundamental Git usage.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En estos momentos conoces las diferentes formas de trabajar, y tienes ya un generoso conocimiento de los fundamentos de Git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In this section, you’ll learn about a few common patterns for contributing to a project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En esta sección, aprenderás acerca de las formas más habituales de contribuir a un proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The main difficulty with describing this process is that there are a huge number of variations on how it’s done.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El mayor problema al intentar describir este proceso es el gran número de variaciones que se pueden presentar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Because Git is very flexible, people can and do work together many ways, and it’s problematic to describe how you should contribute to a project — every project is a bit different.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por la gran flexibilidad de Git, la gente lo suele utilizar de multiples maneras; siendo problemático intentar describir la forma en que deberías contribuir a un proyecto --cada proyecto tiene sus peculiaridades--.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Some of the variables involved are active contributor size, chosen workflow, your commit access, and possibly the external contribution method.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Algunas de las variables a considerar son: la cantidad de colaboradores activos, la forma de trabajo escogida, el nivel de acceso que tengas, y, posiblemente, el sistema de colaboración externa implantado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The first variable is active contributor size.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La primera variable es el número de colaboradores activos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>How many users are actively contributing code to this project, and how often?</seg>
      </tuv>
      <tuv lang="ES">
        <seg>¿Cuántos usuarios están enviando activamente código a este proyecto?, y ¿con qué frecuencia?.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In many instances, you’ll have two or three developers with a few commits a day, or possibly less for somewhat dormant projects.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En muchas ocasiones, tendrás dos o tres desarrolladores, con tan solo unas pocas confirmaciones de cambios (commits) diarias; e incluso menos en algunos proyectos durmientes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For really large companies or projects, the number of developers could be in the thousands, with dozens or even hundreds of patches coming in each day.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En proyectos o empresas verdaderamente grandes puedes tener cientos de desarrolladores, con docenas o incluso cientos de parches llegando cada día.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is important because with more and more developers, you run into more issues with making sure your code applies cleanly or can be easily merged.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto es importante, ya que cuantos más desarrolladores haya, mayores serán los problemas para asegurarte de que tu código se integre limpiamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Changes you submit may be rendered obsolete or severely broken by work that is merged in while you were working or while your changes were waiting to be approved or applied.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Los cambios que envies pueden quedar obsoletos o severamente afectados por otros trabajos que han sido integrados previamente mientras tú estabas trabajando o mientras tus cambios aguardaban a ser aprobados para su integración.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>How can you keep your code consistently up to date and your patches valid?</seg>
      </tuv>
      <tuv lang="ES">
        <seg>¿Cómo puedes mantener consistentemente actualizado tu código, y asegurarte así de que tus parches son válidos? </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The next variable is the workflow in use for the project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La segunda variable es la forma de trabajo que se utilice para el proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Is it centralized, with each developer having equal write access to the main codeline?</seg>
      </tuv>
      <tuv lang="ES">
        <seg>¿Es centralizado, con iguales derechos de acceso en escritura para cada desarrollador?.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Does the project have a maintainer or integration manager who checks all the patches?</seg>
      </tuv>
      <tuv lang="ES">
        <seg>¿Tiene un gestor de integraciones que comprueba todos los parches?.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Are all the patches peer-reviewed and approved?</seg>
      </tuv>
      <tuv lang="ES">
        <seg>¿Se revisan y aprueban los parches entre los propios desarrolladores?. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Are you involved in that process?</seg>
      </tuv>
      <tuv lang="ES">
        <seg>¿Participas en ese proceso de aprobación?.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Is a lieutenant system in place, and do you have to submit your work to them first?</seg>
      </tuv>
      <tuv lang="ES">
        <seg>¿Existe un sistema de tenientes, a los que has de enviar tu trabajo en primer lugar?.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The next issue is your commit access.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La tercera variable es el nivel de acceso que tengas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The workflow required in order to contribute to a project is much different if you have write access to the project than if you don’t.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La forma de trabajar y de contribuir a un proyecto es totalmente diferente dependiendo de si tienes o no acceso de escritura al proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you don’t have write access, how does the project prefer to accept contributed work?</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si no tienes acceso de escritura, ¿cuál es el sistema preferido del proyecto para aceptar contribuciones?.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Does it even have a policy?</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Es más, ¿tiene un sistema para ello?.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>How much work are you contributing at a time?</seg>
      </tuv>
      <tuv lang="ES">
        <seg>¿Con cuánto trabajo contribuyes?.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>How often do you contribute?</seg>
      </tuv>
      <tuv lang="ES">
        <seg>¿Con qué frecuencia?.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>All these questions can affect how you contribute effectively to a project and what workflows are preferred or available to you.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Todas estas preguntas afectan a la forma efectiva de contribuir a un proyecto, y a la forma de trabajo que prefieras o esté disponible para tí.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>I’ll cover aspects of each of these in a series of use cases, moving from simple to more complex; you should be able to construct the specific workflows you need in practice from these examples.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Vamos a cubrir ciertos aspectos de todo esto, en una serie de casos de uso; desde los más sencillos hasta los más complejos. A partir de dichos ejemplos, tendrías que ser capaz de construir la forma de trabajo específica que necesites para cada caso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Commit Guidelines ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Reglas para las confirmaciones de cambios (commits) ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Before you start looking at the specific use cases, here’s a quick note about commit messages.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Antes de comenzar a revisar casos de uso específicos, vamos a dar una pincelada sobre los mensajes en las confirmaciones de cambios (commits).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Having a good guideline for creating commits and sticking to it makes working with Git and collaborating with others a lot easier.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Disponer unas reglas claras para crear confirmaciones de cambios, y seguirlas fielmente, facilta enormemente tanto el trabajo con Git y como la colaboración con otras personas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The Git project provides a document that lays out a number of good tips for creating commits from which to submit patches — you can read it in the Git source code in the `Documentation/SubmittingPatches` file.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El propio proyecto Git suministra un documento con un gran número de buenas sugerencias sobre la creación de confirmaciones de cambio destinadas a enviar parches --puedes leerlo en el código fuente de Git, en el archivo 'Documentation/SubmittingPatches'--.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>First, you don’t want to submit any whitespace errors.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En primer lugar, no querrás enviar ningún error de espaciado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git provides an easy way to check for this — before you commit, run `git diff --check`, which identifies possible whitespace errors and lists them for you.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Git nos permite buscarlos facilmente. Previamente a realizar una confirmación de cambios, lanzar el comando 'git diff --check' para identificar posibles errores de espaciado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Here is an example, where I’ve replaced a red terminal color with `X`s:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Aquí van algunos ejemplos, en los que hemos sustituido las marcas rojas por 'X's:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git diff --check
	lib/simplegit.rb:5: trailing whitespace.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git diff --check
	lib/simplegit.rb:5: trailing whitespace.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>+    @git_dir = File.expand_path(git_dir)XX
	lib/simplegit.rb:7: trailing whitespace.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>+    @git_dir = File.expand_path(git_dir)XX
	lib/simplegit.rb:7: trailing whitespace.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>+ XXXXXXXXXXX
	lib/simplegit.rb:26: trailing whitespace.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>+ XXXXXXXXXXX
	lib/simplegit.rb:26: trailing whitespace.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>+    def command(git_cmd)XXXX</seg>
      </tuv>
      <tuv lang="ES">
        <seg>+    def command(git_cmd)XXXX</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you run that command before committing, you can tell if you’re about to commit whitespace issues that may annoy other developers.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Lanzando este comando antes de confirmar cambios, puedes estar seguro de si vas o no a incluir problemas de espaciado que puedan molestar a otros desarrolladores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Next, try to make each commit a logically separate changeset.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En segundo lugar, intentar hacer de cada confirmación (commit) un grupo lógico e independiente de cambios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you can, try to make your changes digestible — don’t code for a whole weekend on five different issues and then submit them all as one massive commit on Monday.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Siempre que te sea posible, intenta hacer digeribles tus cambios --no estés trabajando todo el fin de semana, sobre cuatro o cinco asuntos diferentes, y luego confirmes todo junto el lunes--.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Even if you don’t commit during the weekend, use the staging area on Monday to split your work into at least one commit per issue, with a useful message per commit.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Aunque no hagas ninguna confirmación durante el fin de semana, el lunes puedes utilizar el área de preparación (staging area) para ir dividiendo tu trabajo y hacer una confirmación de cambios (commit) separada para cada asunto; con un mensaje adecuado para cada una de ellas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If some of the changes modify the same file, try to use `git add --patch` to partially stage files (covered in detail in Chapter 6).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si algunos de los cambios modifican un mismo archivo, utiliza el comando 'git add --patch' para almacenar parcialmente los archivos (tal y como se verá detalladamente en el Capítulo 6).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The project snapshot at the tip of the branch is identical whether you do one commit or five, as long as all the changes are added at some point, so try to make things easier on your fellow developers when they have to review your changes.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El estado del proyecto al final de cada rama será idéntico si haces una sola confirmación o si haces cinco, en tanto en cuanto todos los cambios estén confirmados en un determinado momento. Por consiguiente, intenta facilitar las cosas a tus compañeros y compañeras desarroladores cuando vayan a revisar tus cambios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This approach also makes it easier to pull out or revert one of the changesets if you need to later.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Además, esta manera de trabajar facilitará la integración o el descarte individual de alguno de los cambios, en caso de ser necesario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Chapter 6 describes a number of useful Git tricks for rewriting history and interactively staging files — use these tools to help craft a clean and understandable history.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El Capítulo 6 contiene un gran número de trucos para reescribir el historial e ir preparando archivos interactivamente --utilizalos para ayudarte a crear un claro y comprensible historial--.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The last thing to keep in mind is the commit message.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y, por último, prestar atención al mensaje de confirmación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Getting in the habit of creating quality commit messages makes using and collaborating with Git a lot easier.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si nos acostumbramos a poner siempre mensajes de calidad en las confirmaciones de cambios, facilitaremos en gran medida el trabajo y la colaboración con Git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>As a general rule, your messages should start with a single line that’s no more than about 50 characters and that describes the changeset concisely, followed by a blank line, followed by a more detailed explanation.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Como regla general, tus mensajes han de comenzar con una ĺínea, de no más de 50 caracteres, donde se resuma el grupo de cambios; seguida de una línea en blanco; y seguida de una detallada explicación en las líneas siguientes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The Git project requires that the more detailed explanation include your motivation for the change and contrast its implementation with previous behavior — this is a good guideline to follow.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El proyecto Git obliga a incluir una explicación detallada; incluyendo tus motivaciones para los cambios realizados; y comentarios sobre las diferencias, tras su implementación, respecto del comportamiento anterior del programa. Esta recomendación es una buena regla a seguir.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It’s also a good idea to use the imperative present tense in these messages.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Es también buena idea redactar los mensajes utilizando el imperativo, en tiempo presente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In other words, use commands.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Es decir, dá órdenes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Instead of &quot;I added tests for&quot; or &quot;Adding tests for,&quot; use &quot;Add tests for.&quot;
Here is a template originally written by Tim Pope at tpope.net:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por ejemplo, en vez de escribir &quot;He añadido comprobaciones para&quot; o &quot;Añadiendo comprobaciones para&quot;, utilizar la frase &quot;Añadir comprobaciones para&quot;. Como plantilla de referencia, podemos utilizar la que escribió Tim Pope en tpope.net:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Short (50 chars or less) summary of changes</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Un resumen de cambios, corto (50 caracteres o menos).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>More detailed explanatory text, if necessary.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Seguido de un texto más detallado, si es necesario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Wrap it to about 72
	characters or so.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Limitando las líneas a 72 caracteres mas o menos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In some contexts, the first line is treated as the
	subject of an email and the rest of the text as the body.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En algunos contextos, la primera línea se tratará como si fuera el asundo de un correo electrónico y el resto del texto como si fuera el cuerpo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The blank
	line separating the summary from the body is critical (unless you omit
	the body entirely); tools like rebase can get confused if you run the
	two together.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La línea en blanco separando el resumen del cuerpo es crítica (a no ser que se omita totalmente el cuerpo); algunas herramientas como 'rebase' pueden tener problemas si no los separas adecuadamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Further paragraphs come after blank lines.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Los siguientes párrafos van tras la línea en blanco.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>- Bullet points are okay, too</seg>
      </tuv>
      <tuv lang="ES">
        <seg>- Los puntos con bolo también están permitidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>- Typically a hyphen or asterisk is used for the bullet, preceded by a
	   single space, with blank lines in between, but conventions vary here</seg>
      </tuv>
      <tuv lang="ES">
        <seg>- Habitualmente se emplea un guión o un asterisco como bolo, seguido de un espacio, con líneas en blanco intermedias; pero las convenciones pueden variar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If all your commit messages look like this, things will be a lot easier for you and the developers you work with.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si todas tus confirmaciones de cambio (commit) llevan mensajes de este estilo, facilitarás las cosas tanto para tí como para las personas que trabajen contigo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The Git project has well-formatted commit messages — I encourage you to run `git log --no-merges` there to see what a nicely formatted project-commit history looks like.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El proyecto Git tiene los mensajes adecuadamente formateados. Te animo a lanzar el comando 'git log --no-merges' en dicho proyecto, para que veas la pinta que tiene un historial de proyecto limpio y claro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In the following examples, and throughout most of this book, for the sake of brevity I don’t format messages nicely like this; instead, I use the `-m` option to `git commit`.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En los ejemplos siguientes, y a lo largo de todo este libro, por razones de brevedad no formatearé correctamente los mensajes; sino que emplearé la opción '-m' en los comandos 'git commit'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Do as I say, not as I do.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Observa mis palabras, no mis hechos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Private Small Team ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Pequeño Grupo Privado ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The simplest setup you’re likely to encounter is a private project with one or two other developers.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Lo más simple que te puedes encontrar es un proyecto privado con uno o dos desarrolladores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>By private, I mean closed source — not read-accessible to the outside world.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por privado, me refiero a código propietario --no disponible para ser leido por el mundo exterior--.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You and the other developers all have push access to the repository.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tanto tu como el resto del equipo teneis acceso de envio (push) al repositorio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In this environment, you can follow a workflow similar to what you might do when using Subversion or another centralized system.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En un entorno como este, puedes seguir un flujo de trabajo similar al que adoptarías usando Subversion o algún otro sistema centralizado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You still get the advantages of things like offline committing and vastly simpler branching and merging, but the workflow can be very similar; the main difference is that merges happen client-side rather than on the server at commit time.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Sigues disfrutando de ventajas tales como las confirmaciones offline y la mayor simplicidad en las ramificaciones/fusiones. Pero, en el fondo, la forma de trabajar será bastante similar; la mayor diferencia radica en que las fusiones (merge) se hacen en el lado cliente en lugar de en el servidor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Let’s see what it might look like when two developers start to work together with a shared repository.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Vamos a ver como actuarian dos desarrolladores trabajando conjuntamente en un repositorio compartido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The first developer, John, clones the repository, makes a change, and commits locally.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El primero de ellos, John, clona el repositorio, hace algunos cambios y los confirma localmente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>(I’m replacing the protocol messages with `...` in these examples to shorten them somewhat.)</seg>
      </tuv>
      <tuv lang="ES">
        <seg>(en estos ejemplos estoy sustituyendo los mensajes del protocolo con '...' , para acortarlos)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg># John's Machine
	$ git clone john@githost:simplegit.git
	Initialized empty Git repository in /home/john/simplegit/.git/
	...
	$ cd simplegit/
	$ vim lib/simplegit.rb 
	$ git commit -am 'removed invalid default value'
	[master 738ee87] removed invalid default value
	 1 files changed, 1 insertions(+), 1 deletions(-)</seg>
      </tuv>
      <tuv lang="ES">
        <seg># John's Machine
	$ git clone john@githost:simplegit.git
	Initialized empty Git repository in /home/john/simplegit/.git/
	...
	$ cd simplegit/
	$ vim lib/simplegit.rb 
	$ git commit -am 'removed invalid default value'
	[master 738ee87] removed invalid default value
	 1 files changed, 1 insertions(+), 1 deletions(-)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The second developer, Jessica, does the same thing — clones the repository and commits a change:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La segunda desarrolladora, Jessica, hace lo mismo: clona el repositorio y confirma algunos cambios:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg># Jessica's Machine
	$ git clone jessica@githost:simplegit.git
	Initialized empty Git repository in /home/jessica/simplegit/.git/
	...
	$ cd simplegit/
	$ vim TODO 
	$ git commit -am 'add reset task'
	[master fbff5bc] add reset task
	 1 files changed, 1 insertions(+), 0 deletions(-)</seg>
      </tuv>
      <tuv lang="ES">
        <seg># Jessica's Machine
	$ git clone jessica@githost:simplegit.git
	Initialized empty Git repository in /home/jessica/simplegit/.git/
	...
	$ cd simplegit/
	$ vim TODO 
	$ git commit -am 'add reset task'
	[master fbff5bc] add reset task
	 1 files changed, 1 insertions(+), 0 deletions(-)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now, Jessica pushes her work up to the server:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tras esto, Jessica envia (push) su trabajo al servidor:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg># Jessica's Machine
	$ git push origin master
	...
	To jessica@githost:simplegit.git
	   1edee6b..fbff5bc  master -&gt; master</seg>
      </tuv>
      <tuv lang="ES">
        <seg># Jessica's Machine
	$ git push origin master
	...
	To jessica@githost:simplegit.git
	   1edee6b..fbff5bc  master -&gt; master</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>John tries to push his change up, too:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>John intenta enviar también sus cambios:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg># John's Machine
	$ git push origin master
	To john@githost:simplegit.git
	 !</seg>
      </tuv>
      <tuv lang="ES">
        <seg># John's Machine
	$ git push origin master
	To john@githost:simplegit.git
	 !</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>[rejected]        master -&gt; master (non-fast forward)
	error: failed to push some refs to 'john@githost:simplegit.git'</seg>
      </tuv>
      <tuv lang="ES">
        <seg>[rejected]        master -&gt; master (non-fast forward)
	error: failed to push some refs to 'john@githost:simplegit.git'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>John isn’t allowed to push because Jessica has pushed in the meantime.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>John no puede enviar porque Jessica ha enviado previamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is especially important to understand if you’re used to Subversion, because you’ll notice that the two developers didn’t edit the same file.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Entender bien esto es especialmente importante, sobre todo si estás acostumbrado a utilizar Subversion; porque habrás notado que ambos desarrolladores han editado archivos distintos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Although Subversion automatically does such a merge on the server if different files are edited, in Git you must merge the commits locally.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Mientras que Subversion fusiona automáticamente en el servidor cuando los cambios han sido aplicados sobre archivos distintos, en Git has de fusionar (merge) los cambios localmente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>John has to fetch Jessica’s changes and merge them in before he will be allowed to push:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>John se vé obligado a recuperar (fetch) los cambios de jessica y a fusionarlos (merge) con los suyos, antes de que se le permita enviar (push):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git fetch origin
	...
	From john@githost:simplegit
	 + 049d078...fbff5bc master     -&gt; origin/master</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git fetch origin
	...
	From john@githost:simplegit
	 + 049d078...fbff5bc master     -&gt; origin/master</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>At this point, John’s local repository looks something like Figure 5-4.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En este punto, el repositorio local de John será algo parecido a la Figura 5-4.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0504.png 
Figure 5-4.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0504.png 
Figura 5-4.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>John’s initial repository.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El repositorio inicial de John.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>John has a reference to the changes Jessica pushed up, but he has to merge them into his own work before he is allowed to push:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>John tiene una referencia a los cambios enviados por Jessica, pero ha de fusionarlos en su propio trabajo antes de que se le permita enviar:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git merge origin/master
	Merge made by recursive.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git merge origin/master
	Merge made by recursive.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>TODO |    1 +
	 1 files changed, 1 insertions(+), 0 deletions(-)</seg>
      </tuv>
      <tuv lang="ES">
        <seg>TODO |    1 +
	 1 files changed, 1 insertions(+), 0 deletions(-)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The merge goes smoothly — John’s commit history now looks like Figure 5-5.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si la fusión se realiza sin problemas, el historial de John será algo parecido a la Figura 5-5.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0505.png 
Figure 5-5.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0505.png 
Figura 5-5.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>John’s repository after merging origin/master.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El repositorio de John tras fusionar origin/master.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now, John can test his code to make sure it still works properly, and then he can push his new merged work up to the server:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En este momento, John puede comprobar su código para verificar que sigue funcionando correctamente, y luego puede enviar su trabajo al servidor:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git push origin master
	...
	To john@githost:simplegit.git
	   fbff5bc..72bbc59  master -&gt; master</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git push origin master
	...
	To john@githost:simplegit.git
	   fbff5bc..72bbc59  master -&gt; master</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Finally, John’s commit history looks like Figure 5-6.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Finalmente, el historial de John es algo parecido a la Figura 5-6.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0506.png 
Figure 5-6.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0506.png 
Figura 5-6.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>John’s history after pushing to the origin server.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El historial de John tras enviar al servidor origen.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In the meantime, Jessica has been working on a topic branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Mientras tanto, jessica ha seguido trabajando en una rama puntual (topic branch).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>She’s created a topic branch called `issue54` and done three commits on that branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Ha creado una rama puntual denominada 'issue54' y ha realizado tres confirmaciones de cambios (commit) en dicha rama.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>She hasn’t fetched John’s changes yet, so her commit history looks like Figure 5-7.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Como todavia no ha recuperado los cambios de John, su historial es como se muestra en la Figura 5-7.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0507.png 
Figure 5-7.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0507.png 
Figura 5-7.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Jessica’s initial commit history.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Historial inicial de Jessica.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Jessica wants to sync up with John, so she fetches:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Jessica desea sincronizarse con John, para lo cual:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg># Jessica's Machine
	$ git fetch origin
	...
	From jessica@githost:simplegit
	   fbff5bc..72bbc59  master     -&gt; origin/master</seg>
      </tuv>
      <tuv lang="ES">
        <seg># Jessica's Machine
	$ git fetch origin
	...
	From jessica@githost:simplegit
	   fbff5bc..72bbc59  master     -&gt; origin/master</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>That pulls down the work John has pushed up in the meantime.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto recupera el trabajo enviado por John durante el tiempo en que Jessica estaba trabajando.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Jessica’s history now looks like Figure 5-8.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El historial de Jessica es en estos momentos como se muestra en la figura 5-8.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0508.png 
Figure 5-8.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0508.png 
Figura 5-8.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Jessica’s history after fetching John’s changes.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El historial de Jessica tras recuperar los cambios de John.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Jessica thinks her topic branch is ready, but she wants to know what she has to merge her work into so that she can push.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Jessica considera su rama puntual terminada, pero quiere saber lo que debe integrar con su trabajo antes de poder enviarla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>She runs `git log` to find out:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Lo comprueba con el comando 'git log':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git log --no-merges origin/master ^issue54
	commit 738ee872852dfaa9d6634e0dea7a324040193016
	Author: John Smith &lt;jsmith@example.com&gt;
	Date:   Fri May 29 16:01:27 2009 -0700</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git log --no-merges origin/master ^issue54
	commit 738ee872852dfaa9d6634e0dea7a324040193016
	Author: John Smith &lt;jsmith@example.com&gt;
	Date:   Fri May 29 16:01:27 2009 -0700</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>removed invalid default value</seg>
      </tuv>
      <tuv lang="ES">
        <seg>removed invalid default value</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now, Jessica can merge her topic work into her master branch, merge John’s work (`origin/master`) into her `master` branch, and then push back to the server again.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Ahora, jessica puede fusionar (merge) su trabajo de la rama puntual 'issue54' en su rama 'master'l, fusionar (merge) el trabajo de John ('origin/master') en su rama 'master', y enviarla de vuelta al servidor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>First, she switches back to her master branch to integrate all this work:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Primero, se posiciona de nuevo en su rama principal para integrar todo su trabajo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git checkout master
	Switched to branch &quot;master&quot;
	Your branch is behind 'origin/master' by 2 commits, and can be fast-forwarded.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git checkout master
	Switched to branch &quot;master&quot;
	Your branch is behind 'origin/master' by 2 commits, and can be fast-forwarded.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>She can merge either `origin/master` or `issue54` first — they’re both upstream, so the order doesn’t matter.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puede fusionar primero tanto 'origin/master' o como 'issue54', ya que ambos están aguas arriba.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The end snapshot should be identical no matter which order she chooses; only the history will be slightly different.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La situación final (snapshot) será la misma, indistintamente del orden elegido; tan solo el historial variará ligeramente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>She chooses to merge in `issue54` first:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Elige fusionar primero 'issue54':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git merge issue54
	Updating fbff5bc..4af4298
	Fast forward
	 README           |    1 +
	 lib/simplegit.rb |    6 +++++-
	 2 files changed, 6 insertions(+), 1 deletions(-)</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git merge issue54
	Updating fbff5bc..4af4298
	Fast forward
	 README           |    1 +
	 lib/simplegit.rb |    6 +++++-
	 2 files changed, 6 insertions(+), 1 deletions(-)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>No problems occur; as you can see it, was a simple fast-forward.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>No hay ningún problema; como puedes observar, es un simple avance rápido (fast-forward).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now Jessica merges in John’s work (`origin/master`):</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tras esto, jessica fusiona el trabajo de John ('origin/master'):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git merge origin/master
	Auto-merging lib/simplegit.rb
	Merge made by recursive.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git merge origin/master
	Auto-merging lib/simplegit.rb
	Merge made by recursive.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>lib/simplegit.rb |    2 +-
	 1 files changed, 1 insertions(+), 1 deletions(-)</seg>
      </tuv>
      <tuv lang="ES">
        <seg>lib/simplegit.rb |    2 +-
	 1 files changed, 1 insertions(+), 1 deletions(-)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Everything merges cleanly, and Jessica’s history looks like Figure 5-9.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Todo se integra limpiamente, y el historial de Jessica queda como en la Figura 5-9.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0509.png 
Figure 5-9.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0509.png 
Figura 5-9.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Jessica’s history after merging John’s changes.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El historial de Jessica tras fusionar los cambios de John.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now `origin/master` is reachable from Jessica’s `master` branch, so she should be able to successfully push (assuming John hasn’t pushed again in the meantime):</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En este punto, la rama 'origin/master' es alcanzable desde la rama 'master' de Jessica, permitiendole enviar (push) --asumiendo que John no haya enviado nada más durante ese tiempo--:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git push origin master
	...
	To jessica@githost:simplegit.git
	   72bbc59..8059c15  master -&gt; master</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git push origin master
	...
	To jessica@githost:simplegit.git
	   72bbc59..8059c15  master -&gt; master</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Each developer has committed a few times and merged each other’s work successfully; see Figure 5-10.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cada desarrollador ha confirmado algunos cambios y ambos han fusionado sus trabajos correctamente; ver Figura 5-10.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0510.png 
Figure 5-10.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0510.png 
Figura 5-10.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Jessica’s history after pushing all changes back to the server.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El historial de Jessica tras enviar de vuelta todos los cambios al servidor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>That is one of the simplest workflows.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Este es uno de los flujos de trabajo más simples.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You work for a while, generally in a topic branch, and merge into your master branch when it’s ready to be integrated.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Trabajas un rato, normalmente en una rama puntual de un asunto concreto, y la fusionas con tu rama principal cuando la tienes lista para integrar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When you want to share that work, you merge it into your own master branch, then fetch and merge `origin/master` if it has changed, and finally push to the `master` branch on the server.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cuando deseas compartir ese trabajo, lo fusionas (merge) en tu propia rama 'master'; luego recuperas (fetch) y fusionas (merge) la rama 'origin/master', por si hubiera cambiado; y finalmente envias (push) la rama 'master' de vuelta al servidor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The general sequence is something like that shown in Figure 5-11.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La secuencia general es algo así como la mostrada en la Figura 5-11.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0511.png 
Figure 5-11.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0511.png 
Figura 5-11.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>General sequence of events for a simple multiple-developer Git workflow.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Secuencia general de eventos en un flujo de trabajo multidesarrollador simple.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Private Managed Team ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Grupo Privado Gestionado ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In this next scenario, you’ll look at contributor roles in a larger private group.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En este próximo escenario, vamos a hechar un vistazo al rol de colaborador en un gran grupo privado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You’ll learn how to work in an environment where small groups collaborate on features and then those team-based contributions are integrated by another party.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Aprenderás cómo trabajar en un entorno donde pequeños grupos colaboran en algunas funcionalidades, y luego todas las aportaciones de esos equipos son integradas por otro grupo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Let’s say that John and Jessica are working together on one feature, while Jessica and Josie are working on a second.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Supongamos que John y Jessica trabajan conjuntamente en una funcionalidad, mientras que jessica y Josie trabajan en una segunda funcionalidad.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In this case, the company is using a type of integration-manager workflow where the work of the individual groups is integrated only by certain engineers, and the `master` branch of the main repo can be updated only by those engineers.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En este caso, la compañia está utilizando un flujo de trabajo del tipo gestor-de-integración, donde el trabajo de algunos grupos individuales es integrado por unos ingenieros concretos; siendo solamente estos últimos quienes pueden actualizar la rama 'master' del repositorio principal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In this scenario, all work is done in team-based branches and pulled together by the integrators later.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En este escenario, todo el trabajo se realiza en ramas propias de cada grupo y es consolidado por los integradores más tarde.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Let’s follow Jessica’s workflow as she works on her two features, collaborating in parallel with two different developers in this environment.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Vamos a seguir el trabajo de Jessica, a medida que trabaja en sus dos funcionalidade; colaborando en paralelo con dos desarrolladores distintos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Assuming she already has her repository cloned, she decides to work on `featureA` first.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Suponiendo que tiene su repositorio ya clonado, ella decide trabajar primero en la funcionalidad A (featureA).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>She creates a new branch for the feature and does some work on it there:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Crea una nueva rama para dicha funcionalidad y trabaja en ella:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg># Jessica's Machine
	$ git checkout -b featureA
	Switched to a new branch &quot;featureA&quot;
	$ vim lib/simplegit.rb
	$ git commit -am 'add limit to log function'
	[featureA 3300904] add limit to log function
	 1 files changed, 1 insertions(+), 1 deletions(-)</seg>
      </tuv>
      <tuv lang="ES">
        <seg># Jessica's Machine
	$ git checkout -b featureA
	Switched to a new branch &quot;featureA&quot;
	$ vim lib/simplegit.rb
	$ git commit -am 'add limit to log function'
	[featureA 3300904] add limit to log function
	 1 files changed, 1 insertions(+), 1 deletions(-)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>At this point, she needs to share her work with John, so she pushes her `featureA` branch commits up to the server.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En ese punto, necesita compartir su trabajo con John, por lo que envia (push) al servidor las confirmaciones (commits) en su rama 'featureA'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Jessica doesn’t have push access to the `master` branch — only the integrators do — so she has to push to another branch in order to collaborate with John:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Como Jessica no tiene acceso de envio a la rama 'master' --solo los integradores lo tienen--, ha de enviar a alguna otra rama para poder colaborar con John:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git push origin featureA
	...
	To jessica@githost:simplegit.git
	 * [new branch]      featureA -&gt; featureA</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git push origin featureA
	...
	To jessica@githost:simplegit.git
	 * [new branch]      featureA -&gt; featureA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Jessica e-mails John to tell him that she’s pushed some work into a branch named `featureA` and he can look at it now.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Jessica notifica a John por correo electrónico que ha enviado trabajo a una rama denominada 'featureA' y que puede hecharle un vistazo allí.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>While she waits for feedback from John, Jessica decides to start working on `featureB` with Josie.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Mientras espera noticias de John, Jessica decide comenzar a trabajar en la funcionalidad B (featureB) con Josie.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To begin, she starts a new feature branch, basing it off the server’s `master` branch:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para empezar, arranca una nueva rama puntual, basada en la rama 'master' del servidor:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg># Jessica's Machine
	$ git fetch origin
	$ git checkout -b featureB origin/master
	Switched to a new branch &quot;featureB&quot;</seg>
      </tuv>
      <tuv lang="ES">
        <seg># Jessica's Machine
	$ git fetch origin
	$ git checkout -b featureB origin/master
	Switched to a new branch &quot;featureB&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now, Jessica makes a couple of commits on the `featureB` branch:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y realiza un par de confirmaciones de cambios (commits) en la rama 'featureB':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ vim lib/simplegit.rb
	$ git commit -am 'made the ls-tree function recursive'
	[featureB e5b0fdc] made the ls-tree function recursive
	 1 files changed, 1 insertions(+), 1 deletions(-)
	$ vim lib/simplegit.rb
	$ git commit -am 'add ls-files'
	[featureB 8512791] add ls-files
	 1 files changed, 5 insertions(+), 0 deletions(-)</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ vim lib/simplegit.rb
	$ git commit -am 'made the ls-tree function recursive'
	[featureB e5b0fdc] made the ls-tree function recursive
	 1 files changed, 1 insertions(+), 1 deletions(-)
	$ vim lib/simplegit.rb
	$ git commit -am 'add ls-files'
	[featureB 8512791] add ls-files
	 1 files changed, 5 insertions(+), 0 deletions(-)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Jessica’s repository looks like Figure 5-12.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Quedando su repositorio como se muestra en la Figura 5-12</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0512.png 
Figure 5-12.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0512.png 
Figura 5-12.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>She’s ready to push up her work, but gets an e-mail from Josie that a branch with some initial work on it was already pushed to the server as `featureBee`.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cuando está preparada para enviar (push) su trabajo, recibe un correo-e de Josie de que ha puesto en el servidor una rama denominada 'featureBee', con algo de trabajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Jessica first needs to merge those changes in with her own before she can push to the server.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Jessica necesita fusionar (merge) dichos cambios con los suyos antes de poder enviarlos al servidor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>She can then fetch Josie’s changes down with `git fetch`:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por tanto, recupera (fetch) los cambios de Josie: </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git fetch origin
	...
	From jessica@githost:simplegit
	 * [new branch]      featureBee -&gt; origin/featureBee</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git fetch origin
	...
	From jessica@githost:simplegit
	 * [new branch]      featureBee -&gt; origin/featureBee</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Jessica can now merge this into the work she did with `git merge`:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y los fusiona con su propio trabajo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git merge origin/featureBee
	Auto-merging lib/simplegit.rb
	Merge made by recursive.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git merge origin/featureBee
	Auto-merging lib/simplegit.rb
	Merge made by recursive.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>lib/simplegit.rb |    4 ++++
	 1 files changed, 4 insertions(+), 0 deletions(-)</seg>
      </tuv>
      <tuv lang="ES">
        <seg>lib/simplegit.rb |    4 ++++
	 1 files changed, 4 insertions(+), 0 deletions(-)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>There is a bit of a problem — she needs to push the merged work in her `featureB` branch to the `featureBee` branch on the server.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Pero hay un pequeño problema, necesita enviar el trabajo fusionado en su rama 'featureB' a la rama 'featureBee' del servidor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>She can do so by specifying the local branch followed by a colon (:) followed by the remote branch to the `git push` command:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puede hacerlo usando el comando 'git push' e indicando específicamente el nombre de la rama local seguida de dos puntos (:) y seguida del nombre de la rama remota:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git push origin featureB:featureBee
	...
	To jessica@githost:simplegit.git
	   fba9af8..cd685d1  featureB -&gt; featureBee</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git push origin featureB:featureBee
	...
	To jessica@githost:simplegit.git
	   fba9af8..cd685d1  featureB -&gt; featureBee</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is called a _refspec_.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto es lo que se denomina un _refspec_.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>See Chapter 9 for a more detailed discussion of Git refspecs and different things you can do with them.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes ver el Capítulo 9 para una discusión más detallada acerca de los _refspecs_ de Git y los distintos usos que puedes darles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Next, John e-mails Jessica to say he’s pushed some changes to the `featureA` branch and ask her to verify them.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>A continuación, John envia un correo-e a jessica comentandole que ha enviado algunos cambios a la rama 'featureA' y pidiendole que los verifique.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>She runs a `git fetch` to pull down those changes:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Ella lanza un 'git fetch' para recuperar dichos cambios:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git fetch origin
	...
	From jessica@githost:simplegit
	   3300904..aad881d  featureA   -&gt; origin/featureA</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git fetch origin
	...
	From jessica@githost:simplegit
	   3300904..aad881d  featureA   -&gt; origin/featureA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Then, she can see what has been changed with `git log`:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>A continuación, puede ver las modificaciones realizadas, lanzando el comando 'git log':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git log origin/featureA ^featureA
	commit aad881d154acdaeb2b6b18ea0e827ed8a6d671e6
	Author: John Smith &lt;jsmith@example.com&gt;
	Date:   Fri May 29 19:57:33 2009 -0700</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git log origin/featureA ^featureA
	commit aad881d154acdaeb2b6b18ea0e827ed8a6d671e6
	Author: John Smith &lt;jsmith@example.com&gt;
	Date:   Fri May 29 19:57:33 2009 -0700</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>changed log output to 30 from 25</seg>
      </tuv>
      <tuv lang="ES">
        <seg>changed log output to 30 from 25</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Finally, she merges John’s work into her own `featureA` branch:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para terminar, fusiona el trabajo de John en su propia rama 'featureA':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git checkout featureA
	Switched to branch &quot;featureA&quot;
	$ git merge origin/featureA
	Updating 3300904..aad881d
	Fast forward
	 lib/simplegit.rb |   10 +++++++++-
	1 files changed, 9 insertions(+), 1 deletions(-)</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git checkout featureA
	Switched to branch &quot;featureA&quot;
	$ git merge origin/featureA
	Updating 3300904..aad881d
	Fast forward
	 lib/simplegit.rb |   10 +++++++++-
	1 files changed, 9 insertions(+), 1 deletions(-)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Jessica wants to tweak something, so she commits again and then pushes this back up to the server:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Jessica realiza algunos ajustes, los confirma (commit) y los envia (push) de vuelta al servidor:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git commit -am 'small tweak'
	[featureA ed774b3] small tweak
	 1 files changed, 1 insertions(+), 1 deletions(-)
	$ git push origin featureA
	...
	To jessica@githost:simplegit.git
	   3300904..ed774b3  featureA -&gt; featureA</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git commit -am 'small tweak'
	[featureA ed774b3] small tweak
	 1 files changed, 1 insertions(+), 1 deletions(-)
	$ git push origin featureA
	...
	To jessica@githost:simplegit.git
	   3300904..ed774b3  featureA -&gt; featureA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Jessica’s commit history now looks something like Figure 5-13.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Quedando su historial como se muestra en la Figura 5-13.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0513.png 
Figure 5-13.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0513.png 
Figura 5-13.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Jessica’s history after committing on a feature branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El historial de Jessica después de confirmar cambios en una rama puntual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Jessica, Josie, and John inform the integrators that the `featureA` and `featureBee` branches on the server are ready for integration into the mainline.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Jessica, Josie y John informan a los integradores de que las ramas 'featureA' y 'featureBee' del servidor están preparadas para su integración con la línea principal del programa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>After they integrate these branches into the mainline, a fetch will bring down the new merge commits, making the commit history look like Figure 5-14.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Despues de que dichas ramas sean integradas en la línea principal, una recuperación (fetch) traerá de vuelta las confirmaciones de cambios de las integraciones (merge commits), dejando un historial como el mostrado en la Figura 5-14.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0514.png 
Figure 5-14.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0514.png 
Figura 5-14.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Jessica’s history after merging both her topic branches.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El historial de Jessica tras fusionar sus dos ramas puntuales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Many groups switch to Git because of this ability to have multiple teams working in parallel, merging the different lines of work late in the process.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Muchos grupos se están pasando a trabajar con Git, debido a su habilidad para mantener multiples equipos trabajando en paralelo, fusionando posteriormente las diferentes líneas de trabajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The ability of smaller subgroups of a team to collaborate via remote branches without necessarily having to involve or impede the entire team is a huge benefit of Git.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La habilidad para que pequeños subgrupos de un equipo colaboren a través de ramas remotas, sin necesidad de tener en cuenta o de perturbar el equipo completo, es un gran beneficio de trabajar con Git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The sequence for the workflow you saw here is something like Figure 5-15.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La secuencia del flujo de trabajo que hemos visto es algo así como lo mostrado en la Figura 5-15.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0515.png 
Figure 5-15.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0515.png 
Figura 5-15.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Basic sequence of this managed-team workflow.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Secuencia básica de este flujo de trabajo en equipo gestionado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Public Small Project ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Pequeño Proyecto Público ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Contributing to public projects is a bit different.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Contribuir a proyectos públicos es ligeramente diferente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Because you don’t have the permissions to directly update branches on the project, you have to get the work to the maintainers some other way.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Ya que no tendrás permisos para actualizar ramas directamente sobre el proyecto, has de enviar el trabajo a los gestores de otra manera.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This first example describes contributing via forking on Git hosts that support easy forking.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En este primer ejemplo, veremos cómo contribuir a través de bifurcaciones (forks) en servidores Git que soporten dichas bifurcaciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The repo.or.cz and GitHub hosting sites both support this, and many project maintainers expect this style of contribution.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Los sitios como repo.or.cz  ó GitHub permiten realizar esto, y muchos gestores de proyectos esperan este estilo de contribución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The next section deals with projects that prefer to accept contributed patches via e-mail.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En la siguiente sección, veremos el caso de los proyectos que prefieren aceptar contribuciones a través del correo electrónico.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>First, you’ll probably want to clone the main repository, create a topic branch for the patch or patch series you’re planning to contribute, and do your work there.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para empezar, problemente desees clonar el repositorio principal, crear una rama puntual para el parche con el que piensas contribuir, y ponerte a trabajar sobre ella.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The sequence looks basically like this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La secuencia será algo parecido a esto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git clone (url)
	$ cd project
	$ git checkout -b featureA
	$ (work)
	$ git commit
	$ (work)
	$ git commit</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git clone (url)
	$ cd project
	$ git checkout -b featureA
	$ (work)
	$ git commit
	$ (work)
	$ git commit</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You may want to use `rebase -i` to squash your work down to a single commit, or rearrange the work in the commits to make the patch easier for the maintainer to review — see Chapter 6 for more information about interactive rebasing.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes querer utilizar 'rebase -i' para reducir tu trabajo a una sola confirmación de cambios (commit), o reorganizar el trabajo en las diversas confirmaciones para facilitar la revisión de parche por parte del gestor del proyecto --ver el Capítulo 6 para más detalles sobre reorganizaciones interactivas--.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When your branch work is finished and you’re ready to contribute it back to the maintainers, go to the original project page and click the &quot;Fork&quot; button, creating your own writable fork of the project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cuando el trabajo en tu rama puntual está terminado y estás listo para enviarlo al gestor del proyecto, vete a la página del proyecto original y clica sobre el botón &quot;Fork&quot; (bifurcar), para crear así tu propia copia editable del proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You then need to add in this new repository URL as a second remote, in this case named `myfork`:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tendrás que añadir la URL a este nuevo repositorio como un segundo remoto, y en este caso lo denominaremos 'myfork':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git remote add myfork (url)</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git remote add myfork (url)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You need to push your work up to it.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tu trabajo lo enviarás (push) a este segundo remoto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It’s easiest to push the remote branch you’re working on up to your repository, rather than merging into your master branch and pushing that up.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Es más sencillo enviar (push) directamente la rama puntual sobre la que estás trabajando, en lugar de fusionarla (merge) previamente con tu rama principal y enviar esta última.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The reason is that if the work isn’t accepted or is cherry picked, you don’t have to rewind your master branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y la razón para ello es que, si el trabajo no es aceptado o se integra solo parcialmente, no tendrás que rebobinar tu rama principal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If the maintainers merge, rebase, or cherry-pick your work, you’ll eventually get it back via pulling from their repository anyhow:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si el gestor del proyecto fusiona (merge), reorganiza (rebase) o integra solo parcialmente tu trabajo, aún podrás recuperarlo de vuelta a través de su repositorio:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git push myfork featureA</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git push myfork featureA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When your work has been pushed up to your fork, you need to notify the maintainer.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tras enviar (push) tu trabajo a tu copia bifurcada (fork), has de notificarselo al gestor del proyecto. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is often called a pull request, and you can either generate it via the website — GitHub has a &quot;pull request&quot; button that automatically messages the maintainer — or run the `git request-pull` command and e-mail the output to the project maintainer manually.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Normalmente se suele hacer a través de una solicitud de recuperación/integración (pull request). La puedes generar directamente desde el sitio web, --GitHub tiene un botón &quot;pull request&quot; que notifica automáticamente al gestor--, o puedes lanzar el comando 'git request-pull' y enviar manualmente su salida por correo electrónico al gestor del proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The `request-pull` command takes the base branch into which you want your topic branch pulled and the Git repository URL you want them to pull from, and outputs a summary of all the changes you’re asking to be pulled in.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Este comando 'request-pull' compara la rama base donde deseas que se integre tu rama puntual y el repositorio desde cuya URL deseas que se haga, para darte un resumen de todos los cambios que deseas integrar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For instance, if Jessica wants to send John a pull request, and she’s done two commits on the topic branch she just pushed up, she can run this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por ejemplo, si Jessica quiere enviar a John una solicitud de recuperación, y ha realizado dos confirmaciones de cambios sobre la rama puntual que desea enviar, lanzará los siguientes comandos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git request-pull origin/master myfork
	The following changes since commit 1edee6b1d61823a2de3b09c160d7080b8d1b3a40:
	  John Smith (1):
	        added a new function</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git request-pull origin/master myfork
	The following changes since commit 1edee6b1d61823a2de3b09c160d7080b8d1b3a40:
	  John Smith (1):
	        added a new function</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>are available in the git repository at:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>are available in the git repository at:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>git://githost/simplegit.git featureA</seg>
      </tuv>
      <tuv lang="ES">
        <seg>git://githost/simplegit.git featureA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Jessica Smith (2):
	      add limit to log function
	      change log output to 30 from 25</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Jessica Smith (2):
	      add limit to log function
	      change log output to 30 from 25</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>lib/simplegit.rb |   10 +++++++++-
	 1 files changed, 9 insertions(+), 1 deletions(-)</seg>
      </tuv>
      <tuv lang="ES">
        <seg>lib/simplegit.rb |   10 +++++++++-
	 1 files changed, 9 insertions(+), 1 deletions(-)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The output can be sent to the maintainer—it tells them where the work was branched from, summarizes the commits, and tells where to pull this work from.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esta salida puede ser enviada al gestor del proyecto, --le indica el punto donde  se ramificó, resume las confirmaciones de cambio, y le dice desde dónde recuperar estos cambios--.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>On a project for which you’re not the maintainer, it’s generally easier to have a branch like `master` always track `origin/master` and to do your work in topic branches that you can easily discard if they’re rejected.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En un proyecto del que no seas gestor, suele ser más sencillo tener una rama tal como 'master' siguiendo siempre a la rama 'origin/master'; mientras realizas todo tu trabajo en otras ramas puntuales, que podrás descartar facilmente en caso de que alguna de ellas sea rechazada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Having work themes isolated into topic branches also makes it easier for you to rebase your work if the tip of the main repository has moved in the meantime and your commits no longer apply cleanly.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Manteniendo el trabajo de distintos temas aislados en sus respectivas ramas puntuales, te facilitas también el poder reorganizar tu trabajo si la cabeza del repositorio principal se mueve mientras tanto y tus confirmaciones de cambio (commits) ya no se pueden integrar limpiamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For example, if you want to submit a second topic of work to the project, don’t continue working on the topic branch you just pushed up — start over from the main repository’s `master` branch:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por ejemplo, si deseas contribuir al proyecto en un segundo tema, no continues trabajando sobre la rama puntual que acabas de enviar; comienza una nueva rama puntual desde la rama 'master' del repositorio principal: </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git checkout -b featureB origin/master
	$ (work)
	$ git commit
	$ git push myfork featureB
	$ (email maintainer)
	$ git fetch origin</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git checkout -b featureB origin/master
	$ (work)
	$ git commit
	$ git push myfork featureB
	$ (email maintainer)
	$ git fetch origin</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now, each of your topics is contained within a silo — similar to a patch queue — that you can rewrite, rebase, and modify without the topics interfering or interdepending on each other as in Figure 5-16.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>De esta forma, cada uno de los temas está aislado dentro de un silo, --similar a una cola de parches--; permitiendote reescribir, reorganizar y modificar cada uno de ellos sin interferir ni crear interdependencias entre ellos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0516.png 
Figure 5-16.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0516.png 
Figura 5-16.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Initial commit history with featureB work.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Historial inicial con el trabajo de la funcionalidad B.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Let’s say the project maintainer has pulled in a bunch of other patches and tried your first branch, but it no longer cleanly merges.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Supongamos que el gestor del proyecto ha recuperado e integrado un grupo de otros parches y después lo intenta con tu primer parche, viendo que no se integra limpiamente. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In this case, you can try to rebase that branch on top of `origin/master`, resolve the conflicts for the maintainer, and then resubmit your changes:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En este caso, puedes intentar reorganizar (rebase) tu parche sobre 'origin/master', arreglar los conflictos y volver a enviar tus cambios:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git checkout featureA
	$ git rebase origin/master
	$ git push –f myfork featureA</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git checkout featureA
	$ git rebase origin/master
	$ git push –f myfork featureA</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This rewrites your history to now look like Figure 5-17.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto reescribe tu historial, quedando como se vé en la Figura 5-17.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0517.png 
Figure 5-17.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0517.png 
Figura 5-17.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Commit history after featureA work.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Historial tras el trabajo en la funcionalidad A.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Because you rebased the branch, you have to specify the `–f` to your push command in order to be able to replace the `featureA` branch on the server with a commit that isn’t a descendant of it.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Debido a que has reorganizado (rebase) tu rama de trabajo, tienes que indicar la opción '-f' en tu comando de envio (push), para permitir que la rama 'featureA' del servidor sea reemplazada por una confirmación de cambios (commit) que no es hija suya.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>An alternative would be to push this new work to a different branch on the server (perhaps called `featureAv2`).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Una alternativa podría ser el enviar (push) este nuevo trabajo a una rama diferente del servidor (por ejemplo a 'featureAv2').</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Let’s look at one more possible scenario: the maintainer has looked at work in your second branch and likes the concept but would like you to change an implementation detail.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Vamos a ver otro posible escenario: el gestor del proyecto ha revisado tu trabajo en la segunda rama y le ha gustado el concepto, pero desea que cambies algunos detalles de la implementación. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You’ll also take this opportunity to move the work to be based off the project’s current `master` branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes aprovechar también esta oportunidad para mover el trabajo y actualizarlo sobre la actual rama 'master' del proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You start a new branch based off the current `origin/master` branch, squash the `featureB` changes there, resolve any conflicts, make the implementation change, and then push that up as a new branch:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para ello, inicias una nueva rama basada en la actual 'origin/master', aplicas (squash) sobre ella los cambios de 'featureB', resuelves los posibles conflictos que se pudieran presentar, realizas los cambios en los detalles, y la envias de vuelta como una nueva rama:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git checkout -b featureBv2 origin/master
	$ git merge --no-commit --squash featureB
	$ (change implementation)
	$ git commit
	$ git push myfork featureBv2</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git checkout -b featureBv2 origin/master
	$ git merge --no-commit --squash featureB
	$ (change implementation)
	$ git commit
	$ git push myfork featureBv2</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The `--squash` option takes all the work on the merged branch and squashes it into one non-merge commit on top of the branch you’re on.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La opción '--squash' coge todo el trabajo en la rama fusionada y lo aplica, en una sola confirmación de cambios sin fusión (no-merge commit), sobre la rama en la que estés situado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The `--no-commit` option tells Git not to automatically record a commit.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La opción '--no-commit' indica a Git que no debe registrar automáticamente una confirmación de cambios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This allows you to introduce all the changes from another branch and then make more changes before recording the new commit.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto te permitirá el aplicar todos los cambios de la otra rama y después hacer más cambios, antes de guardarlos todos ellos en una nueva confirmación (commit).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now you can send the maintainer a message that you’ve made the requested changes and they can find those changes in your `featureBv2` branch (see Figure 5-18).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En estos momentos, puedes notificar al gestor del proyecto que has realizado todos los cambios solicitados y que los puede encontrar en tu rama 'featureBv2' (ver Figura 5-18).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0518.png 
Figure 5-18.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0518.png 
Figura 5-18.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Commit history after featureBv2 work.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Historial tras el trabajo en la versión 2 de la funcionalidad B.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## Summary ##</seg>
      </tuv>
      <tuv lang="ES">
        <seg>## Recapitulación ##</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Cualquier sistema de control de versiones moderno tiene algún mecanismo para soportar distintas ramas.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cualquier sistema de control de versiones moderno tiene algún mecanismo para soportar distintos ramales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Cuando hablamos de ramificaciones, significa que tu has tomado la rama principal de desarrollo (master) y a partir de ahí has continuado trabajando sin seguir la rama principal de desarrollo.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cuando hablamos de ramificaciones, significa que tu has tomado la rama principal de desarrollo (master) y a partir de ahí has continuado trabajando sin seguir la rama principal de desarrollo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>En muchas sistemas de control de versiones este proceso es costoso, pues a menudo requiere crear una nueva copia del código, lo cual puede tomar mucho tiempo cuando se trata de proyectos grandes.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En muchas sistemas de control de versiones este proceso es costoso, pues a menudo requiere crear una nueva copia del código, lo cual puede tomar mucho tiempo cuando se trata de proyectos grandes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Algunas personas resaltan que uno de los puntos mas fuertes de Git es su sistema de ramificaciones y lo cierto es que esto le hace resaltar sobre los otros sistemas de control de versiones.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Algunas personas resaltan que uno de los puntos mas fuertes de Git es su sistema de ramificaciones y lo cierto es que esto le hace resaltar sobre los otros sistemas de control de versiones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>¿Porqué esto es tan importante?</seg>
      </tuv>
      <tuv lang="ES">
        <seg>¿Porqué esto es tan importante?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>La forma en la que Git maneja las ramificaciones es increíblemente rápida, haciendo así de las operaciones de ramificación algo casi instantáneo, al igual que el avance o el retroceso entre distintas ramas, lo cual también es tremendamente rápido.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La forma en la que Git maneja las ramificaciones es increíblemente rápida, haciendo así de las operaciones de ramificación algo casi instantáneo, al igual que el avance o el retroceso entre distintas ramas, lo cual también es tremendamente rápido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>A diferencia de otros sistemas de control de versiones, Git promueve un ciclo de desarrollo donde las ramas se crean y se unen ramas entre sí, incluso varias veces en el mismo día.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>A diferencia de otros sistemas de control de versiones, Git promueve un ciclo de desarrollo donde las ramas se crean y se unen ramas entre sí, incluso varias veces en el mismo día.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Entender y manejar esta opción te proporciona una poderosa y exclusiva herramienta que puede, literalmente, cambiar la forma en la que desarrollas.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Entender y manejar esta opción te proporciona una poderosa y exclusiva herramienta que puede, literalmente, cambiar la forma en la que desarrollas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## ¿Qué es una rama?</seg>
      </tuv>
      <tuv lang="ES">
        <seg>## ¿Qué es una rama?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>##</seg>
      </tuv>
      <tuv lang="ES">
        <seg>##</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To really understand the way Git does branching, we need to take a step back and examine how Git stores its data.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para entender realmente cómo ramifica Git, previamente hemos de examinar la forma en que almacena sus datos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>As you may remember from Chapter 1, Git doesn’t store data as a series of changesets or deltas, but instead as a series of snapshots.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Recordando lo citado en el capítulo 1, Git no los almacena de forma incremental (guardando solo diferencias), sino que los almacena como una serie de instantáneas (copias puntuales de los archivos completos, tal y como se encuentran en ese momento). </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When you commit in Git, Git stores a commit object that contains a pointer to the snapshot of the content you staged, the author and message metadata, and zero or more pointers to the commit or commits that were the direct parents of this commit: zero parents for the first commit, one parent for a normal commit, and multiple parents for a commit that results from a merge of two or more branches.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En cada confirmación de cambios (commit), Git almacena un punto de control que conserva: un apuntador a la copia puntual de los contenidos preparados (staged), unos metadatos con el autor y el mensaje explicativo, y uno o varios apuntadores a las confirmaciones (commit) que sean padres directos de esta (un padre en los casos de confirmación normal, y múltiples padres en los casos de estar confirmando una fusión (merge) de dos o mas ramas).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To visualize this, let’s assume that you have a directory containing three files, and you stage them all and commit.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para ilustrar esto, vamos a suponer, por ejemplo, que tienes una carpeta con tres archivos, que preparas (stage) todos ellos y los confirmas (commit).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Staging the files checksums each one (the SHA-1 hash we mentioned in Chapter 1), stores that version of the file in the Git repository (Git refers to them as blobs), and adds that checksum to the staging area:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Al preparar los archivos, Git realiza una suma de control de cada uno de ellos (un resumen SHA-1, tal y como se mencionaba en el capítulo 1), almacena una copia de cada uno en el repositorio (estas copias se denominan &quot;blobs&quot;), y guarda cada suma de control en el área de preparación (staging area):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git add README test.rb LICENSE
	$ git commit -m 'initial commit of my project'</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git add README test.rb LICENSE
	$ git commit -m 'initial commit of my project'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When you create the commit by running `git commit`, Git checksums each subdirectory (in this case, just the root project directory) and stores those tree objects in the Git repository.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cuando creas una confirmación con el comando 'git commit', Git realiza sumas de control de cada subcarpeta (en el ejemplo, solamente tenemos la carpeta principal del proyecto), y guarda en el repositorio Git una copia de cada uno de los archivos contenidos en ella/s.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git then creates a commit object that has the metadata and a pointer to the root project tree so it can re-create that snapshot when needed.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Después, Git crea un objeto de confirmación con los metadatos pertinentes y un apuntador al nodo correspondiente del árbol de proyecto. Esto permitirá poder regenerar posteriormente dicha instantánea cuando sea necesario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Your Git repository now contains five objects: one blob for the contents of each of your three files, one tree that lists the contents of the directory and specifies which file names are stored as which blobs, and one commit with the pointer to that root tree and all the commit metadata.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En este momento, el repositorio de Git contendrá cinco objetos: un &quot;blob&quot; para cada uno de los tres archivos, un árbol con la lista de contenidos de la carpeta (más sus respectivas relaciones con los &quot;blobs&quot;), y una confirmación de cambios (commit) apuntando a la raiz de ese árbol y conteniendo el resto de metadatos pertinentes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Conceptually, the data in your Git repository looks something like Figure 3-1.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Conceptualmente, el contenido del repositorio Git será algo parecido a la Figura 3-1</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0301.png 
Figure 3-1.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0301.png 
Figura 3-1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Single commit repository data.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Datos en el repositorio tras una confirmación sencilla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you make some changes and commit again, the next commit stores a pointer to the commit that came immediately before it.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si haces más cambios y vuelves a confirmar, la siguiente confirmación guardará un apuntador a esta su confirmación precedente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>After two more commits, your history might look something like Figure 3-2.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tras un par de confirmaciones más, el registro ha de ser algo parecido a la Figura 3-2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0302.png 
Figure 3-2.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0302.png 
Figura 3-2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git object data for multiple commits.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Datos en el repositorio tras una serie de confirmaciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>A branch in Git is simply a lightweight movable pointer to one of these commits.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Una rama Git es simplemente un apuntador móvil apuntando a una de esas confirmaciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The default branch name in Git is master.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La rama por defecto de Git es la rama 'master'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>As you initially make commits, you’re given a master branch that points to the last commit you made.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Con la primera confirmación de cambios que realicemos, se creará esta rama principal 'master' apuntando a dicha confirmación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Every time you commit, it moves forward automatically.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En cada confirmación de cambios que realicemos, la rama irá avanzando automáticamente. Y la rama 'master' apuntará siempre a la última confirmación realizada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0303.png 
Figure 3-3.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0303.png 
Figura 3-3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Branch pointing into the commit data’s history.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Apuntadores en el registro de confirmaciones de una rama.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>What happens if you create a new branch?</seg>
      </tuv>
      <tuv lang="ES">
        <seg>¿Qué sucede cuando creas una nueva rama?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Well, doing so creates a new pointer for you to move around.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Bueno....., simplemente se crea un nuevo apuntador para que lo puedas mover libremente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Let’s say you create a new branch called testing.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por ejemplo, si quieres crear una nueva rama denominada &quot;testing&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You do this with the `git branch` command:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Usarás el comando 'git branch':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git branch testing</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git branch testing</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This creates a new pointer at the same commit you’re currently on (see Figure 3-4).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto creará un nuevo apuntador apuntando a la misma confirmación donde estés actualmente (ver Figura 3-4).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0304.png 
Figure 3-4.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0304.png 
Figura 3-4.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Multiple branches pointing into the commit’s data history.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Apuntadores de varias ramas en el registro de confirmaciones de cambio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>How does Git know what branch you’re currently on?</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y, ¿cómo sabe Git en qué rama estás en este momento?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It keeps a special pointer called HEAD.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Pues...., mediante un apuntador especial denominado HEAD.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Note that this is a lot different than the concept of HEAD in other VCSs you may be used to, such as Subversion or CVS.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Aunque es preciso comentar que este HEAD es totalmente distinto al concepto de HEAD en otros sistemas de control de cambios como Subversion o CVS.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In Git, this is a pointer to the local branch you’re currently on.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En Git, es simplemente el apuntador a la rama local en la que tú estés en ese momento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In this case, you’re still on master.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En este caso, en la rama 'master'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The git branch command only created a new branch — it didn’t switch to that branch (see Figure 3-5).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puesto que el comando git branch solamente crea una nueva rama, y no salta a dicha rama.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0305.png 
Figure 3-5.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0305.png 
Figura 3-5.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>HEAD file pointing to the branch you’re on.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Apuntador HEAD a la rama donde estás actualmente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To switch to an existing branch, you run the `git checkout` command.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para saltar de una rama a otra, tienes que utilizar el comando 'git checkout'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Let’s switch to the new testing branch:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Hagamos una prueba, saltando a la rama 'testing' recién creada:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git checkout testing</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git checkout testing</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This moves HEAD to point to the testing branch (see Figure 3-6).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto mueve el apuntador HEAD a la rama 'testing' (ver Figura 3-6).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0306.png
Figure 3-6.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0306.png
Figura 3-6.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>HEAD points to another branch when you switch branches.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Apuntador HEAD apuntando a otra rama cuando saltamos de rama.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>What is the significance of that?</seg>
      </tuv>
      <tuv lang="ES">
        <seg>¿Cuál es el significado de todo esto?.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Well, let’s do another commit:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Bueno.... lo veremos tras realizar otra confirmación de cambios:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ vim test.rb
	$ git commit -a -m 'made a change'</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ vim test.rb
	$ git commit -a -m 'made a change'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Figure 3-7 illustrates the result.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La Figura 3-7 ilustra el resultado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0307.png 
Figure 3-7.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0307.png 
Figura 3-7.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The branch that HEAD points to moves forward with each commit.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La rama apuntada por HEAD avanza con cada confirmación de cambios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is interesting, because now your testing branch has moved forward, but your master branch still points to the commit you were on when you ran `git checkout` to switch branches.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Observamos algo interesante: la rama 'testing' avanza, mientras que la rama 'master' permanece en la confirmación donde estaba cuando lanzaste el comando 'git checkout' para saltar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Let’s switch back to the master branch:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Volvamos ahora a la rama 'master':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git checkout master</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git checkout master</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Figure 3-8 shows the result.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La Figura 3-8 muestra el resultado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0308.png 
Figure 3-8.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0308.png 
Figura 3-8.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>HEAD moves to another branch on a checkout.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>HEAD apunta a otra rama cuando hacemos un checkout.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>That command did two things.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Este comando realiza dos acciones:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It moved the HEAD pointer back to point to the master branch, and it reverted the files in your working directory back to the snapshot that master points to.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Mueve el apuntador HEAD de nuevo a la rama 'master', y revierte los archivos de tu directorio de trabajo; dejandolos tal y como estaban en la última instantánea confirmada en dicha rama 'master'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This also means the changes you make from this point forward will diverge from an older version of the project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto supone que los cambios que hagas desde este momento en adelante divergerán de la antigua versión del proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It essentially rewinds the work you’ve done in your testing branch temporarily so you can go in a different direction.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Básicamente, lo que se está haciendo es rebobinar el trabajo que habias hecho temporalmente en la rama 'testing'; de tal forma que puedas avanzar en otra dirección diferente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Let’s make a few changes and commit again:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Haz algunos cambios más y confirmalos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ vim test.rb
	$ git commit -a -m 'made other changes'</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ vim test.rb
	$ git commit -a -m 'made other changes'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now your project history has diverged (see Figure 3-9).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Ahora el registro de tu proyecto diverge (ver Figura 3-9).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You created and switched to a branch, did some work on it, and then switched back to your main branch and did other work.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Has creado una rama y saltado a ella, has trabajado sobre ella; has vuelto a la rama original, y has trabajado también sobre ella.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Both of those changes are isolated in separate branches: you can switch back and forth between the branches and merge them together when you’re ready.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Los cambios realizados en ambas sesiones de trabajo están aislados en ramas independientes: puedes saltar libremente de una a otra según estimes oportuno.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>And you did all that with simple `branch` and `checkout` commands.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y todo ello simplemente con dos comandos:  'git branch' y 'git checkout'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0309.png 
Figure 3-9.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0309.png 
Figura 3-9.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The branch histories have diverged.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Los registros de las ramas divergen.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Because a branch in Git is in actuality a simple file that contains the 40 character SHA-1 checksum of the commit it points to, branches are cheap to create and destroy.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Debido a que una rama Git es realmente un simple archivo que contiene los 40 caracteres de una suma de control SHA-1, (representando la confirmación de cambios a la que apunta), no cuesta nada el crear y destruir ramas en Git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Creating a new branch is as quick and simple as writing 41 bytes to a file (40 characters and a newline).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Crear una nueva rama es tan rápido y simple como escribir 41 bytes en un archivo, (40 caracteres y un retorno de carro).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is in sharp contrast to the way most VCS tools branch, which involves copying all of the project’s files into a second directory.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto contrasta fuertemente con los métodos de ramificación usados por otros sistemas de control de versiones. En los que crear una nueva rama supone el copiar todos los archivos del proyecto a una nueva carpeta adiccional.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This can take several seconds or even minutes, depending on the size of the project, whereas in Git the process is always instantaneous.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Lo que puede llevar segundos o incluso minutos, dependiendo del tamaño del proyecto. Mientras que en Git el proceso es siempre instantáneo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Also, because we’re recording the parents when we commit, finding a proper merge base for merging is automatically done for us and is generally very easy to do.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y, además, debido a que se almacenan tambien los nodos padre para cada confirmación, el encontrar las bases adecuadas para realizar una fusión entre ramas es un proceso automático y generalmente sencillo de realizar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>These features help encourage developers to create and use branches often.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Animando así a los desarrolladores a utilizar ramificaciones frecuentemente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Let’s see why you should do so.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y vamos a ver el por qué merece la pena hacerlo así.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## Basic Branching and Merging ##</seg>
      </tuv>
      <tuv lang="ES">
        <seg>## Procedimientos básicos para ramificar y fusionar ##</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Let’s go through a simple example of branching and merging with a workflow that you might use in the real world.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Vamos a presentar un ejemplo simple de ramificar y de fusionar, con un flujo de trabajo que se podría presentar en la realidad.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You’ll follow these steps:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Imagina que sigues los siquientes pasos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Do work on a web site.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Trabajas en un sitio web.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Create a branch for a new story you’re working on.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Creas una rama para un nuevo tema sobre el que quieres trabajar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Do some work in that branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Realizas algo de trabajo en esa rama.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>At this stage, you’ll receive a call that another issue is critical and you need a hotfix.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En este momento, recibes una llamada avisandote de un problema crítico que has de resolver.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You’ll do the following:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y sigues los siguientes pasos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Revert back to your production branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Vuelves a la rama de producción original.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Create a branch to add the hotfix.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Creas una nueva rama para el problema crítico y lo resuelves trabajando en ella.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>After it’s tested, merge the hotfix branch, and push to production.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tras las pertinentes pruebas, fusionas (merge) esa rama y la envias (push) a la rama de producción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Switch back to your original story and continue working.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Vuelves a la rama del tema en que andabas antes de la llamada y continuas tu trabajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Basic Branching ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Procedimientos básicos de ramificación ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>First, let’s say you’re working on your project and have a couple of commits already (see Figure 3-10).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Imagina que estas trabajando en un proyecto, y tienes un par de confirmaciones (commit) ya realizadas. (ver Figura 3-10)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0310.png 
Figure 3-10.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0310.png 
Figura 3-10.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>A short and simple commit history.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Un registro de confirmaciones simple y corto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You’ve decided that you’re going to work on issue #53 in whatever issue-tracking system your company uses.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Decides trabajar el problema #53, del sistema que tu compañia utiliza para llevar seguimiento de los problemas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To be clear, Git isn’t tied into any particular issue-tracking system; but because issue #53 is a focused topic that you want to work on, you’ll create a new branch in which to work.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Aunque, por supuesto, Git no está ligado a ningún sistema de seguimiento de problemas concreto. Como el problema #53 es un tema concreto y puntual en el que vas a trabajar, creas una nueva rama para él.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To create a branch and switch to it at the same time, you can run the `git checkout` command with the `-b` switch:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para crear una nueva rama y saltar a ella, en un solo paso, puedes utilizar el comando 'git checkout' con la opción '-b':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git checkout -b iss53
	Switched to a new branch &quot;iss53&quot;</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git checkout -b iss53
	Switched to a new branch &quot;iss53&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is shorthand for:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto es un atajo a:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git branch iss53
	$ git checkout iss53</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git branch iss53
	$ git checkout iss53</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Figure 3-11 illustrates the result.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Figura 3-11 muestra el resultado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0311.png 
Figure 3-11.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0311.png 
Figura 3-11.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Creating a new branch pointer.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Creación de un apuntador a la nueva rama.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You work on your web site and do some commits.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Trabajas en el sitio web y haces algunas confirmaciones de cambios (commits).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Doing so moves the `iss53` branch forward, because you have it checked out (that is, your HEAD is pointing to it; see Figure 3-12):</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Con ello avanzas la rama 'iss53', que es la que tienes activada (checked out) en este momento (es decir, a la que apunta HEAD; ver Figura 3-12):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ vim index.html
	$ git commit -a -m 'added a new footer [issue 53]'</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ vim index.html
	$ git commit -a -m 'added a new footer [issue 53]'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0312.png 
Figure 3-12.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0312.png 
Figura 3-12.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The iss53 branch has moved forward with your work.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La rama 'iss53' ha avanzado con tu trabajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now you get the call that there is an issue with the web site, and you need to fix it immediately.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Entonces, recibes una llamada avisandote de otro problema urgente en el sitio web. Problema que has de resolver inmediatamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>With Git, you don’t have to deploy your fix along with the `iss53` changes you’ve made, and you don’t have to put a lot of effort into reverting those changes before you can work on applying your fix to what is in production.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Usando Git, no necesitas mezclar el nuevo problema con los cambios que ya habias realizado sobre el problema #53; ni tampoco perder tiempo revirtiendo esos cambios para poder trabajar sobre el contenido que está en producción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>All you have to do is switch back to your master branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Basta con saltar de nuevo a la rama 'master' y continuar trabajando a partir de ella.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>However, before you do that, note that if your working directory or staging area has uncommitted changes that conflict with the branch you’re checking out, Git won’t let you switch branches.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Pero, antes de poder hacer eso, hemos de tener en cuenta  que teniendo cambios aún no confirmados en la carpeta de trabajo o en el área de preparación, Git no nos permitirá saltar a otra rama con la que podríamos tener conflictos. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It’s best to have a clean working state when you switch branches.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Lo mejor es tener siempre un estado de trabajo limpio y despejado antes de saltar entre ramas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>There are ways to get around this (namely, stashing and commit amending) that we’ll cover later.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y, para ello, tenemos algunos procedimientos (stash y commit ammend), que vamos a ver más adelante.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For now, you’ve committed all your changes, so you can switch back to your master branch:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por ahora, como tenemos confirmados todos los cambios, podemos saltar a la rama 'master' sin problemas:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git checkout master
	Switched to branch &quot;master&quot;</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git checkout master
	Switched to branch &quot;master&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>At this point, your project working directory is exactly the way it was before you started working on issue #53, and you can concentrate on your hotfix.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tras esto, tendrás la carpeta de trabajo exactamente igual a como estaba antes de comenzar a trabajar sobre el problema #53. Y podrás concentrarte en el nuevo problema urgente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is an important point to remember: Git resets your working directory to look like the snapshot of the commit that the branch you check out points to.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Es importante recordar que Git revierte la carpeta de trabajo exactamente al estado en que estaba en la confirmación (commit)  apuntada por la rama que activamos (checkout) en cada momento. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It adds, removes, and modifies files automatically to make sure your working copy is what the branch looked like on your last commit to it.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Git añade, quita y modifica archivos automáticamente. Para asegurarte que tu copia de trabajo es exactamente tal y como era la rama en la última confirmación de cambios realizada sobre ella.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Next, you have a hotfix to make.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Volviendo al problema urgente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Let’s create a hotfix branch on which to work until it’s completed (see Figure 3-13):</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Vamos a crear una nueva rama 'hotfix', sobre la que trabajar hasta resolverlo (ver Figura 3-13):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git checkout -b 'hotfix'
	Switched to a new branch &quot;hotfix&quot;
	$ vim index.html
	$ git commit -a -m 'fixed the broken email address'
	[hotfix]: created 3a0874c: &quot;fixed the broken email address&quot;
	 1 files changed, 0 insertions(+), 1 deletions(-)</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git checkout -b 'hotfix'
	Switched to a new branch &quot;hotfix&quot;
	$ vim index.html
	$ git commit -a -m 'fixed the broken email address'
	[hotfix]: created 3a0874c: &quot;fixed the broken email address&quot;
	 1 files changed, 0 insertions(+), 1 deletions(-)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0313.png 
Figure 3-13.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0313.png 
Figura 3-13.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>hotfix branch based back at your master branch point.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>rama 'hotfix' basada en la rama 'master' original.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can run your tests, make sure the hotfix is what you want, and merge it back into your master branch to deploy to production.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes realizar las pruebas oportunas, asegurarte que la solución es correcta, e incorporar los cambios a la rama 'master' para ponerlos en producción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You do this with the `git merge` command:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto se hace con el comando 'git merge':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git checkout master
	$ git merge hotfix
	Updating f42c576..3a0874c
	Fast forward
	 README |    1 -
	 1 files changed, 0 insertions(+), 1 deletions(-)</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git checkout master
	$ git merge hotfix
	Updating f42c576..3a0874c
	Fast forward
	 README |    1 -
	 1 files changed, 0 insertions(+), 1 deletions(-)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You’ll notice the phrase &quot;Fast forward&quot; in that merge.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Merece destacar la frase &quot;Avance rápido&quot; (&quot;Fast forward&quot;) que aparece en la respuesta al comando.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Because the commit pointed to by the branch you merged in was directly upstream of the commit you’re on, Git moves the pointer forward.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Git ha movido el apuntador hacia adelante, ya que la confirmación apuntada en la rama donde has fusionado estaba directamente &quot;aguas arriba&quot; respecto de la confirmación actual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To phrase that another way, when you try to merge one commit with a commit that can be reached by following the first commit’s history, Git simplifies things by moving the pointer forward because there is no divergent work to merge together — this is called a &quot;fast forward&quot;.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Dicho de otro modo: cuando intentas fusionar una confirmación con otra confirmación accesible siguiendo directamente el registro de la primera; Git simplifica las cosas avanzando el puntero, ya que no hay ningûn otro trabajo divergente a fusionar. Esto es lo que se denomina &quot;avance rápido&quot; (&quot;fast forward&quot;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Your change is now in the snapshot of the commit pointed to by the `master` branch, and you can deploy your change (see Figure 3-14).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Ahora, los cambios realizados están ya en la instantánea (snapshot) de la confirmación (commit) apuntada por la rama 'master'. Y puedes desplegarlos (ver Figura 3-14)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0314.png 
Figure 3-14.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0314.png 
Figura 3-14.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Your master branch points to the same place as your hotfix branch after the merge.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tras la fusión (merge), la rama 'master' apunta al mismo sitio que la rama 'hotfix'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>After your super-important fix is deployed, you’re ready to switch back to the work you were doing before you were interrupted.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tras haber resuelto el problema urgente que te habia interrumpido tu trabajo, puedes volver a donde estabas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>However, first you’ll delete the `hotfix` branch, because you no longer need it — the `master` branch points at the same place.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Pero antes, es interesante borrar la rama 'hotfix'. Ya que no la vamos a necesitar más, puesto que apunta exactamente al mismo sitio que la rama 'master'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can delete it with the `-d` option to `git branch`:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto lo puedes hacer con la opción '-d' del comando 'git branch':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git branch -d hotfix
	Deleted branch hotfix (3a0874c).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git branch -d hotfix
	Deleted branch hotfix (3a0874c).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now you can switch back to your work-in-progress branch on issue #53 and continue working on it (see Figure 3-15):</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y, con esto, ya estas dispuesto para regresar al trabajo sobre el problema #53 (ver Figura 3-15):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git checkout iss53
	Switched to branch &quot;iss53&quot;
	$ vim index.html
	$ git commit -a -m 'finished the new footer [issue 53]'
	[iss53]: created ad82d7a: &quot;finished the new footer [issue 53]&quot;
	 1 files changed, 1 insertions(+), 0 deletions(-)</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git checkout iss53
	Switched to branch &quot;iss53&quot;
	$ vim index.html
	$ git commit -a -m 'finished the new footer [issue 53]'
	[iss53]: created ad82d7a: &quot;finished the new footer [issue 53]&quot;
	 1 files changed, 1 insertions(+), 0 deletions(-)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0315.png 
Figure 3-15.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0315.png 
Figura 3-15.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Your iss53 branch can move forward independently.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La rama 'iss53' puede avanzar independientemente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It’s worth noting here that the work you did in your `hotfix` branch is not contained in the files in your `iss53` branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cabe indicar que todo el trabajo realizado en la rama 'hotfix' no está en los archivos de la rama 'iss53'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you need to pull it in, you can merge your `master` branch into your `iss53` branch by running `git merge master`, or you can wait to integrate those changes until you decide to pull the `iss53` branch back into `master` later.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si fuera necesario agregarlos, puedes fusionar (merge) la rama 'master' sobre la rama 'iss53' utilizando el comando 'git merge master'. O puedes esperar hasta que decidas llevar (pull) la rama 'iss53' a la rama 'master'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Basic Merging ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Procedimientos básicos de fusión ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Suppose you’ve decided that your issue #53 work is complete and ready to be merged into your `master` branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Supongamos que tu trabajo con el problema #53 está ya completo y listo para fusionarlo (merge) con la rama 'master'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In order to do that, you’ll merge in your `iss53` branch, much like you merged in your `hotfix` branch earlier.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para ello, de forma similar a como antes has hecho con la rama 'hotfix', vas a fusionar la rama 'iss53'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>All you have to do is check out the branch you wish to merge into and then run the `git merge` command:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Simplemente, activando (checkout) la rama donde deseas fusionar y lanzando el comando 'git merge':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git checkout master
	$ git merge iss53
	Merge made by recursive.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git checkout master
	$ git merge iss53
	Merge made by recursive.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>README |    1 +
	 1 files changed, 1 insertions(+), 0 deletions(-)</seg>
      </tuv>
      <tuv lang="ES">
        <seg>README |    1 +
	 1 files changed, 1 insertions(+), 0 deletions(-)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This looks a bit different than the `hotfix` merge you did earlier.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Es algo diferente de la fusión realizada anteriormente con 'hotfix'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In this case, your development history has diverged from some older point.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En este caso, el registro de desarrollo habia divergido en un punto anterior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Because the commit on the branch you’re on isn’t a direct ancestor of the branch you’re merging in, Git has to do some work.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Debido a que la confirmación en la rama actual no es ancestro directo de la rama que pretendes fusionar, Git tiene cierto trabajo extra que hacer.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In this case, Git does a simple three-way merge, using the two snapshots pointed to by the branch tips and the common ancestor of the two.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Git realizará una fusión a tres bandas, utilizando las dos instantáneas apuntadas por el extremo de cada una de las ramas y por el ancestro común a ambas dos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Figure 3-16 highlights the three snapshots that Git uses to do its merge in this case.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La figura 3-16 ilustra las tres instantáneas que Git utiliza para realizar la fusión en este caso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0316.png 
Figure 3-16.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0316.png 
Figura 3-16.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git automatically identifies the best common-ancestor merge base for branch merging.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Git identifica automáticamente el mejor ancestro común para realizar la fusión de las ramas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Instead of just moving the branch pointer forward, Git creates a new snapshot that results from this three-way merge and automatically creates a new commit that points to it (see Figure 3-17).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En lugar de simplemente avanzar el apuntador de la rama, Git crea una nueva instantánea (snapshot) resultante de la fusión a tres bandas; y crea automáticamente una nueva confirmación de cambios (commit) que apunta a ella.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is referred to as a merge commit and is special in that it has more than one parent.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Nos referimos a este proceso como &quot;fusión confirmada&quot;. Y se diferencia en que tiene más de un padre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It’s worth pointing out that Git determines the best common ancestor to use for its merge base; this is different than CVS or Subversion (before version 1.5), where the developer doing the merge has to figure out the best merge base for themselves.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Merece la pena destacar el hecho de que es el propio Git quien determina automáticamente el mejor ancestro común para realizar la fusión. Diferenciandose de otros sistemas tales como CVS o Subversion, donde es el desarrollador quien ha de imaginarse cuál puede ser dicho mejor ancestro común.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This makes merging a heck of a lot easier in Git than in these other systems.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto hace que en Git sea mucho más facil el realizar fusiones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0317.png 
Figure 3-17.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0317.png 
Figura 3-17.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git automatically creates a new commit object that contains the merged work.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Git crea automáticamente una nueva confirmación para la fusión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now that your work is merged in, you have no further need for the `iss53` branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Ahora que todo tu trabajo está ya fusionado con la rama principal, ya no tienes necesidad de la rama 'iss53'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can delete it and then manually close the ticket in your ticket-tracking system:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por lo que puedes borrarla. Y cerrar manualmente el problema en el sistema de seguimiento de problemas de tu empresa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git branch -d iss53</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git branch -d iss53</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Basic Merge Conflicts ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Principales conflictos que pueden surgir en las fusiones ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Occasionally, this process doesn’t go smoothly.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En algunas ocasiones, los procesos de fusión no suelen ser fluidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you changed the same part of the same file differently in the two branches you’re merging together, Git won’t be able to merge them cleanly.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si hay modificaciones dispares en una misma porción de un mismo archivo en las dos ramas distintas que pretendes fusionar, Git no será capaz de fusionarlas directamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If your fix for issue #53 modified the same part of a file as the `hotfix`, you’ll get a merge conflict that looks something like this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por ejemplo, si en tu trabajo del problema #53 has modificado una misma porción que también ha sido modificada en el problema 'hotfix'. Puedes obtener un conflicto de fusión tal que:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git merge iss53
	Auto-merging index.html
	CONFLICT (content): Merge conflict in index.html
	Automatic merge failed; fix conflicts and then commit the result.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git merge iss53
	Auto-merging index.html
	CONFLICT (content): Merge conflict in index.html
	Automatic merge failed; fix conflicts and then commit the result.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git hasn’t automatically created a new merge commit.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Git no crea automáticamente una nueva fusión confirmada (merge commit).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It has paused the process while you resolve the conflict.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Sino que hace una pausa en el proceso, esperando a que tu resuelvas el conflicto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you want to see which files are unmerged at any point after a merge conflict, you can run `git status`:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para ver qué archivos permanecen sin fusionar en un determinado momento conflictivo de una fusión, puedes usar el comando 'git status':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>[master*]$ git status
	index.html: needs merge
	# On branch master
	# Changed but not updated:
	#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
	#   (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)
	#
	#	unmerged:   index.html
	#</seg>
      </tuv>
      <tuv lang="ES">
        <seg>[master*]$ git status
	index.html: needs merge
	# On branch master
	# Changed but not updated:
	#   (use &quot;git add &lt;file&gt;...&quot; to update what will be committed)
	#   (use &quot;git checkout -- &lt;file&gt;...&quot; to discard changes in working directory)
	#
	#	unmerged:   index.html
	#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Anything that has merge conflicts and hasn’t been resolved is listed as unmerged.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Todo aquello que sea conflictivo y no se haya podido resolver, se marca como &quot;sin fusionar&quot; (unmerged).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git adds standard conflict-resolution markers to the files that have conflicts, so you can open them manually and resolve those conflicts.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Git añade a los archivos conflictivos unos marcadores especiales de resolución de conflictos. Marcadores que te guiarán cuando abras manualmente los archivos implicados y los edites para corregirlos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Your file contains a section that looks something like this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El archivo conflictivo contendrá algo como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html
	&lt;div id=&quot;footer&quot;&gt;contact : email.support@github.com&lt;/div&gt;
	=======
	&lt;div id=&quot;footer&quot;&gt;
	  please contact us at support@github.com
	&lt;/div&gt;
	&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html</seg>
      </tuv>
      <tuv lang="ES">
        <seg>&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:index.html
	&lt;div id=&quot;footer&quot;&gt;contact : email.support@github.com&lt;/div&gt;
	=======
	&lt;div id=&quot;footer&quot;&gt;
	  please contact us at support@github.com
	&lt;/div&gt;
	&gt;&gt;&gt;&gt;&gt;&gt;&gt; iss53:index.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This means the version in HEAD (your master branch, because that was what you had checked out when you ran your merge command) is the top part of that block (everything above the `=======`), while the version in your `iss53` branch looks like everything in the bottom part.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Donde nos dice que la versión en HEAD (la rama 'master', la que habias activado antes de lanzar el comando de fusión), contiene lo indicado en la parte superior del bloque (todo lo que está encima de '======='). Y que la versión en 'iss53' contiene el resto, lo indicado en la parte inferior del bloque.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In order to resolve the conflict, you have to either choose one side or the other or merge the contents yourself.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para resolver el conflicto, has de elegir manualmente contenido de uno o de otro lado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For instance, you might resolve this conflict by replacing the entire block with this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por ejemplo, puedes optar por cambiar el bloque, dejandolo tal que:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>&lt;div id=&quot;footer&quot;&gt;
	please contact us at email.support@github.com
	&lt;/div&gt;</seg>
      </tuv>
      <tuv lang="ES">
        <seg>&lt;div id=&quot;footer&quot;&gt;
	please contact us at email.support@github.com
	&lt;/div&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This resolution has a little of each section, and I’ve fully removed the `&lt;&lt;&lt;&lt;&lt;&lt;&lt;`, `=======`, and `&gt;&gt;&gt;&gt;&gt;&gt;&gt;` lines.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esta corrección contiene un poco de ambas partes. Y se han eliminado completamente las líneas `&lt;&lt;&lt;&lt;&lt;&lt;&lt;` , `=======` y `&gt;&gt;&gt;&gt;&gt;&gt;&gt;`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>After you’ve resolved each of these sections in each conflicted file, run `git add` on each file to mark it as resolved.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tras resolver todos los bloques conflictivos, has de lanzar comandos 'git add' para marcar cada archivo modificado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Staging the file marks it as resolved in Git.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Marcar archivos como preparados (staging), indica a Git que sus conflictos han sido resueltos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you want to use a graphical tool to resolve these issues, you can run `git mergetool`, which fires up an appropriate visual merge tool and walks you through the conflicts:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si, en lugar de resolver directamente, prefieres utilizar una herramienta gráfica. Puedes usar el comando 'git mergetool'. Esto arrancará la correspondiente herramienta de visualización y te permirá ir resolviendo conflictos con ella.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git mergetool
	merge tool candidates: kdiff3 tkdiff xxdiff meld gvimdiff opendiff emerge vimdiff
	Merging the files: index.html</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git mergetool
	merge tool candidates: kdiff3 tkdiff xxdiff meld gvimdiff opendiff emerge vimdiff
	Merging the files: index.html</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Normal merge conflict for 'index.html':
	  {local}: modified
	  {remote}: modified
	Hit return to start merge resolution tool (opendiff):</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Normal merge conflict for 'index.html':
	  {local}: modified
	  {remote}: modified
	Hit return to start merge resolution tool (opendiff):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you want to use a merge tool other than the default (Git chose `opendiff` for me in this case because I ran the command on a Mac), you can see all the supported tools listed at the top after “merge tool candidates”.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si deseas usar una herramienta distinta de la escogida por defecto (en mi caso 'opendiff', porque estoy lanzando el comando en un Mac), puedes escogerla entre la lista de herramientas soportadas mostradas al principio (&quot;merge tool candidates&quot;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Type the name of the tool you’d rather use.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tecleando el nombre de dicha herramienta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In Chapter 7, we’ll discuss how you can change this default value for your environment.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En el capítulo 7 se verá cómo cambiar este valor por defecto de tu entorno de trabajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>After you exit the merge tool, Git asks you if the merge was successful.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tras salir de la herramienta de fusionado, Git preguntará a ver si hemos resuelto todos los conflictos y la fusión ha sido satisfactoria.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you tell the script that it was, it stages the file to mark it as resolved for you.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si le indicas que así ha sido, Git marca como preparado (staged) el archivo que acabamos de modificar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can run `git status` again to verify that all conflicts have been resolved:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En cualquier momento, puedes lanzar el comando 'git status' para ver si ya has resuelto todos los conflictos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git status
	# On branch master
	# Changes to be committed:
	#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)
	#
	#	modified:   index.html
	#</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git status
	# On branch master
	# Changes to be committed:
	#   (use &quot;git reset HEAD &lt;file&gt;...&quot; to unstage)
	#
	#	modified:   index.html
	#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you’re happy with that, and you verify that everything that had conflicts has been staged, you can type `git commit` to finalize the merge commit.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si todo ha ido correctamente, y ves que todos los archivos conflictivos están marcados como preparados, puedes lanzar el comando 'git commit' para terminar de confirmar la fusión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The commit message by default looks something like this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El mensaje de confirmación por defecto será algo parecido a:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Merge branch 'iss53'</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Merge branch 'iss53'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Conflicts:
	  index.html
	#
	# It looks like you may be committing a MERGE.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Conflicts:
	  index.html
	#
	# It looks like you may be committing a MERGE.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg># If this is not correct, please remove the file
	# .git/MERGE_HEAD
	# and try again.</seg>
      </tuv>
      <tuv lang="ES">
        <seg># If this is not correct, please remove the file
	# .git/MERGE_HEAD
	# and try again.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>#</seg>
      </tuv>
      <tuv lang="ES">
        <seg>#</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can modify that message with details about how you resolved the merge if you think it would be helpful to others looking at this merge in the future — why you did what you did, if it’s not obvious.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes modificar este mensaje añadiendo detalles sobre cómo has resuelto la fusión, si lo consideras util para que otros entiendan esta fusión en un futuro. Se trata de indicar porqué has hecho lo que has hecho; a no ser que resulte obvio, claro está.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## Branch Management ##</seg>
      </tuv>
      <tuv lang="ES">
        <seg>## Gestión de ramificaciones ##</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now that you’ve created, merged, and deleted some branches, let’s look at some branch-management tools that will come in handy when you begin using branches all the time.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Ahora que ya has creado, fusionado y borrado algunas ramas, vamos a dar un vistazo a algunas herramientas de gestión muy útiles cuando comienzas a utilizar ramas profusamente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The `git branch` command does more than just create and delete branches.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El comando 'git branch' tiene más funciones que las de crear y borrar ramas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you run it with no arguments, you get a simple listing of your current branches:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si lo lanzas sin argumentos, obtienes una lista de las ramas presentes en tu proyecto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git branch
	  iss53
	* master
	  testing</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git branch
	  iss53
	* master
	  testing</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Notice the `*` character that prefixes the `master` branch: it indicates the branch that you currently have checked out.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Fijate en el carácter '*' delante de la rama 'master': nos indica la rama  activa en este momento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This means that if you commit at this point, the `master` branch will be moved forward with your new work.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si hacemos una confirmación de cambios (commit), esa será la rama que avance.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To see the last commit on each branch, you can run `git branch –v`:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para ver la última confirmación de cambios en cada rama, puedes usar el comando 'git branch -v':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git branch -v
	  iss53   93b412c fix javascript issue
	* master  7a98805 Merge branch 'iss53'
	  testing 782fd34 add scott to the author list in the readmes</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git branch -v
	  iss53   93b412c fix javascript issue
	* master  7a98805 Merge branch 'iss53'
	  testing 782fd34 add scott to the author list in the readmes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Another useful option to figure out what state your branches are in is to filter this list to branches that you have or have not yet merged into the branch you’re currently on.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Otra opción útil para averiguar el estado de las ramas, es filtrarlas y mostrar solo aquellas que han sido fusionadas (o que no lo han sido) con la rama actualmente activa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The useful `--merged` and `--no-merged` options have been available in Git since version 1.5.6 for this purpose.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para ello, Git dispone, desde la versión 1.5.6, las opciones '--merged' y '--no-merged'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To see which branches are already merged into the branch you’re on, you can run `git branch –merged`:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si deseas ver las ramas que han sido fusionadas en la rama activa, puedes lanzar el comando 'git branch --merged':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git branch --merged
	  iss53
	* master</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git branch --merged
	  iss53
	* master</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Because you already merged in `iss53` earlier, you see it in your list.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Aparece la rama 'iss53' porque ya ha sido fusionada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Branches on this list without the `*` in front of them are generally fine to delete with `git branch -d`; you’ve already incorporated their work into another branch, so you’re not going to lose anything.</seg>
      </tuv>
      <tuv lang="ES">
        <seg> Y no lleva por delante el caracter '*' porque todo su contenido ya ha sido incorporado a otras ramas. Podemos borrarla tranquilamente con 'git branch -d', sin miedo a perder nada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To see all the branches that contain work you haven’t yet merged in, you can run `git branch --no-merged`:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para mostrar todas las ramas que contienen trabajos sin fusionar aún, puedes utilizar el comando 'git branch --no-merged':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git branch --no-merged
	  testing</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git branch --no-merged
	  testing</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This shows your other branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto nos muestra la otra rama en el proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Because it contains work that isn’t merged in yet, trying to delete it with `git branch -d` will fail:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Debido a que contiene trabajos sin fusionar aún, al intentarla borrar con 'git branch -d', el comando nos dará un error:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git branch -d testing
	error: The branch 'testing' is not an ancestor of your current HEAD.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git branch -d testing
	error: The branch 'testing' is not an ancestor of your current HEAD.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you are sure you want to delete it, run 'git branch -D testing'.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>If you are sure you want to delete it, run 'git branch -D testing'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you really do want to delete the branch and lose that work, you can force it with `-D`, as the helpful message points out.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si realmente deseas borrar la rama, y perder el trabajo contenido en ella, puedes forzar el borrado con la opción '-D'; tal y como lo indica el mensaje de ayuda.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## Branching Workflows ##</seg>
      </tuv>
      <tuv lang="ES">
        <seg>## Flujos de trabajo ramificados ##</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now that you have the basics of branching and merging down, what can or should you do with them?</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Ahora que ya has visto los procedimientos básicos de ramificación y fusión, ¿qué puedes o qué debes hacer con ellos?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In this section, we’ll cover some common workflows that this lightweight branching makes possible, so you can decide if you would like to incorporate it into your own development cycle.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En este apartado vamos a ver algunos de los flujos de trabajo más comunes, de tal forma que puedas decidir si te gustaría incorporar alguno de ellos a tu ciclo de desarrollo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Long-Running Branches ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Ramas de largo recorrido ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Because Git uses a simple three-way merge, merging from one branch into another multiple times over a long period is generally easy to do.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por la sencillez de la fusión a tres bandas de Git, el fusionar de una rama a otra multitud de veces a lo largo del tiempo es facil de hacer.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This means you can have several branches that are always open and that you use for different stages of your development cycle; you can merge regularly from some of them into others.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto te posibilita tener varias ramas siempre abiertas, e irlas usando en diferentes etapas del ciclo de desarrollo; realizando frecuentes fusiones entre ellas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Many Git developers have a workflow that embraces this approach, such as having only code that is entirely stable in their `master` branch — possibly only code that has been or will be released.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Muchos desarrolladores que usan Git llevan un flujo de trabajo de esta naturaleza, manteniendo en la rama 'master' únicamente el código totalmente estable (el código que ha sido o que va a ser liberado).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>They have another parallel branch named develop or next that they work from or use to test stability — it isn’t necessarily always stable, but whenever it gets to a stable state, it can be merged into `master`.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Teniendo otras ramas paralelas denominadas 'desarrollo' o 'siguiente', en las que trabajan y realizan pruebas. Estas ramas paralelas no suele estar siempre en un estado estable; pero cada vez que sí lo están, pueden ser fusionadas con la rama 'master'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It’s used to pull in topic branches (short-lived branches, like your earlier `iss53` branch) when they’re ready, to make sure they pass all the tests and don’t introduce bugs.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>También es habitual el incorporarle (pull) ramas puntuales (ramas temporales, como la rama 'iss53' del anterior ejemplo) cuando las completamos y estamos seguros de que no van a introducir errores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In reality, we’re talking about pointers moving up the line of commits you’re making.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En realidad, en todo momento estamos hablando simplemente de apuntadores moviendose por la línea temporal de confirmaciones de cambio (commit history).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The stable branches are farther down the line in your commit history, and the bleeding-edge branches are farther up the history (see Figure 3-18).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Las ramas estables apuntan hacia posiciones más antiguas en el registro de confirmaciones. Mientras que las ramas avanzadas, las que van abriendo camino, apuntan hacia posiciones más recientes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0318.png 
Figure 3-18.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0318.png 
Figura 3-18.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>More stable branches are generally farther down the commit history.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Las ramas más estables apuntan hacia posiciones más antiguas en el registro de cambios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It’s generally easier to think about them as work silos, where sets of commits graduate to a more stable silo when they’re fully tested (see Figure 3-19).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Podría ser más sencillo pensar en las ramas como si fueran silos de almacenamiento. Donde grupos de confirmaciones de cambio (commits) van promocionando hacia silos más estables a medida que son probados y depurados (ver Figura 3-19)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0319.png 
Figure 3-19.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0319.png 
Figura 3-19.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It may be helpful to think of your branches as silos.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puede ayudar pensar en las ramas como silos de almacenamiento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can keep doing this for several levels of stability.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Este sistema de trabajo se puede ampliar para diversos grados de estabilidad.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Some larger projects also have a `proposed` or `pu` (proposed updates) branch that has integrated branches that may not be ready to go into the `next` or `master` branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Algunos proyectos muy grandes suelen tener una rama denominada 'propuestas' o 'pu' (proposed updates). Donde suele estar todo aquello integrado desde otras ramas, pero que aún no está listo para ser incorporado a las ramas 'siguiente' o 'master'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The idea is that your branches are at various levels of stability; when they reach a more stable level, they’re merged into the branch above them.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La idea es mantener siempre diversas ramas en diversos grados de estabilidad; pero cuando alguna alcanza un estado más estable, la fusionamos con la rama inmediatamente superior a ella.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Again, having multiple long-running branches isn’t necessary, but it’s often helpful, especially when you’re dealing with very large or complex projects.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Aunque no es obligatorio el trabajar con ramas de larga duración, realmente es práctico y útil. Sobre todo en proyectos largos o complejos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Topic Branches ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Ramas puntuales ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Topic branches, however, are useful in projects of any size.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Las ramas puntuales, en cambio, son útiles en proyectos de cualquier tamaño.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>A topic branch is a short-lived branch that you create and use for a single particular feature or related work.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Una rama puntual es aquella de corta duración que abres para un tema o para una funcionalidad muy concretos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is something you’ve likely never done with a VCS before because it’s generally too expensive to create and merge branches.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Es algo que nunca habrías hecho en otro sistema VCS, debido a los altos costos de crear y fusionar ramas que se suelen dar en esos sistemas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>But in Git it’s common to create, work on, merge, and delete branches several times a day.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Pero en Git, por el contrario, es muy habitual el crear, trabajar con, fusionar y borrar ramas varias veces al día.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You saw this in the last section with the `iss53` and `hotfix` branches you created.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tal y como has visto con las ramas 'iss53' y 'hotfix' que has creado en la sección anterior.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You did a few commits on them and deleted them directly after merging them into your main branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Has hecho unas pocas confirmaciones de cambio en ellas, y luego las has borrado tras fusionarlas con la rama principal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This technique allows you to context-switch quickly and completely — because your work is separated into silos where all the changes in that branch have to do with that topic, it’s easier to see what has happened during code review and such.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esta técnica te posibilita realizar rápidos y completos saltos de contexto. Y, debido a que el trabajo está claramente separado en silos, con todos los cambios de cada tema en su propia rama, te será mucho más sencillo revisar el código y seguir su evolución.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can keep the changes there for minutes, days, or months, and merge them in when they’re ready, regardless of the order in which they were created or worked on.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes mantener los cambios ahí durante minutos, dias o meses; y fusionarlos cuando realmente estén listos. En lugar de verte obligado a fusionarlos en el orden en que fueron creados y comenzaste a trabajar en ellos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Consider an example of doing some work (on `master`), branching off for an issue (`iss91`), working on it for a bit, branching off the second branch to try another way of handling the same thing (`iss91v2`), going back to your master branch and working there for a while, and then branching off there to do some work that you’re not sure is a good idea (`dumbidea` branch).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por ejemplo, puedes realizar cierto trabajo en la rama 'master', ramificar para un problema concreto (rama 'iss91'), trabajar en él un rato, ramificar a una segunda rama para probar otra manera de resolverlo (rama 'iss92v2'), volver a la rama 'master' y trabajar un poco más, y, por último, ramificar temporalmente para probar algo de lo que no estás seguro (rama 'dumbidea').</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Your commit history will look something like Figure 3-20.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El registro de confirmaciones (commit history) será algo parecido a la Figura 3-20.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0320.png 
Figure 3-20.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0320.png 
Figura 3-20.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Your commit history with multiple topic branches.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El registro de confirmaciones con múltiples ramas puntuales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now, let’s say you decide you like the second solution to your issue best (`iss91v2`); and you showed the `dumbidea` branch to your coworkers, and it turns out to be genius.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En este momento, supongamos que te decides por la segunda solución al problema (rama 'iss92v2'); y que, tras mostrar la rama 'dumbidea' a tus compañeros, resulta que les parece una idea genial.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can throw away the original `iss91` branch (losing commits C5 and C6) and merge in the other two.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes descartar la rama 'iss91' (perdiendo las confirmaciones C5 y C6), y fusionar las otras dos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Your history then looks like Figure 3-21.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El registro será algo parecido a la Figura 3-21.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0321.png 
Figure 3-21.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0321.png 
Figura 3-21.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Your history after merging in dumbidea and iss91v2.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El registro tras fusionar 'dumbidea' e 'iss91v2'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It’s important to remember when you’re doing all this that these branches are completely local.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Es importante recordar que, mientras estás haciendo todo esto, todas las ramas son completamente locales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When you’re branching and merging, everything is being done only in your Git repository — no server communication is happening.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cuando ramificas y fusionas, todo se realiza en tu propio repositorio Git. No hay nigún tipo de tráfico con ningún servidor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## Remote Branches ##</seg>
      </tuv>
      <tuv lang="ES">
        <seg>## Ramas Remotas ## </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Remote branches are references to the state of branches on your remote repositories.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Las ramas remotas son referencias al estado de ramas en tus repositorios remotos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>They’re local branches that you can’t move; they’re moved automatically whenever you do any network communication.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Son ramas locales que no puedes mover;  se mueven automáticamente cuando estableces comunicaciones en la red.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Remote branches act as bookmarks to remind you where the branches on your remote repositories were the last time you connected to them.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Las ramas remotas funcionan como marcadores, para recordarte en qué estado se encontraban tus repositorios remotos la última vez que conectaste con ellos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>They take the form `(remote)/(branch)`.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Suelen referenciarse como '(remoto)/(rama)'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For instance, if you wanted to see what the `master` branch on your `origin` remote looked like as of the last time you communicated with it, you would check the `origin/master` branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por ejemplo, si quieres saber cómo estaba la rama 'master' en el remoto 'origin'. Puedes revisar la rama 'origin/master'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you were working on an issue with a partner and they pushed up an `iss53` branch, you might have your own local `iss53` branch; but the branch on the server would point to the commit at `origin/iss53`.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>O si estás trabajando en un problema con un compañero y este envia (push) una rama 'iss53', tu tendrás tu propia rama de trabajo local 'iss53'; pero la rama en el servidor apuntará a la última confirmación (commit) en la rama 'origin/iss53'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This may be a bit confusing, so let’s look at an example.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto puede ser un tanto confuso, pero intentemos aclararlo con un ejemplo. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Let’s say you have a Git server on your network at `git.ourcompany.com`.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Supongamos que tienes un sevidor Git en tu red, en 'git.ourcompany.com'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you clone from this, Git automatically names it `origin` for you, pulls down all its data, creates a pointer to where its `master` branch is, and names it `origin/master` locally; and you can’t move it.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si haces un clón desde ahí, Git automáticamente lo denominará 'origin', traerá (pull) sus datos, creará un apuntador hacia donde esté en ese momento su rama 'master', denominará la copia local 'origin/master'; y será inamovible para tí. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git also gives you your own `master` branch starting at the same place as origin’s `master` branch, so you have something to work from (see Figure 3-22).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Git te proporcionará también tu propia rama 'master', apuntando al mismo lugar que la rama 'master' de 'origin'; siendo en esta última donde podrás trabajar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0322.png 
Figure 3-22.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0322.png 
Figura 3-22.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>A Git clone gives you your own master branch and origin/master pointing to origin’s master branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Un clón Git te proporciona tu propia rama 'master' y otra rama 'origin/master' apuntando a la rama 'master' original.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you do some work on your local master branch, and, in the meantime, someone else pushes to `git.ourcompany.com` and updates its master branch, then your histories move forward differently.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si haces algún trabajo en tu rama 'master' local. Y, al mismo tiempo, alguna otra persona lleva (push) su trabajo al servidor 'git.ourcompany.com', actualizando la rama 'master' de allí. Te encontrarás con que ambos registros avanzan de forma diferente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Also, as long as you stay out of contact with your origin server, your `origin/master` pointer doesn’t move (see Figure 3-23).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Además, mientras no tengas contacto con el servidor, tu apuntador a tu rama 'origin/master' no se moverá (ver Figura 3/23).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0323.png 
Figure 3-23.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0323.png 
Figura 3-23.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Working locally and having someone push to your remote server makes each history move forward differently.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Trabajando localmente y que otra persona esté llevando (push) algo al servidor remoto, hace que cada registro avance de forma distinta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To synchronize your work, you run a `git fetch origin` command.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para sincronizarte, puedes utilizar el comando 'git fetch origin'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This command looks up which server origin is (in this case, it’s `git.ourcompany.com`), fetches any data from it that you don’t yet have, and updates your local database, moving your `origin/master` pointer to its new, more up-to-date position (see Figure 3-24).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Este comando localiza en qué servidor está el origen (en este caso 'git.ourcompany.com'), recupera cualquier dato presente allí que tu no tengas, y actualiza tu base de datos local, moviendo tu rama 'origin/master' para que apunte a esta nueva y más reciente posición (ver Figura 3-24).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0324.png 
Figure 3-24.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0324.png 
Figura 3-24.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The git fetch command updates your remote references.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El comando 'git fetch' actualiza tus referencias remotas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To demonstrate having multiple remote servers and what remote branches for those remote projects look like, let’s assume you have another internal Git server that is used only for development by one of your sprint teams.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para ilustrar mejor el caso de tener múltiples servidores y cómo van las ramas remotas para esos proyectos remotos. Supongamos que tienes otro servidor Git; utilizado solamente para desarrollo, por uno de tus equipos sprint.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This server is at `git.team1.ourcompany.com`.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Un servidor en 'git.team1.ourcompany.com'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can add it as a new remote reference to the project you’re currently working on by running the `git remote add` command as we covered in Chapter 2.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes incluirlo como una nueva referencia remota a tu proyecto actual, mediante el comando 'git remote add', tal y como vimos en el capítulo 2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Name this remote `teamone`, which will be your shortname for that whole URL (see Figure 3-25).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes denominar 'teamone' a este remoto, poniendo este nombre abreviado para la URL (ver Figura 3-25)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0325.png 
Figure 3-25.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0325.png 
Figura 3-25.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Adding another server as a remote.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Añadiendo otro servidor como remoto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now, you can run `git fetch teamone` to fetch everything server has that you don’t have yet.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Ahora, puedes usar el comando 'git fetch teamone' para recuperar todo el contenido del servidor que tu no tenias.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Because that server is a subset of the data your `origin` server has right now, Git fetches no data but sets a remote branch called `teamone/master` to point to the commit that `teamone` has as its `master` branch (see Figure 3-26).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Debido a que dicho servidor es un subconjunto de de los datos del servidor 'origin' que tienes actualmente, Git no recupera (fetch) ningún  dato; simplemente prepara una rama remota llamada 'teamone/master' para apuntar a la confirmación (commit) que 'teamone' tiene en su rama 'master'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0326.png 
Figure 3-26.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0326.png 
Figura 3-26.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You get a reference to teamone’s master branch position locally.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Obtienes una referencia local a la posición en la rama 'master' de 'teamone'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Pushing ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Publicando ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When you want to share a branch with the world, you need to push it up to a remote that you have write access to.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cuando quieres compartir una rama con el resto del mundo, has de llevarla (push) a un remoto donde tengas permisos de escritura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Your local branches aren’t automatically synchronized to the remotes you write to — you have to explicitly push the branches you want to share.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tus ramas locales no se sincronizan automáticamente con los remotos en los que escribes. Sino que tienes que llevar (push) expresamente, cada vez, al remoto las ramas que desees compartir.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>That way, you can use private branches for work you don’t want to share, and push up only the topic branches you want to collaborate on.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>De esta forma, puedes usar ramas privadas para el trabajo que no deseas compartir. Llevando a un remoto tan solo aquellas partes que deseas aportar a los demás.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you have a branch named `serverfix` that you want to work on with others, you can push it up the same way you pushed your first branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si tienes una rama llamada 'serverfix', con la que vas a trabajar en colaboración; puedes llevarla al remoto de la misma forma que llevaste tu primera rama.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Run `git push (remote) (branch)`:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Con el comando 'git push (remoto) (rama)':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git push origin serverfix
	Counting objects: 20, done.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git push origin serverfix
	Counting objects: 20, done.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Compressing objects: 100% (14/14), done.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Compressing objects: 100% (14/14), done.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Writing objects: 100% (15/15), 1.74 KiB, done.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Writing objects: 100% (15/15), 1.74 KiB, done.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Total 15 (delta 5), reused 0 (delta 0)
	To git@github.com:schacon/simplegit.git
	 * [new branch]      serverfix -&gt; serverfix</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Total 15 (delta 5), reused 0 (delta 0)
	To git@github.com:schacon/simplegit.git
	 * [new branch]      serverfix -&gt; serverfix</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is a bit of a shortcut.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto es un poco como un atajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git automatically expands the `serverfix` branchname out to `refs/heads/serverfix:refs/heads/serverfix`, which means, “Take my serverfix local branch and push it to update the remote’s serverfix branch.” We’ll go over the `refs/heads/` part in detail in Chapter 9, but you can generally leave it off.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Git expande automáticamente el nombre de rama 'serverfix' a 'refs/heads/serverfix:refs/heads/serverfix', que significa: &quot;coge mi rama local 'serverfix' y actualiza con ella la rama 'serverfix' del remoto&quot;. Volveremos más tarde sobre el tema de 'refs/heads/', viendolo en detalle en el capítulo 9; aunque puedes ignorarlo por ahora.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can also do `git push origin serverfix:serverfix`, which does the same thing — it says, “Take my serverfix and make it the remote’s serverfix.” You can use this format to push a local branch into a remote branch that is named differently.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>También puedes hacer 'git push origin serverfix:serverfix', que hace lo mismo; es decir: &quot;coge mi 'serverfix' y hazlo el 'serverfix' remoto&quot;. Puedes utilizar este último formato para llevar una rama local a una rama remota con otro nombre distinto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you didn’t want it to be called `serverfix` on the remote, you could instead run `git push origin serverfix:awesomebranch` to push your local `serverfix` branch to the `awesomebranch` branch on the remote project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si no quieres que se llame 'serverfix' en el remoto, puedes lanzar, por ejemplo, 'git push origin serverfix:awesomebranch'; para llevar tu rama 'serverfix' local a la rama 'awesomebranch' en el proyecto remoto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The next time one of your collaborators fetches from the server, they will get a reference to where the server’s version of `serverfix` is under the remote branch `origin/serverfix`:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La próxima vez que tus colaboradores recuperen desde el servidor, obtendrán una referencia a donde la versión de 'serverfix' en el servidor esté bajo la rama remota 'origin/serverfix':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git fetch origin
	remote: Counting objects: 20, done.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git fetch origin
	remote: Counting objects: 20, done.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>remote: Compressing objects: 100% (14/14), done.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>remote: Compressing objects: 100% (14/14), done.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>remote: Total 15 (delta 5), reused 0 (delta 0)
	Unpacking objects: 100% (15/15), done.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>remote: Total 15 (delta 5), reused 0 (delta 0)
	Unpacking objects: 100% (15/15), done.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>From git@github.com:schacon/simplegit
	 * [new branch]      serverfix    -&gt; origin/serverfix</seg>
      </tuv>
      <tuv lang="ES">
        <seg>From git@github.com:schacon/simplegit
	 * [new branch]      serverfix    -&gt; origin/serverfix</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It’s important to note that when you do a fetch that brings down new remote branches, you don’t automatically have local, editable copies of them.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Es importante destacar que cuando recuperas (fetch) nuevas ramas remotas, no obtienes automáticamente una copia editable local de las mismas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In other words, in this case, you don’t have a new `serverfix` branch — you only have an `origin/serverfix` pointer that you can’t modify.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En otras palabras, en este caso, no tienes una nueva rama 'serverfix'. Sino que únicamente tienes un puntero no editable a 'origin/serverfix'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To merge this work into your current working branch, you can run `git merge origin/serverfix`.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para integrar (merge) esto en tu actual rama de trabajo, puedes usar el comando 'git merge origin/serverfix'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you want your own `serverfix` branch that you can work on, you can base it off your remote branch:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y si quieres tener tu propia rama 'serverfix', donde puedas trabajar, puedes crearla directamente basandote en rama remota:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git checkout -b serverfix origin/serverfix
	Branch serverfix set up to track remote branch refs/remotes/origin/serverfix.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git checkout -b serverfix origin/serverfix
	Branch serverfix set up to track remote branch refs/remotes/origin/serverfix.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Switched to a new branch &quot;serverfix&quot;</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Switched to a new branch &quot;serverfix&quot;Switched to a new branch &quot;serverfix&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This gives you a local branch that you can work on that starts where `origin/serverfix` is.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto sí te da una rama local donde puedes trabajar, comenzando donde 'origin/serverfix' estaba en ese momento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Tracking Branches ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Haciendo seguimiento a las ramas ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Checking out a local branch from a remote branch automatically creates what is called a _tracking branch_.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Activando (checkout) una rama local a partir de una rama remota, se crea automáticamente lo que podríamos denominar &quot;una rama de seguimiento&quot; (tracking branch).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Tracking branches are local branches that have a direct relationship to a remote branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Las ramas de seguimiento son ramas locales que tienen una relación directa con alguna rama remota.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you’re on a tracking branch and type git push, Git automatically knows which server and branch to push to.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si estás en una rama de seguimiento y tecleas el comando 'git push', Git sabe automáticamente a qué servidor y a qué rama ha de llevar los contenidos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Also, running `git pull` while on one of these branches fetches all the remote references and then automatically merges in the corresponding remote branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Igualmente, tecleando 'git pull' mientras estamos en una de esas ramas, recupera (fetch) todas las referencias remotas y las fusiona (merge) automáticamente en la correspondiente rama remota.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When you clone a repository, it generally automatically creates a `master` branch that tracks `origin/master`.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cuando clonas un repositorio, este suele crear automáticamente una rama 'master' que hace seguimiento de 'origin/master'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>That’s why `git push` and `git pull` work out of the box with no other arguments.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y es por eso que 'git push' y 'git pull' trabajan directamente, sin necesidad de más argumentos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>However, you can set up other tracking branches if you wish — ones that don’t track branches on `origin` and don’t track the `master` branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Sin embargo, puedes preparar otras ramas de seguimiento si deseas tener unas que no hagan seguimiento de ramas en 'origin' y que no sigan a la rama 'master'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The simple case is the example you just saw, running `git checkout -b [branch] [remotename]/[branch]`.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El ejemplo más simple, es el que acabas de ver al lanzar el comando 'git checkout -b [rama] [nombreremoto]/[rama]'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you have Git version 1.6.2 or later, you can also use the `--track` shorthand:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si tienes la versión 1.6.2 de Git, o superior, puedes utilizar también el parámetro '--track':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git checkout --track origin/serverfix
	Branch serverfix set up to track remote branch refs/remotes/origin/serverfix.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git checkout --track origin/serverfix
	Branch serverfix set up to track remote branch refs/remotes/origin/serverfix.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To set up a local branch with a different name than the remote branch, you can easily use the first version with a different local branch name:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para preparar una rama local con un nombre distinto a la del remoto, puedes utilizar:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git checkout -b sf origin/serverfix
	Branch sf set up to track remote branch refs/remotes/origin/serverfix.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git checkout -b sf origin/serverfix
	Branch sf set up to track remote branch refs/remotes/origin/serverfix.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Switched to a new branch &quot;sf&quot;</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Switched to a new branch &quot;sf&quot;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now, your local branch sf will automatically push to and pull from origin/serverfix.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Así, tu rama local 'sf' va a llevar (push) y traer (pull) hacia o desde 'origin/serverfix'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Deleting Remote Branches ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Borrando ramas remotas ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Suppose you’re done with a remote branch — say, you and your collaborators are finished with a feature and have merged it into your remote’s `master` branch (or whatever branch your stable codeline is in).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Imagina que ya has terminado con una rama remota. Es decir, tanto tu como tus colaboradores habeis completado una determinada funcionalidad y la habeis incorporado (merge) a la rama 'master' en el remoto (o donde quiera que tengais la rama de código estable).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can delete a remote branch using the rather obtuse syntax `git push [remotename] :[branch]`.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes borrar la rama remota utilizando la un tanto confusa sintaxis:  'git push [nombreremoto] :[rama]'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you want to delete your `serverfix` branch from the server, you run the following:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por ejemplo, si quieres borrar la rama 'serverfix' del servidor, puedes utilizar:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git push origin :serverfix
	To git@github.com:schacon/simplegit.git
	 - [deleted]         serverfix</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git push origin :serverfix
	To git@github.com:schacon/simplegit.git
	 - [deleted]         serverfix</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Boom.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y....Boom!.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>No more branch on your server.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La rama en el servidor ha desaparecido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You may want to dog-ear this page, because you’ll need that command, and you’ll likely forget the syntax.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes grabarte a fuego esta página, porque necesitarás ese comando y, lo más probable es que hayas olvidado su sintaxis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>A way to remember this command is by recalling the `git push [remotename] [localbranch]:[remotebranch]` syntax that we went over a bit earlier.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Una manera de recordar este comando es dándonos cuenta de que proviene de la sintaxis 'git push [nombreremoto] [ramalocal]:[ramaremota]'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you leave off the `[localbranch]` portion, then you’re basically saying, “Take nothing on my side and make it be `[remotebranch]`.”</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si omites la parte '[ramalocal]', lo que estás diciendo es: &quot;no cojas nada de mi lado y haz con ello [ramaremota]&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## Rebasing ##</seg>
      </tuv>
      <tuv lang="ES">
        <seg>## Reorganizando el trabajo realizado ##</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In Git, there are two main ways to integrate changes from one branch into another: the `merge` and the `rebase`.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En Git tenemos dos formas de integrar cambios de una rama en otra: la fusión (merge) y la reorganización (rebase).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In this section you’ll learn what rebasing is, how to do it, why it’s a pretty amazing tool, and in what cases you won’t want to use it.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En esta sección vas a aprender en qué consiste la reorganización, como utilizarla, por qué es una herramienta sorprendente y en qué casos no es conveniente utilizarla.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### The Basic Rebase ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Reorganización básica ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you go back to an earlier example from the Merge section (see Figure 3-27), you can see that you diverged your work and made commits on two different branches.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Volviendo al ejemplo anterior, en la sección sobre fusiones (ver Figura 3-27), puedes ver que has separado  tu trabajo y realizado confirmaciones (commit) en dos ramas diferentes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0327.png 
Figure 3-27.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0327.png 
Figura 3-27.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Your initial diverged commit history.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El registro de confirmaciones inicial.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The easiest way to integrate the branches, as we’ve already covered, is the `merge` command.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La manera más sencilla de integrar ramas, tal y como hemos visto, es el comando 'git merge'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It performs a three-way merge between the two latest branch snapshots (C3 and C4) and the most recent common ancestor of the two (C2), creating a new snapshot (and commit), as shown in Figure 3-28.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Realiza una fusión a tres bandas entre las dos últimas instantáneas de cada rama (C3 y C4) y el ancestro común a ambas (C2); creando una nueva instantánea (snapshot)  y la correspondiente confirmación (commit), según se muestra en la Figura 3-28.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0328.png 
Figure 3-28.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0328.png 
Figura 3-28.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Merging a branch to integrate the diverged work history.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Fusionando una rama para integrar el registro de trabajos divergentes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>However, there is another way: you can take the patch of the change that was introduced in C3 and reapply it on top of C4.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Aunque también hay otra forma de hacerlo: puedes coger los cambios introducidos en C3 y reaplicarlos encima de C4.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In Git, this is called _rebasing_.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto es lo que en Git llamamos _reorganizar_.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>With the `rebase` command, you can take all the changes that were committed on one branch and replay them on another one.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Con el comando 'git rebase', puedes coger todos los cambios confirmados en una rama, y reaplicarlos sobre otra.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In this example, you’d run the following:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por ejemplo, puedes lanzar los comandos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git checkout experiment
	$ git rebase master
	First, rewinding head to replay your work on top of it...
	Applying: added staged command</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git checkout experiment
	$ git rebase master
	First, rewinding head to replay your work on top of it...
	Applying: added staged command</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It works by going to the common ancestor of the two branches (the one you’re on and the one you’re rebasing onto), getting the diff introduced by each commit of the branch you’re on, saving those diffs to temporary files, resetting the current branch to the same commit as the branch you are rebasing onto, and finally applying each change in turn.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Haciendo que Git: vaya al ancestro común de ambas ramas (donde estás actualmente y de donde quieres reorganizar), saque las diferencias introducidas por cada confirmación en la rama donde estás, guarde esas diferencias en archivos temporales, reinicie (reset) la rama actual hasta llevarla a la misma confirmación en la rama de donde quieres reorganizar, y, finalmente, vuelva a aplicar ordenadamente los cambios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Figure 3-29 illustrates this process.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El proceso se muestra en la Figura 3-29.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0329.png 
Figure 3-29.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0329.png 
Figura 3-29.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Rebasing the change introduced in C3 onto C4.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Reorganizando sobre C4 los cambios introducidos en C3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>At this point, you can go back to the master branch and do a fast-forward merge (see Figure 3-30).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En este momento, puedes volver a la rama 'master' y hacer una fusión con avance rápido (fast-forward merge). (ver Figura 3-30)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0330.png 
Figure 3-30.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0330.png 
Figura 3-30.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Fast-forwarding the master branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Avance rápido de la rama 'master'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now, the snapshot pointed to by C3 is exactly the same as the one that was pointed to by C5 in the merge example.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Así, la instantánea apuntada por C3 aquí es exactamente la misma apuntada por C5 en el ejemplo de la fusión.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>There is no difference in the end product of the integration, but rebasing makes for a cleaner history.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>No hay ninguna diferencia en el resultado final de la integración, pero el haberla hecho reorganizando nos deja un registro más claro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you examine the log of a rebased branch, it looks like a linear history: it appears that all the work happened in series, even when it originally happened in parallel.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si examinas el registro de una rama reorganizada, este aparece siempre como un registro lineal: como si todo el trabajo se hubiera realizado en series, aunque realmente se haya hecho en paralelo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Often, you’ll do this to make sure your commits apply cleanly on a remote branch — perhaps in a project to which you’re trying to contribute but that you don’t maintain.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Habitualmente, optarás por esta vía cuando quieras estar seguro de que tus confirmaciones de cambio (commits) se pueden aplicar limpiamente sobre una rama remota; posiblemente, en un proyecto donde estés intentando colaborar, pero lleves tu el mantenimiento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In this case, you’d do your work in a branch and then rebase your work onto `origin/master` when you were ready to submit your patches to the main project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En casos como esos, puedes trabajar sobre una rama y luego reorgainzar lo realizado en la rama 'origin/master' cuando lo tengas todo listo para enviarlo al proyecto principal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>That way, the maintainer doesn’t have to do any integration work — just a fast-forward or a clean apply.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>De esta forma, la persona que mantiene el proyecto no necesitará hacer ninguna integración con tu trabajo; le bastará con un avance rápido o una incorporación limpia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Note that the snapshot pointed to by the final commit you end up with, whether it’s the last of the rebased commits for a rebase or the final merge commit after a merge, is the same snapshot — it’s only the history that is different.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cabe destacar que la instantánea (snapshot) apuntada por la confirmación (commit) final, tanto si es producto de una regorganización (rebase) como si lo es de una fusión (merge), es exactamente la misma instantánea. Lo único diferente es el registro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Rebasing replays changes from one line of work onto another in the order they were introduced, whereas merging takes the endpoints and merges them together.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La reorganización vuelve a aplicar cambios de una rama de trabajo sobre otra rama, en el mismo orden en que fueron introducidos en la primera. Mientras que la fusión combina entre sí los dos puntos finales de ambas ramas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### More Interesting Rebases ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Algunas otras reorganizaciones interesantes ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can also have your rebase replay on something other than the rebase branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>También puedes aplicar una reorganización (rebase) sobre otra cosa además de sobre la rama de reorganización.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Take a history like Figure 3-31, for example.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por ejemplo, sea un registro como el de la Figura 3-31.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You branched a topic branch (`server`) to add some server-side functionality to your project, and made a commit.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Has ramificado a una rama puntual ('server') para añadir algunas funcionalidades al proyecto, y luego has confirmado los cambios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Then, you branched off that to make the client-side changes (`client`) and committed a few times.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Despues, vuelves a la rama original para hacer algunos cambios en la parte cliente (rama 'client'), y confirmas también esos cambios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Finally, you went back to your server branch and did a few more commits.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por último, vuelves sobre la rama 'server' y haces algunos cambios más.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0331.png 
Figure 3-31.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0331.png 
Figura 3-31.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>A history with a topic branch off another topic branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Un registro con una rama puntual sobre otra rama puntual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Suppose you decide that you want to merge your client-side changes into your mainline for a release, but you want to hold off on the server-side changes until it’s tested further.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Imagina que decides incorporar tus cambios de la parte cliente sobre el proyecto principal, para hacer un lanzamiento de versión; pero no quieres lanzar aún los cambios de la parte server porque no están aún suficientemente probados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can take the changes on client that aren’t on server (C8 and C9) and replay them on your master branch by using the `--onto` option of `git rebase`:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes coger los cambios del cliente que no estan en server (C8 y C9), y reaplicarlos sobre tu rama principal usando la opción '--onto' del comando 'git rebase':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git rebase --onto master server client</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git rebase --onto master server client</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This basically says, “Check out the client branch, figure out the patches from the common ancestor of the `client` and `server` branches, and then replay them onto `master`.” It’s a bit complex; but the result, shown in Figure 3-32, is pretty cool.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto viene a decir: &quot;Activa la rama 'client', averigua los cambios desde el ancestro común entre las ramas 'client' y 'server', y aplicalos en la rama 'master'. Puede parecer un poco complicado, pero los resultados, mostrados en la Figura 3-32, son realmente interesantes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0332.png 
Figure 3-32.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0332.png 
Figura 3-32.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Rebasing a topic branch off another topic branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Reorganizando una rama puntual fuera de otra rama puntual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now you can fast-forward your master branch (see Figure 3-33):</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y, tras esto, ya puedes avanzar la rama principal (ver Figura 3-33):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git checkout master
	$ git merge client</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git checkout master
	$ git merge client</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0333.png 
Figure 3-33.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0333.png 
Figura 3-33.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Fast-forwarding your master branch to include the client branch changes.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Avance rápido de tu rama 'master', para incluir los cambios de la rama 'client'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Let’s say you decide to pull in your server branch as well.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Ahora supongamos que decides traerlos (pull) también sobre tu rama 'server'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can rebase the server branch onto the master branch without having to check it out first by running `git rebase [basebranch] [topicbranch]` — which checks out the topic branch (in this case, `server`) for you and replays it onto the base branch (`master`):</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes reorganizar (rebase) la rama 'server' sobre la rama 'master' sin necesidad siquiera de comprobarlo previamente, usando el comando 'git rebase [ramabase] [ramapuntual]'. El cual activa la rama puntual ('server' en este caso) y la aplica sobre la rama base ('master' en este caso):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git rebase master server</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git rebase master server</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This replays your `server` work on top of your `master` work, as shown in Figure 3-34.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto vuelca el trabajo de 'server' sobre el de 'master', tal y como se muestra en la Figura 3-34.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0334.png 
Figure 3-34.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0334.png 
Figura 3-34.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Rebasing your server branch on top of your master branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Reorganizando la rama 'server' sobre la rama 'branch'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Then, you can fast-forward the base branch (`master`):</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Después, puedes avanzar rápidamente la rama base ('master'):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git checkout master
	$ git merge server</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git checkout master
	$ git merge server</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can remove the `client` and `server` branches because all the work is integrated and you don’t need them anymore, leaving your history for this entire process looking like Figure 3-35:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y por último puedes eliminar las ramas 'client' y 'server' porque ya todo su contenido ha sido integrado y no las vas a necesitar más. Dejando tu registro tras todo este proceso tal y como se muestra en la Figura 3-35:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git branch -d client
	$ git branch -d server</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git branch -d client
	$ git branch -d server</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0335.png 
Figure 3-35.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0335.png 
Figura 3-35.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Final commit history.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Registro final de confirmaciones de cambio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### The Perils of Rebasing ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Los peligros de la reorganización ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Ahh, but the bliss of rebasing isn’t without its drawbacks, which can be summed up in a single line:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Ahh...., pero la dicha de la reorganización no la alcanzamos sin sus contrapartidas: </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>**Do not rebase commits that you have pushed to a public repository.**</seg>
      </tuv>
      <tuv lang="ES">
        <seg>**Nunca reorganices confirmaciones de cambio (commits) que hayas enviado (push) a un repositorio público.**</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you follow that guideline, you’ll be fine.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Siguiendo esta recomendación, no tendrás problemas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you don’t, people will hate you, and you’ll be scorned by friends and family.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Pero si no la sigues, la gente te odiará y serás despreciado por tus familiares y amigos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When you rebase stuff, you’re abandoning existing commits and creating new ones that are similar but different.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cuando reorganizas algo, estás abandonando las confirmaciones de cambio ya creadas y estás creando unas nuevas; que son similares, pero diferentes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you push commits somewhere and others pull them down and base work on them, and then you rewrite those commits with `git rebase` and push them up again, your collaborators will have to re-merge their work and things will get messy when you try to pull their work back into yours.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si envias (push) confirmaciones (commits) a alguna parte, y otros las recogen (pull) de allí. Y después vas tu y las reescribes con 'git rebase' y las vuelves a enviar (push) de nuevo. Tus colaboradores tendrán que refusionar (re-merge) su trabajo  y todo se volverá tremendamente complicado cuando intentes recoger (pull) su trabajo de vuelta sobre el tuyo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Let’s look at an example of how rebasing work that you’ve made public can cause problems.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Vamos a verlo con un ejemplo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Suppose you clone from a central server and then do some work off that.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Imaginate que haces un clon desde un servidor central, y luego trabajas sobre él.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Your commit history looks like Figure 3-36.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tu registro de cambios puede ser algo como lo de la Figura 3-36.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0336.png 
Figure 3-36.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0336.png 
Figura 3-36.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Clone a repository, and base some work on it.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Clonar un repositorio y trabajar sobre él.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now, someone else does more work that includes a merge, and pushes that work to the central server.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Ahora, otra persona trabaja también sobre ello, realiza una fusión (merge) y lleva (push) su trabajo al servidor central.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You fetch them and merge the new remote branch into your work, making your history look something like Figure 3-37.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tu te traes (fetch) sus trabajos y los fusionas (merge) sobre una nueva rama en tu trabajo. Quedando tu registro de confirmaciones como en la Figura 3-37.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0337.png 
Figure 3-37.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0337.png 
Figura 3-37.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Fetch more commits, and merge them into your work.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Traer (fetch) algunas confirmaciones de cambio (commits) y fusionarlas (merge) sobre tu trabajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Next, the person who pushed the merged work decides to go back and rebase their work instead; they do a `git push --force` to overwrite the history on the server.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>A continuación, la persona que habia llevado cambios al servidor central decide retroceder y reorganizar su trabajo; haciendo un 'git push --force' para sobreescribir el registro en el servidor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You then fetch from that server, bringing down the new commits.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tu te traes (fetch) esos nuevos cambios desde el servidor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0338.png 
Figure 3-38.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0338.png 
Figura 3-38.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Someone pushes rebased commits, abandoning commits you’ve based your work on.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Alguien envia (push) confirmaciones (commits) reorganizadas, abandonando las confirmaciones en las que tu habias basado tu trabajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>At this point, you have to merge this work in again, even though you’ve already done so.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En ese momento, tu te ves obligado a fusionar (merge) tu trabajo de nuevo, aunque creias que ya lo habias hecho antes.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Rebasing changes the SHA-1 hashes of these commits so to Git they look like new commits, when in fact you already have the C4 work in your history (see Figure 3-39).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La reorganización cambia los resumenes (hash) SHA-1 de esas confirmaciones (commits), haciendo que Git se crea que son nuevas confirmaciones. Cuando realmente tu ya tenias el trabajo de C4 en tu registro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0339.png 
Figure 3-39.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0339.png 
Figura 3-39.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You merge in the same work again into a new merge commit.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Vuelves a fusionar el mismo trabajo en una nueva fusión confirmada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You have to merge that work in at some point so you can keep up with the other developer in the future.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Te ves obligado a fusionar (merge) ese trabajo en algún punto, para poder seguir adelante con otros desarrollos en el futuro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>After you do that, your commit history will contain both the C4 and C4' commits, which have different SHA-1 hashes but introduce the same work and have the same commit message.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tras todo esto, tu registro de confirmaciones de cambio (commit history) contendrá tanto la confirmación C4 como la C4'; teniendo ambas el mismo contenido y el mismo mensaje de confirmación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you run a `git log` when your history looks like this, you’ll see two commits that have the same author date and message, which will be confusing.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si lanzas un 'git log' en un registro como este, verás dos confirmaciones  con el mismo autor, misma fecha y mismo mensaje. Lo que puede llevar a confusiones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Furthermore, if you push this history back up to the server, you’ll reintroduce all those rebased commits to the central server, which can further confuse people.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Es más, si luego tu envias (push) ese registro de vuelta al servidor, vas a introducir todas esas confirmaciones reorganizadas en el servidor central. Lo que puede confundir aún más a la gente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you treat rebasing as a way to clean up and work with commits before you push them, and if you only rebase commits that have never been available publicly, then you’ll be fine.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si solo usas la reorganización como una vía para hacer limpieza y organizar confirmaciones de cambio antes de enviarlas, y si únicamente reorganizas confirmaciones que nunca han sido públicas. Entonces no tendrás problemas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you rebase commits that have already been pushed publicly, and people may have based work on those commits, then you may be in for some frustrating trouble.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si, por el contrario, reorganizas confirmaciones que alguna vez han sido públicas y otra gente ha basado su trabajo  en ellas. Entonces estarás en un aprieto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>We’ve covered basic branching and merging in Git.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Hemos visto los procedimientos básicos de ramificación (branching) y fusión (merging) en Git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You should feel comfortable creating and switching to new branches, switching between branches and merging local branches together.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>A estas alturas, te sentirás cómodo creando nuevas ramas (branch), saltando (checkout) entre ramas para trabajar y fusionando (merge) ramas entre ellas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You should also be able to share your branches by pushing them to a shared server, working with others on shared branches and rebasing your branches before they are shared.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>También conocerás cómo compatir tus ramas enviandolas (push) a un servidor compartido, cómo trabajar colaborativamente en ramas compartidas, y cómo reorganizar (rebase) tus ramas antes de compartirlas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg># Git on the Server #</seg>
      </tuv>
      <tuv lang="ES">
        <seg># Git en un servidor #</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>At this point, you should be able to do most of the day-to-day tasks for which you’ll be using Git.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>A estas alturas, ya podrás realizar la mayor parte de las tareas habituales trabajando con Git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>However, in order to do any collaboration in Git, you’ll need to have a remote Git repository.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Pero, para poder colaborar, necesitarás tener un repositorio remoto de Git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Although you can technically push changes to and pull changes from individuals’ repositories, doing so is discouraged because you can fairly easily confuse what they’re working on if you’re not careful.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Aunque técnicamente es posible enviar (push) y recibir (pull) cambios directamente a o desde repositorios individuales, no es muy recomendable trabajar así por la gran facilidad de confundirte si no andas con sumo cuidado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Furthermore, you want your collaborators to be able to access the repository even if your computer is offline — having a more reliable common repository is often useful.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Es más, si deseas que tus colaboradores puedan acceder a tu repositorio, incluso cuando tu ordenador este apagado, puede ser de gran utilidad disponer de un repositorio común fiable.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Therefore, the preferred method for collaborating with someone is to set up an intermediate repository that you both have access to, and push to and pull from that.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En este sentido, el método más recomendable para colaborar con otra persona es preparar un repositorio intermedio donde ambos tengais acceso, enviando (push) y recibiendo (pull) a o desde allí.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>We’ll refer to this repository as a &quot;Git server&quot;; but you’ll notice that it generally takes a tiny amount of resources to host a Git repository, so you’ll rarely need to use an entire server for it.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Nos referiremos a este repositorio como &quot;servidor Git&quot;; pero en seguida te darás cuenta de que solo se necesitan unos pocos recursos para albergar un repositorio Git, y, por tanto, no será necesario utilizar todo un servidor entero para él.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Running a Git server is simple.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Disponer un servidor Git es simple.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>First, you choose which protocols you want your server to communicate with.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Lo primero, has de elegir el/los protocolo/s que deseas para comunicarte con el servidor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The first section of this chapter will cover the available protocols and the pros and cons of each.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La primera parte de este capítulo cubrirá la gama de protocolos disponibles, detallando los pros y contras de cada uno de ellos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The next sections will explain some typical setups using those protocols and how to get your server running with them.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Las siguientes secciones explicarán algunas de las típicas configuraciones utilizando esos protocolos, y cómo podemos poner en marcha nuestro servidor con ellos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Last, we’ll go over a few hosted options, if you don’t mind hosting your code on someone else’s server and don’t want to go through the hassle of setting up and maintaining your own server.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por último, repasaremos algunas opciones albergadas on-line; por si no te preocupa guardar tu código en servidores de terceros y no deseas enredarte preparando y manteniendo tu propio servidor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you have no interest in running your own server, you can skip to the last section of the chapter to see some options for setting up a hosted account and then move on to the next chapter, where we discuss the various ins and outs of working in a distributed source control environment.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si este es el caso, si no tienes interés de tener tu propio servidor, puedes saltar directamente a la última sección del capítulo; donde verás algunas opciones para dar de alta una cuenta albergada. Y después puedes moverte al capítulo siguiente, donde vamos a discutir algunos de los mecanismos para trabajar en un entorno distribuido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>A remote repository is generally a _bare repository_ — a Git repository that has no working directory.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Un repositorio remoto es normalmente un _repositorio básico mínimo_, un repositorio Git sin carpeta de trabajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Because the repository is only used as a collaboration point, there is no reason to have a snapshot checked out on disk; it’s just the Git data.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Debido a que dicho repositorio se va a utilizar exclusivamente como un punto de colaboración, no tiene sentido el tener una instantánea de trabajo (snapshot) activa en el disco (checkout); nos basta con tener solamente los propios datos Git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In the simplest terms, a bare repository is the contents of your project’s `.git` directory and nothing else.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Básicamente, un repositorio básico mínimo son los contenidos de la carpeta '.git', tal cual, sin nada más. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## The Protocols ##</seg>
      </tuv>
      <tuv lang="ES">
        <seg>## Los Protocolos ##</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git can use four major network protocols to transfer data: Local, Secure Shell (SSH), Git, and HTTP.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Git puede usar cuatro protocolos principales para transferir datos: Local, Secure Shell (SSH), Git y HTTP.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Here we’ll discuss what they are and in what basic circumstances you would want (or not want) to use them.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Vamos a ver en qué consisten y las circunstancias en que querrás (o no) utilizar cada uno de ellos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It’s important to note that with the exception of the HTTP protocols, all of these require Git to be installed and working on the server.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Merece destacar que, con la excepción del protocolo HTTP, todos los demás protocolos requieren que Git esté instalado y operativo en el servidor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Local Protocol ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Procolo Local ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The most basic is the _Local protocol_, in which the remote repository is in another directory on disk.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El más básico es el _Protocolo Local_, donde el repositorio remoto es simplemente otra carpeta en el disco.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is often used if everyone on your team has access to a shared filesystem such as an NFS mount, or in the less likely case that everyone logs in to the same computer.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Se utiliza habitualmente cuando todos los miembros del equipo tienen acceso a un mismo sistema de archivos, como por ejemplo un punto de montaje NFS, o en los casos en que todos se conectan al mismo ordenador.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The latter wouldn’t be ideal, because all your code repository instances would reside on the same computer, making a catastrophic loss much more likely.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Aunque este último caso no es precisamente el ideal, ya que todas las instancias del repositorio estarían en la misma máquina; aumentando las posibilidades de una pérdida catastrófica.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you have a shared mounted filesystem, then you can clone, push to, and pull from a local file-based repository.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si dispones de un sistema de archivos compartido, podrás clonar (clone), enviar (push) y recibir (pull) a/desde repositorios locales basado en archivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To clone a repository like this or to add one as a remote to an existing project, use the path to the repository as the URL.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para clonar un repositorio como estos, o para añadirlo como remoto a un proyecto ya existente, usa el camino (path) del repositorio como su URL.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For example, to clone a local repository, you can run something like this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por ejemplo, para clonar un repositorio local, puedes usar algo como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git clone /opt/git/project.git</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git clone /opt/git/project.git</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Or you can do this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>O como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git clone file:///opt/git/project.git</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git clone file:///opt/git/project.git</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git operates slightly differently if you explicitly specify `file://` at the beginning of the URL.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Git trabaja ligeramente distinto si indicas 'file://' de forma explícita al comienzo de la URL.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you just specify the path, Git tries to use hardlinks or directly copy the files it needs.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si escribes simplemente el camino, Git intentará usar enlaces rígidos (hardlinks) o copiar directamente los archivos que necesita.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you specify `file://`, Git fires up the processes that it normally uses to transfer data over a network which is generally a lot less efficient method of transferring the data.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si escribes con el prefijo 'file://', Git lanza el proceso que usa habitualmente para transferir datos sobre una red; proceso que suele ser mucho menos eficiente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The main reason to specify the `file://` prefix is if you want a clean copy of the repository with extraneous references or objects left out — generally after an import from another version-control system or something similar (see Chapter 9 for maintenance tasks).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La única razón que puedes tener para indicar expresamente el prefijo 'file://' puede ser el querer una copia limpia del repositorio, descartando referencias u objetos superfluos. Normalmente, tras haberlo importado desde otro sistema de control de versiones o algo similar (ver el Capítulo 9 sobre tareas de mantenimiento).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>We’ll use the normal path here because doing so is almost always faster.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Habitualmente, usaremos el camino (path) normal por ser casi siempre más rápido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To add a local repository to an existing Git project, you can run something like this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para añadir un repositorio local a un proyecto Git existente, puedes usar algo como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git remote add local_proj /opt/git/project.git</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git remote add local_proj /opt/git/project.git</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Then, you can push to and pull from that remote as though you were doing so over a network.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Con lo que podrás enviar (push) y recibir (pull) desde dicho remoto exactamente de la misma forma a como lo harías a través de una red.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>#### The Pros ####</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Ventajas ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The pros of file-based repositories are that they’re simple and they use existing file permissions and network access.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Las ventajas de los repositorios basados en carpetas y archivos, son su simplicicidad y el aprovechamiento de los permisos preexistentes de acceso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you already have a shared filesystem to which your whole team has access, setting up a repository is very easy.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si tienes un sistema de archivo compartido que todo el equipo pueda usar, preparar un repositorio es muy sencillo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You stick the bare repository copy somewhere everyone has shared access to and set the read/write permissions as you would for any other shared directory.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Simplemente pones el repositorio básico en algún lugar donde todos tengan acceso a él y ajustas los permisos de lectura/escritura según proceda, tal y como lo harías para preparar cualquier otra carpeta compartida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>We’ll discuss how to export a bare repository copy for this purpose in the next section, “Getting Git on a Server.”</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En la próxima sección, &quot;Disponiendo Git en un servidor&quot;, veremos cómo exportar un repositorio básico para conseguir esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is also a nice option for quickly grabbing work from someone else’s working repository.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Este camino es también util para recuperar rápidamente el contenido del repositorio de trabajo de alguna otra persona.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you and a co-worker are working on the same project and they want you to check something out, running a command like `git pull /home/john/project` is often easier than them pushing to a remote server and you pulling down.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si tu y otra persona estais trabajando en el mismo proyecto y ella quiere mostrarte algo, el usar un comando tal como 'git pull /home/john/project' suele ser más sencillo que el que esa persona te lo envie (push) a un servidor remoto y luego tú lo recojas (pull) desde allí.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>#### The Cons ####</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Desventajas ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The cons of this method are that shared access is generally more difficult to set up and reach from multiple locations than basic network access.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La principal desventaja de los repositorios basados en carpetas y archivos es su dificultad de acceso desde distintas ubicaciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you want to push from your laptop when you’re at home, you have to mount the remote disk, which can be difficult and slow compared to network-based access.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por ejemplo, si quieres enviar (push) desde tu portátil cuando estás en casa, primero tienes que montar el disco remoto; lo cual puede ser dificil y lento, en comparación con un acceso basado en red.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It’s also important to mention that this isn’t necessarily the fastest option if you’re using a shared mount of some kind.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cabe destacar también que una carpeta compartida no es precisamente la opción más rápida.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>A local repository is fast only if you have fast access to the data.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Un repositorio local es rápido solamente en aquellas ocasiones en que tienes un acceso rápido a él.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>A repository on NFS is often slower than the repository over SSH on the same server, allowing Git to run off local disks on each system.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Normalmente un repositorio sobre NFS es más lento que un repositorio SSH en el mismo servidor, asumiendo que las pruebas se hacen con Git sobre discos locales en ambos casos. </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### The SSH Protocol ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### El Procotolo SSH ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Probably the most common transport protocol for Git is SSH.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Probablemente, SSH sea el protocolo más habitual para Git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is because SSH access to servers is already set up in most places — and if it isn’t, it’s easy to do.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Debido a disponibilidad en la mayor parte de los servidores; (pero, si no lo estuviera disponible, además es sencillo habilitarlo).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>SSH is also the only network-based protocol that you can easily read from and write to.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por otro lado, SSH es el único protocolo de red con el que puedes facilmente tanto leer como escribir.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The other two network protocols (HTTP and Git) are generally read-only, so even if you have them available for the unwashed masses, you still need SSH for your own write commands.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Los otros dos protocolos de red (HTTP y Git) suelen ser normalmente protocolos de solo-lectura; de tal forma que, aunque los tengas disponibles para el público en general, sigues necesitando SSH para tu propio uso en escritura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>SSH is also an authenticated network protocol; and because it’s ubiquitous, it’s generally easy to set up and use.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Otra ventaja de SSH es el su mecanismo de autentificación, sencillo de habilitar y de usar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To clone a Git repository over SSH, you can specify ssh:// URL like this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para clonar un repositorio a través de SSH, puedes indicar una URL ssh:// tal como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git clone ssh://user@server:project.git</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git clone ssh://user@server:project.git</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Or you can not specify a protocol — Git assumes SSH if you aren’t explicit:
	
	$ git clone user@server:project.git</seg>
      </tuv>
      <tuv lang="ES">
        <seg>O puedes prescindir del protocolo; Git asume SSH si no indicas nada expresamente: $ git clone user@server:project.git</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can also not specify a user, and Git assumes the user you’re currently logged in as.</seg>
      </tuv>
      <tuv lang="ES">
        <seg> Pudiendo asimismo prescindir del usuario; en cuyo caso Git asume el usuario con el que estés conectado en ese momento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The pros of using SSH are many.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El uso de SSH tiene múltiples ventajas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>First, you basically have to use it if you want authenticated write access to your repository over a network.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En primer lugar, necesitas usarlo si quieres un acceso de escritura autentificado a tu repositorio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Second, SSH is relatively easy to set up — SSH daemons are commonplace, many network admins have experience with them, and many OS distributions are set up with them or have tools to manage them.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En segundo lugar, SSH es sencillo de habilitar. Los demonios (daemons) SSH son de uso común, muchos administradores de red tienen experiencia con ellos y muchas distribuciones del SO los traen predefinidos o tienen herramientas para gestionarlos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Next, access over SSH is secure — all data transfer is encrypted and authenticated.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Además, el acceso a través de SSH es seguro, estando todas las transferencias encriptadas y autentificadas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Last, like the Git and Local protocols, SSH is efficient, making the data as compact as possible before transferring it.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y, por último, al igual que los procolos Git y Local, SSH es eficiente, comprimiendo los datos lo más posible antes de transferirlos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The negative aspect of SSH is that you can’t serve anonymous access of your repository over it.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El aspecto negativo de SSH es su imposibilidad para dar acceso anónimo al repositorio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>People must have access to your machine over SSH to access it, even in a read-only capacity, which doesn’t make SSH access conducive to open source projects.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Todos han de tener configurado un acceso SSH al servidor, incluso aunque sea con permisos de solo lectura; lo que no lo hace recomendable para soportar proyectos abiertos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you’re using it only within your corporate network, SSH may be the only protocol you need to deal with.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si lo usas únicamente dentro de tu red corporativa, posiblemente sea SSH el único procolo que tengas que emplear.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you want to allow anonymous read-only access to your projects, you’ll have to set up SSH for you to push over but something else for others to pull over.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Pero si quieres también habilitar accesos anónimos de solo lectura, tendrás que reservar SSH para tus envios (push) y habilitar algún otro protocolo para las recuperaciones (pull) de los demás.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### The Git Protocol ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### El Protocolo Git ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Next is the Git protocol.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El protocolo Git </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is a special daemon that comes packaged with Git; it listens on a dedicated port (9418) that provides a service similar to the SSH protocol, but with absolutely no authentication.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>es un demonio (daemon) especial, que viene incorporado con Git. Escucha por un puerto dedicado (9418), y nos da un servicio similar al del protocolo SSH; pero sin ningún tipo de autentificación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In order for a repository to be served over the Git protocol, you must create the `git-export-daemon-ok` file — the daemon won’t serve a repository without that file in it — but other than that there is no security.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para que un repositorio pueda exponerse a través del protocolo Git, tienes que crear en él un archivo 'git-export-daemon-ok'; sin este archivo, el demonio no hará disponible el repositorio. Pero, aparte de esto, no hay ninguna otra medida de seguridad.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Either the Git repository is available for everyone to clone or it isn’t.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>O el repositorio está disponible para que cualquiera lo pueda clonar, o no lo está.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This means that there is generally no pushing over this protocol.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Lo cual significa que, normalmente, no se podrá enviar (push) a través de este protocolo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can enable push access; but given the lack of authentication, if you turn on push access, anyone on the internet who finds your project’s URL could push to your project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Aunque realmente si que puedes habilitar el envio, si lo haces, dada la total falta de ningún mecanismo de autentificación, cualquiera que encuentre la URL a tu proyecto en Internet, podrá enviar (push) contenidos a él.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Suffice it to say that this is rare.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Ni que decir tiene que esto solo lo necesitarás en contadas ocasiones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The Git protocol is the fastest transfer protocol available.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El protocolo Git es el más rápido de todos los disponibles.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you’re serving a lot of traffic for a public project or serving a very large project that doesn’t require user authentication for read access, it’s likely that you’ll want to set up a Git daemon to serve your project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si has de servir mucho tráfico de un proyecto público o servir un proyecto muy grande, que no requiera autentificación para leer de él, un demonio Git es la respuesta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It uses the same data-transfer mechanism as the SSH protocol but without the encryption and authentication overhead.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Utiliza los mismos mecanismos de transmisión de datos que el protocolo SSH, pero sin la sobrecarga de la encriptación ni de la autentificación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The downside of the Git protocol is the lack of authentication.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La pega del protocolo Git, es su falta de autentificación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It’s generally undesirable for the Git protocol to be the only access to your project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>No es recomendable tenerlo como único protocolo de acceso a tus proyectos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Generally, you’ll pair it with SSH access for the few developers who have push (write) access and have everyone else use `git://` for read-only access.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Habitualmente, lo combinarás con un acceso SSH para los pocos desarrolladores con acceso de escritura que envien (push) material. Usando 'git://' para los accesos solo-lectura del resto de personas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It’s also probably the most difficult protocol to set up.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por otro lado, es también el protocolo más complicado de implementar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It must run its own daemon, which is custom — we’ll look at setting one up in the “Gitosis” section of this chapter — it requires `xinetd` configuration or the like, which isn’t always a walk in the park.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Necesita activar su propio demonio, (tal y como se explica en la sección &quot;Gitosis&quot;, más adelante, en este capítulo); y necesita configurar 'xinetd' o similar, lo cual no suele estar siempre disponible en el sistema donde estés trabajando.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It also requires firewall access to port 9418, which isn’t a standard port that corporate firewalls always allow.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Requiere además abrir expresamente acceso al puerto 9418 en el cortafuegos, ya que este no es uno de los puertos estandares que suelen estar habitualmente permitidos en los cortafuegos corporativos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Behind big corporate firewalls, this obscure port is commonly blocked.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Normalmente, este oscuro puerto suele estar bloqueado detrás de los cortafuegos corporativos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### The HTTP/S Protocol ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### El protocolo HTTP/S ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Last we have the HTTP protocol.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por último, tenemos el protocolo HTTP.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The beauty of the HTTP or HTTPS protocol is the simplicity of setting it up.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>  Cuya belleza radica en la simplicidad para habilitarlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Basically, all you have to do is put the bare Git repository under your HTTP document root and set up a specific `post-update` hook, and you’re done (See Chapter 7 for details on Git hooks).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Basta con situar el repositorio Git bajo la raiz de los documentos HTTP y preparar el enganche (hook) 'post-update' adecuado. (Ver el Capítulo 7 para detalles sobre los enganches Git.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>At that point, anyone who can access the web server under which you put the repository can also clone your repository.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>A partir de ese momento, cualquiera con acceso al servidor web podrá clonar tu repositorio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To allow read access to your repository over HTTP, do something like this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para permitir acceso a tu repositorio a través de HTTP, puedes hacer algo como esto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ cd /var/www/htdocs/
	$ git clone --bare /path/to/git_project gitproject.git
	$ cd gitproject.git
	$ mv hooks/post-update.sample hooks/post-update
	$ chmod a+x hooks/post-update</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ cd /var/www/htdocs/
	$ git clone --bare /path/to/git_project gitproject.git
	$ cd gitproject.git
	$ mv hooks/post-update.sample hooks/post-update
	$ chmod a+x hooks/post-update</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>That’s all.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y eso es todo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The `post-update` hook that comes with Git by default runs the appropriate command (`git update-server-info`) to make HTTP fetching and cloning work properly.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El enganche 'post-update' que viene de serie con Git se encarga de lanzar el comando adecuado ('git update-server-info') para hacer funcionar la recuperación (fetching) y el clonado (cloning) vía HTTP.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This command is run when you push to this repository over SSH; then, other people can clone via something like</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Este comando se lanza automáticamente cuando envias (push) a este repositorio vía SSh; de tal forma que otras personas puedan clonarlo usando un comando tal que:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git clone http://example.com/gitproject.git</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git clone http://example.com/gitproject.git</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In this particular case, we’re using the `/var/www/htdocs` path that is common for Apache setups, but you can use any static web server — just put the bare repository in its path.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En este caso particular, estamos usando el camino '/var/www/htdocs', habitual en las configuraciones de Apache. Pero puedes utilizar cualquier servidor web estático, sin más que poner el repositorio en su camino.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The Git data is served as basic static files (see Chapter 9 for details about exactly how it’s served).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Los contenidos Git se sirven como archivos estáticos básicos (ver el Capitulo 9 para más detalles sobre servicios).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It’s possible to make Git push over HTTP as well, although that technique isn’t as widely used and requires you to set up complex WebDAV requirements.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Es posible hacer que Git envie (push) a través de HTTP. Pero no se suele usar demasiado, ya que requiere lidiar con los complejos requerimientos de WebDAV.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Because it’s rarely used, we won’t cover it in this book.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y precisamente porque se usa raramente, no lo vamos a cubrir en este libro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you’re interested in using the HTTP-push protocols, you can read about preparing a repository for this purpose at `http://www.kernel.org/pub/software/scm/git/docs/howto/setup-git-server-over-http.txt`.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si estás interesado en utilizar los protocolos HTTP-push, puedes encotrar más información en  `http://www.kernel.org/pub/software/scm/git/docs/howto/setup-git-server-over-http.txt`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>One nice thing about making Git push over HTTP is that you can use any WebDAV server, without specific Git features; so, you can use this functionality if your web-hosting provider supports WebDAV for writing updates to your web site.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La utilidad de habilitar Git para enviar (push) a través de HTTP es la posibilidad de utilizar cualquier servidor WebDAV para ello, sin necesidad de requerimientos específicos para Git. De tal forma que puedes hacerlo incluso a través de tu proveedor de albergue web, si este soporta WebDAV para escribir actualizaciones en tu sitio web.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The upside of using the HTTP protocol is that it’s easy to set up.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La mejor parte del protocolo HTTP es su sencillez de preparación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Running the handful of required commands gives you a simple way to give the world read access to your Git repository.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Simplemente lanzando unos cuantos comandos, dispones de un método sencillo de dar al mundo entero acceso a tu repositorio Git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It takes only a few minutes to do.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En tan solo unos minutos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The HTTP protocol also isn’t very resource intensive on your server.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Además, el procolo HTTP no requiere de grandes recursos en tu servidor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Because it generally uses a static HTTP server to serve all the data, a normal Apache server can serve thousands of files per second on average — it’s difficult to overload even a small server.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por utilizar normalmente un servidor HTTP estático, un servidor Apache estandar puede con un tráfico de miles de archivos por segundo; siendo dificil de sobrecargar incluso con el más pequeño de los servidores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can also serve your repositories read-only over HTTPS, which means you can encrypt the content transfer; or you can go so far as to make the clients use specific signed SSL certificates.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes también servir tus repositorios de solo lectura a través de HTTPS, teniendo así las transferencias encriptadas. O puedes ir más lejos aún, requiriendo el uso de certificados SSL específicos para cada cliente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Generally, if you’re going to these lengths, it’s easier to use SSH public keys; but it may be a better solution in your specific case to use signed SSL certificates or other HTTP-based authentication methods for read-only access over HTTPS.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Aunque, si pretendes ir tan lejos, es más sencillo utilizar claves públicas SSH; pero ahí está la posibilidad, por si en algún caso concreto sea mejor solución el uso de certificados SSL u otros medios de autentificación HTTP para el acceso de solo-lectura a través de HTTPS.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Another nice thing is that HTTP is such a commonly used protocol that corporate firewalls are often set up to allow traffic through this port.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Otro detalle muy util de emplear HTTP, es que, al ser un protocolo de uso común, la mayoría de los cortafuegos corporativos suelen tener habilitado el tráfico a traves de este puerto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The downside of serving your repository over HTTP is that it’s relatively inefficient for the client.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La pega de servir un repositorio a través de HTTP es su relativa ineficiencia para el cliente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It generally takes a lot longer to clone or fetch from the repository, and you often have a lot more network overhead and transfer volume over HTTP than with any of the other network protocols.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Suele requerir mucho más tiempo el clonar o el recuperar (fetch), debido a la mayor carga de procesamiento y  al mayor volumen de transferencia que se da sobre HTTP respecto de otros protocolos de red.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Because it’s not as intelligent about transferring only the data you need — there is no dynamic work on the part of the server in these transactions — the HTTP protocol is often referred to as a _dumb_ protocol.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y precisamente por esto, porque no es tan inteligente y no transfiere solamente los datos imprescindibles, (no hay un trabajo dinámico por parte del servidor), el protocolo HTTP suele ser conocido como el protocolo _estúpido_.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For more information about the differences in efficiency between the HTTP protocol and the other protocols, see Chapter 9.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para más información sobre diferencias de eficiencia entre el protocolo HTTP y los otros protocolos, ver el Capítulo 9.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## Getting Git on a Server ##</seg>
      </tuv>
      <tuv lang="ES">
        <seg>## Poniendo Git en un Servidor ##</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In order to initially set up any Git server, you have to export an existing repository into a new bare repository — a repository that doesn’t contain a working directory.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El primer paso para preparar un servidor Git, es exportar un repositorio existente a un nuevo repositorio básico, a un repositorio sin carpeta de trabajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is generally straightforward to do.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Normalmente suele ser sencillo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In order to clone your repository to create a new bare repository, you run the clone command with the `--bare` option.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tan solo has de utilizar el comando 'clone' con la opción '--bare'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>By convention, bare repository directories end in `.git`, like so:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por convenio, los nombres de los repositorios básicos suelen terminar en '.git', por lo que lanzaremos:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git clone --bare my_project my_project.git
	Initialized empty Git repository in /opt/projects/my_project.git/</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git clone --bare my_project my_project.git
	Initialized empty Git repository in /opt/projects/my_project.git/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The output for this command is a little confusing.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El resultado de este comando es un poco confuso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Since `clone` is basically a `git init` then a `git fetch`, we see some output from the `git init` part, which creates an empty directory.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Como 'clone' es fundamentalmente un 'git init' seguido de un 'git fetch', veremos algunos de los mensajes de la parte 'init', concretamente de la parte en que se crea una carpeta vacia.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The actual object transfer gives no output, but it does happen.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La copia de objetos no da ningún mensaje, pero también se realiza.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You should now have a copy of the Git directory data in your `my_project.git` directory.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tras esto, tendrás una copia de los datos en tu carpeta 'my_project.git'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This is roughly equivalent to something like</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Siendo el proceso mas o menos equivalente a haber realizado:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ cp -Rf my_project/.git my_project.git</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ cp -Rf my_project/.git my_project.git</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>There are a couple of minor differences in the configuration file; but for your purpose, this is close to the same thing.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Realmente hay un par de pequeñas diferencias en el archivo de configuración; pero, a efectos prácticos es casi lo mismo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It takes the Git repository by itself, without a working directory, and creates a directory specifically for it alone.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Se coge el repositorio Git en sí mismo, sin la carpeta de trabajo, y se crea una copia en una nueva carpeta específica para él solo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Putting the Bare Repository on a Server ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Poniendo el repositorio básico en un servidor ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now that you have a bare copy of your repository, all you need to do is put it on a server and set up your protocols.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Ahora que ya tienes una copia básica de tu repositorio, todo lo que te resta por hacer es colocarlo en un servidor y ajustar los protocolos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Let’s say you’ve set up a server called `git.example.com` that you have SSH access to, and you want to store all your Git repositories under the `/opt/git` directory.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Supongamos que has preparado un servidor denominado 'git.example.com', con acceso SSH. Y que quieres guardar todos los repositorios Git bajo la carpeta '/opt/git'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can set up your new repository by copying your bare repository over:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes colocar tu nuevo repositorio simplemente copiandolo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ scp -r my_project.git user@git.example.com:/opt/git</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ scp -r my_project.git user@git.example.com:/opt/git</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>At this point, other users who have SSH access to the same server which has read-access to the `/opt/git` directory can clone your repository by running</seg>
      </tuv>
      <tuv lang="ES">
        <seg>A partir de entonces, cualquier otro usuario con acceso de lectura SSH a la carpeta '/opt/git' del servidor, podrá clonar el repositorio con la orden:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git clone user@git.example.com:/opt/git/my_project.git</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git clone user@git.example.com:/opt/git/my_project.git</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If a user SSHs into a server and has write access to the `/opt/git/my_project.git` directory, they will also automatically have push access.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y cualquier usuario SSH que tenga acceso de escritura a la carpeta '/opt/git/my_project.git', tendrá también automáticamente acceso de volcado (push).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git will automatically add group write permissions to a repository properly if you run the `git init` command with the `--shared` option.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Git añadirá automáticamente permisos de escritura al grupo sobre cualquier repositorio donde lances el comando 'git init' con la opción '--shared'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ ssh user@git.example.com
	$ cd /opt/git/my_project.git
	$ git init --bare --shared</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ ssh user@git.example.com
	$ cd /opt/git/my_project.git
	$ git init --bare --shared</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You see how easy it is to take a Git repository, create a bare version, and place it on a server to which you and your collaborators have SSH access.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Como se vé, es sencillo crear un repositorio básico a partir de un repositorio Git, y ponerlo en un servidor donde tanto tú como tus colaboradores tengais acceso SSH.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now you’re ready to collaborate on the same project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Ahora ya estás preparado para trabajar con ellos en el proyecto común.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It’s important to note that this is literally all you need to do to run a useful Git server to which several people have access — just add SSH-able accounts on a server, and stick a bare repository somewhere that all those users have read and write access to.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Es importante destacar que esto es, literalmente, todo lo necesario para preparar un servidor Git compartido. Habilitar unas cuantas cuentas SSH en un servidor; colocar un repositorio básico en algún lugar donde esos usuarios tengan acceso de lectura/escritura;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You’re ready to go — nothing else needed.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>y.... ¡listo!, eso es todo lo que necesitas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In the next few sections, you’ll see how to expand to more sophisticated setups.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En los siguientes apartados, se mostrará como ir más allá y preparar disposiciones más sofisticadas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This discussion will include not having to create user accounts for each user, adding public read access to repositories, setting up web UIs, using the Gitosis tool, and more.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Incluyendo temas tales como el evitar crear cuentas para cada usuario, el añadir acceso público de lectura, el disponer interfaces de usuario web, el usar la herramienta Gitosis, y mucho más.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>However, keep in mind that to collaborate with a couple of people on a private project, all you _need_ is an SSH server and a bare repository.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Pero, ten presente que para colaborar con un pequeño grupo de personas en un proyecto privado, todo lo que necesitas es un servidor SSH y un repositorio básico.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Small Setups ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Pequeños despliegues ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you’re a small outfit or are just trying out Git in your organization and have only a few developers, things can be simple for you.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si tienes un proyecto reducido o estás simplemente probando Git en tu empresa y sois unos pocos desarrolladores, el despliegue será sencillo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>One of the most complicated aspects of setting up a Git server is user management.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Porque la gestión de usuarios es precisamente uno de los aspectos más complicados de preparar un servidor Git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you want some repositories to be read-only to certain users and read/write to others, access and permissions can be a bit difficult to arrange.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En caso de requerir varios repositorios de solo lectura para ciertos usuarios y de lectura/escritura para otros, preparar el acceso y los permisos puede dar bastante trabajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>#### SSH Access ####</seg>
      </tuv>
      <tuv lang="ES">
        <seg>#### Acceso SSH ####</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you already have a server to which all your developers have SSH access, it’s generally easiest to set up your first repository there, because you have to do almost no work (as we covered in the last section).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si ya dispones de un servidor donde todos los desarrolladores tengan acceso SSH, te será facil colocar los repositorios en él (tal y como se verá en el próximo apartado).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you want more complex access control type permissions on your repositories, you can handle them with the normal filesystem permissions of the operating system your server runs.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En caso de que necesites un control más complejo y fino sobre cada repositorio, puedes manejarlos a través de los permisos estandar del sistema de archivos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you want to place your repositories on a server that doesn’t have accounts for everyone on your team whom you want to have write access, then you must set up SSH access for them.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si deseas colocar los repositorios en un servidor donde no todas las personas de tu equipo tengan cuentas de acceso, tendrás que dar acceso SSH a aquellas que no lo tengan.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>We assume that if you have a server with which to do this, you already have an SSH server installed, and that’s how you’re accessing the server.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Suponiendo que ya tengas el servidor, que el servicio SSH esté instalado y que sea esa la vía de acceso que tú estés utilizando para acceder a él.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>There are a few ways you can give access to everyone on your team.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tienes varias maneras para dar acceso a todos los miembros de tu equipo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The first is to set up accounts for everybody, which is straightforward but can be cumbersome.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La primera forma es el habilitar cuentas para todos; es la manera más directa, pero también la más laboriosa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You may not want to run `adduser` and set temporary passwords for every user.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Ya que tendrias que lanzar el comando 'adduser' e inventarte contraseñas temporales para cada uno.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>A second method is to create a single 'git' user on the machine, ask every user who is to have write access to send you an SSH public key, and add that key to the `~/.ssh/authorized_keys` file of your new 'git' user.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La segunda forma es el crear un solo usuario 'git' en la máquina y solicitar a cada persona que te envie una clave pública SSH, para que puedas añadirlas al archivo  `~/.ssh/authorized_keys` de dicho usuario 'git'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>At that point, everyone will be able to access that machine via the 'git' user.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>De esta forma, todos pueden acceder a la máquina a través del usuario 'git'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This doesn’t affect the commit data in any way — the SSH user you connect as doesn’t affect the commits you’ve recorded.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto no afecta a los datos de las confirmaciones (commit), ya que el usuario SSH con el que te conectes no es relevante para las confirmaciones de cambios que registres.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Another way to do it is to have your SSH server authenticate from an LDAP server or some other centralized authentication source that you may already have set up.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y una tercera forma es el preparar un servidor SSH autenficado desde un servidor LDAP o desde alguna otra fuente de autenficación externa ya disponible.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>As long as each user can get shell access on the machine, any SSH authentication mechanism you can think of should work.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tan solo con que cada usuario pueda tener acceso al shell de la máquina, es válido cualquier mecanismo de autentificación SSH que se emplee para ello.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## Generating Your SSH Public Key ##</seg>
      </tuv>
      <tuv lang="ES">
        <seg>## Generando tu clave pública SSH ##</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>That being said, many Git servers authenticate using SSH public keys.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tal y como se ha comentado, muchos servidores Git utilizan la autentificación a través de claves públicas SSH.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In order to provide a public key, each user in your system must generate one if they don’t already have one.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y, para ello, cada usuario del sistema ha de generarse una, si es que no la tiene ya.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This process is similar across all operating systems.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El proceso para hacerlo es similar en casi cualquier sistema operativo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>First, you should check to make sure you don’t already have a key.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Ante todo,  asegurarte que no tengas ya una clave.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>By default, a user’s SSH keys are stored in that user’s `~/.ssh` directory.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por defecto, las claves de cualquier usuario SSH se guardan en la carpeta `~/.ssh` de dicho usuario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can easily check to see if you have a key already by going to that directory and listing the contents:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes verificar si tienes ya unas claves, simplemente situandote sobre dicha carpeta y viendo su contenido:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ cd ~/.ssh
	$ ls
	authorized_keys2  id_dsa       known_hosts
	config            id_dsa.pub</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ cd ~/.ssh
	$ ls
	authorized_keys2  id_dsa       known_hosts
	config            id_dsa.pub</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You’re looking for a pair of files named something and something.pub, where the something is usually `id_dsa` or `id_rsa`.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Has de buscar un par de archivos con nombres tales como 'algo' y 'algo.pub'; siendo ese &quot;algo&quot; normalmente 'id_dsa' o 'id_rsa'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The `.pub` file is your public key, and the other file is your private key.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El archivo terminado en '.pub' es tu clave pública, y el otro archivo es tu clave privada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you don’t have these files (or you don’t even have a `.ssh` directory), you can create them by running a program called `ssh-keygen`, which is provided with the SSH package on Linux/Mac systems and comes with the MSysGit package on Windows:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si no tienes esos archivos (o no tienes ni siquiera la carpeta '.ssh'), has de crearlos; utilizando un programa llamado 'ssh-keygen', que viene incluido en el paquete SSH de los sistemas Linux/Mac o en el paquete MSysGit en los sistemas Windows:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ ssh-keygen 
	Generating public/private rsa key pair.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ ssh-keygen 
	Generating public/private rsa key pair.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Enter file in which to save the key (/Users/schacon/.ssh/id_rsa): 
	Enter passphrase (empty for no passphrase): 
	Enter same passphrase again: 
	Your identification has been saved in /Users/schacon/.ssh/id_rsa.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Enter file in which to save the key (/Users/schacon/.ssh/id_rsa): 
	Enter passphrase (empty for no passphrase): 
	Enter same passphrase again: 
	Your identification has been saved in /Users/schacon/.ssh/id_rsa.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Your public key has been saved in /Users/schacon/.ssh/id_rsa.pub.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Your public key has been saved in /Users/schacon/.ssh/id_rsa.pub.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The key fingerprint is:
	43:c5:5b:5f:b1:f1:50:43:ad:20:a6:92:6a:1f:9a:3a schacon@agadorlaptop.local</seg>
      </tuv>
      <tuv lang="ES">
        <seg>The key fingerprint is:
	43:c5:5b:5f:b1:f1:50:43:ad:20:a6:92:6a:1f:9a:3a schacon@agadorlaptop.local</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>First it confirms where you want to save the key (`.ssh/id_rsa`), and then it asks twice for a passphrase, which you can leave empty if you don’t want to type a password when you use the key.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Como se vé, este comando primero solicita confirmación de dónde van a a guardarse las claves ('.ssh/id_rsa'), y luego solicita, dos veces, una contraseña (passphrase), contraseña que puedes dejar en blanco si no deseas tener que teclearla cada vez que uses la clave.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now, each user that does this has to send their public key to you or whoever is administrating the Git server (assuming you’re using an SSH server setup that requires public keys).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tras generarla, cada usuario ha de encargarse de enviar su clave pública a quienquiera que administre el servidor Git (en el caso de que este esté configurado con SSH y así lo requiera).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>All they have to do is copy the contents of the `.pub` file and e-mail it.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto se puede realizar simplemente copiando los contenidos del archivo terminado en '.pub' y enviandoselos por correo electrónico.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The public keys look something like this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La clave pública será una serie de números, letras y signos, algo así como esto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ cat ~/.ssh/id_rsa.pub 
	ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAklOUpkDHrfHY17SbrmTIpNLTGK9Tjom/BWDSU
	GPl+nafzlHDTYW7hdI4yZ5ew18JH4JW9jbhUFrviQzM7xlELEVf4h9lFX5QVkbPppSwg0cda3
	Pbv7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8V6RjsNAQwdsdMFvSlVK/7XA
	t3FaoJoAsncM1Q9x5+3V0Ww68/eIFmb1zuUFljQJKprrX88XypNDvjYNby6vw/Pb0rwert/En
	mZ+AW4OZPnTPI89ZPmVMLuayrD2cE86Z/il8b+gw3r3+1nKatmIkjn2so1d01QraTlMqVSsbx
	NrRFi9wrf+M7Q== schacon@agadorlaptop.local</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ cat ~/.ssh/id_rsa.pub 
	ssh-rsa AAAAB3NzaC1yc2EAAAABIwAAAQEAklOUpkDHrfHY17SbrmTIpNLTGK9Tjom/BWDSU
	GPl+nafzlHDTYW7hdI4yZ5ew18JH4JW9jbhUFrviQzM7xlELEVf4h9lFX5QVkbPppSwg0cda3
	Pbv7kOdJ/MTyBlWXFCR+HAo3FXRitBqxiX1nKhXpHAZsMciLq8V6RjsNAQwdsdMFvSlVK/7XA
	t3FaoJoAsncM1Q9x5+3V0Ww68/eIFmb1zuUFljQJKprrX88XypNDvjYNby6vw/Pb0rwert/En
	mZ+AW4OZPnTPI89ZPmVMLuayrD2cE86Z/il8b+gw3r3+1nKatmIkjn2so1d01QraTlMqVSsbx
	NrRFi9wrf+M7Q== schacon@agadorlaptop.local</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For a more in-depth tutorial on creating an SSH key on multiple operating systems, see the GitHub guide on SSH keys at `http://github.com/guides/providing-your-ssh-key`.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para más detalles sobre cómo crear unas claves SSH en variados sistemas operativos, consultar la correspondiente guia en GitHub:  `http://github.com/guides/providing-your-ssh-key`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## Setting Up the Server ##</seg>
      </tuv>
      <tuv lang="ES">
        <seg>## Preparando el servidor ##</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Let’s walk through setting up SSH access on the server side.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Vamos a avanzar en los ajustes de los accesos SSH en el lado del servidor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In this example, you’ll use the `authorized_keys` method for authenticating your users.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En este ejemplo, usarás el método de las 'claves autorizadas' para autentificar a tus usuarios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>We also assume you’re running a standard Linux distribution like Ubuntu.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Se asume que tienes un servidor en marcha, con una distribución estandar de Linux, tal como Ubuntu.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>First, you create a 'git' user and a `.ssh` directory for that user.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Comienzas creando un usuario 'git' y una carpeta '.ssh' para él.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ sudo adduser git
	$ su git
	$ cd
	$ mkdir .ssh</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ sudo adduser git
	$ su git
	$ cd
	$ mkdir .ssh</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Next, you need to add some developer SSH public keys to the `authorized_keys` file for that user.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y a continuación añades las claves públicas de los desarrolladores al archivo 'autorized_keys' del usuario 'git' que has creado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Let’s assume you’ve received a few keys by e-mail and saved them to temporary files.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Suponiendo que hayas recibido las claves por correo electrónico y que las has guardado en archivos temporales.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Again, the public keys look something like this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y recordando que las claves públicas son algo así como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ cat /tmp/id_rsa.john.pub
	ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCB007n/ww+ouN4gSLKssMxXnBOvf9LGt4L
	ojG6rs6hPB09j9R/T17/x4lhJA0F3FR1rP6kYBRsWj2aThGw6HXLm9/5zytK6Ztg3RPKK+4k
	Yjh6541NYsnEAZuXz0jTTyAUfrtU3Z5E003C4oxOj6H0rfIF1kKI9MAQLMdpGW1GYEIgS9Ez
	Sdfd8AcCIicTDWbqLAcU4UpkaX8KyGlLwsNuuGztobF8m72ALC/nLF6JLtPofwFBlgc+myiv
	O7TCUSBdLQlgMVOFq1I2uPWQOkOWQAHukEOmfjy2jctxSDBQ220ymjaNsHT4kgtZg2AYYgPq
	dAv8JggJICUvax2T9va5 gsg-keypair</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ cat /tmp/id_rsa.john.pub
	ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCB007n/ww+ouN4gSLKssMxXnBOvf9LGt4L
	ojG6rs6hPB09j9R/T17/x4lhJA0F3FR1rP6kYBRsWj2aThGw6HXLm9/5zytK6Ztg3RPKK+4k
	Yjh6541NYsnEAZuXz0jTTyAUfrtU3Z5E003C4oxOj6H0rfIF1kKI9MAQLMdpGW1GYEIgS9Ez
	Sdfd8AcCIicTDWbqLAcU4UpkaX8KyGlLwsNuuGztobF8m72ALC/nLF6JLtPofwFBlgc+myiv
	O7TCUSBdLQlgMVOFq1I2uPWQOkOWQAHukEOmfjy2jctxSDBQ220ymjaNsHT4kgtZg2AYYgPq
	dAv8JggJICUvax2T9va5 gsg-keypair</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You just append them to your `authorized_keys` file:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>No tienes más que añadirlas al archivo 'authorized_keys':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ cat /tmp/id_rsa.john.pub &gt;&gt; ~/.ssh/authorized_keys
	$ cat /tmp/id_rsa.josie.pub &gt;&gt; ~/.ssh/authorized_keys
	$ cat /tmp/id_rsa.jessica.pub &gt;&gt; ~/.ssh/authorized_keys</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ cat /tmp/id_rsa.john.pub &gt;&gt; ~/.ssh/authorized_keys
	$ cat /tmp/id_rsa.josie.pub &gt;&gt; ~/.ssh/authorized_keys
	$ cat /tmp/id_rsa.jessica.pub &gt;&gt; ~/.ssh/authorized_keys</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now, you can set up an empty repository for them by running `git init` with the `--bare` option, which initializes the repository without a working directory:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tras esto, puedes preparar un repositorio básico vacio para ellos, usando el comando 'git init' con la opción '--bare' para inicializar el repositorio sin carpeta de trabajo:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ cd /opt/git
	$ mkdir project.git
	$ cd project.git
	$ git --bare init</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ cd /opt/git
	$ mkdir project.git
	$ cd project.git
	$ git --bare init</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Then, John, Josie, or Jessica can push the first version of their project into that repository by adding it as a remote and pushing up a branch.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y John, Josie o Jessica podrán enviar (push) la primera versión de su proyecto a dicho repositorio, añadiendolo como remoto y enviando (push) una rama (branch).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Note that someone must shell onto the machine and create a bare repository every time you want to add a project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cabe indicar que alguien tendrá que iniciar sesión en la máquina y crear un repositorio básico, cada vez que se desee añadir un nuevo proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Let’s use `gitserver` as the hostname of the server on which you’ve set up your 'git' user and repository.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Suponiendo, por ejemplo, que se llame 'gitserver' el servidor donde has puesto el usuario 'git' y los repositorios;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you’re running it internally, and you set up DNS for `gitserver` to point to that server, then you can use the commands pretty much as is:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>que dicho servidor es interno a vuestra red y que está asignado el nombre 'gitserver' en vuestro DNS.  Podrás utlizar comandos tales como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg># on Johns computer
	$ cd myproject
	$ git init
	$ git add .</seg>
      </tuv>
      <tuv lang="ES">
        <seg># en la máquina de John
	$ cd myproject
	$ git init
	$ git add .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git commit -m 'initial commit'
	$ git remote add origin git@gitserver:/opt/git/project.git
	$ git push origin master</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git commit -m 'initial commit'
	$ git remote add origin git@gitserver:/opt/git/project.git
	$ git push origin master</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>At this point, the others can clone it down and push changes back up just as easily:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tras lo cual, otros podrán clonarlo y enviar cambios de vuelta:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git clone git@gitserver:/opt/git/project.git
	$ vim README
	$ git commit -am 'fix for the README file'
	$ git push origin master</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git clone git@gitserver:/opt/git/project.git
	$ vim README
	$ git commit -am 'fix for the README file'
	$ git push origin master</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>With this method, you can quickly get a read/write Git server up and running for a handful of developers.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Con este método, puedes preparar rápidamente un servidor Git con acceso de lectura/escritura para un grupo de desarrolladores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>As an extra precaution, you can easily restrict the 'git' user to only doing Git activities with a limited shell tool called `git-shell` that comes with Git.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para una mayor protección, puedes restringir facilmente el usuario 'git' a realizar solamente actividades relacionadas con Git. Utilizando un shell limitado llamado 'git-shell', que viene incluido en Git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you set this as your 'git' user’s login shell, then the 'git' user can’t have normal shell access to your server.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si lo configuras como el shell de inicio de sesión de tu usuario 'git', dicho usuario no tendrá acceso al shell normal del servidor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To use this, specify `git-shell` instead of bash or csh for your user’s login shell.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para especificar el 'git-shell' en lugar de bash o de csh como el shell de inicio de sesión de un usuario,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To do so, you’ll likely have to edit your `/etc/passwd` file:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Has de editar el archivo '/etc/passwd':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ sudo vim /etc/passwd</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ sudo vim /etc/passwd</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>At the bottom, you should find a line that looks something like this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Localizar, al fondo, una línea parecida a:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>git:x:1000:1000::/home/git:/bin/sh</seg>
      </tuv>
      <tuv lang="ES">
        <seg>git:x:1000:1000::/home/git:/bin/shgit:x:1000:1000::/home/git:/bin/sh</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Change `/bin/sh` to `/usr/bin/git-shell` (or run `which git-shell` to see where it’s installed).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y cambiar '/bin/sh' por '/usr/bin/git-shell' (nota: puedes utilizar el comando 'which git-shell' para ver dónde está instalado dicho shell).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The line should look something like this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Quedará una linea algo así como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>git:x:1000:1000::/home/git:/usr/bin/git-shell</seg>
      </tuv>
      <tuv lang="ES">
        <seg>git:x:1000:1000::/home/git:/usr/bin/git-shellgit:x:1000:1000::/home/git:/usr/bin/git-shell</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now, the 'git' user can only use the SSH connection to push and pull Git repositories and can’t shell onto the machine.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>De esta forma dejamos al usuario 'git' limitado a utilizar la conexión SSH solamente para enviar (push) y recibir (pull) repositorios, sin posibilidad de iniciar una sesión normal en el servidor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you try, you’ll see a login rejection like this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si pruebas a hacerlo, recibiras un rechazo de inicio de sesión:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ ssh git@gitserver
	fatal: What do you think I am?</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ ssh git@gitserver
	fatal: What do you think I am?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>A shell?</seg>
      </tuv>
      <tuv lang="ES">
        <seg>A shell?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Connection to gitserver closed.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Connection to gitserver closed.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## Public Access ##</seg>
      </tuv>
      <tuv lang="ES">
        <seg>## Acceso público ##</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>What if you want anonymous read access to your project?</seg>
      </tuv>
      <tuv lang="ES">
        <seg>¿Qué hacer si necesitas acceso anónimo de lectura a tu proyecto?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Perhaps instead of hosting an internal private project, you want to host an open source project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por ejemplo, si en lugar de albergar un proyecto privado interno, quieres albergar un proyecto de código abierto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Or maybe you have a bunch of automated build servers or continuous integration servers that change a lot, and you don’t want to have to generate SSH keys all the time — you just want to add simple anonymous read access.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>O si tienes un grupo de servidores de integración automatizados o servidores de integración continua que cambian muy a menudo, y no quieres estar todo el rato generando claves SSH. Es posible que desees añadirles un simple acceso anónimo de lectura.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Probably the simplest way for smaller setups is to run a static web server with its document root where your Git repositories are, and then enable that `post-update` hook we mentioned in the first section of this chapter.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La manera más sencilla de hacerlo para pequeños despliegues, es el preparar un servidor web estático cuya raiz de documentos sea la ubicación donde tengas tus repositorios Git; y luego activar el anclaje (hook) 'post-update' que se ha mencionado en la primera parte de este capítulo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Let’s work from the previous example.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si utilizamos el mismo ejemplo usado anteriormente,</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Say you have your repositories in the `/opt/git` directory, and an Apache server is running on your machine.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>suponiendo que tengas los repositorios en la carpeta '/opt/git', y que hay un servidor Apache en marcha en tu máquina.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Again, you can use any web server for this; but as an example, we’ll demonstrate some basic Apache configurations that should give you an idea of what you might need.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Veremos algunas configuraciones básicas de Apache, para que puedas hacerte una idea de lo que puedes necesitar. (Recordar que esto es solo un ejemplo, y que puedes utilizar cualquier otro servidor web.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>First you need to enable the hook:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Lo primero, es activar el anclaje (hook):</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ cd project.git
	$ mv hooks/post-update.sample hooks/post-update
	$ chmod a+x hooks/post-update</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ cd project.git
	$ mv hooks/post-update.sample hooks/post-update
	$ chmod a+x hooks/post-update</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you’re using a version of Git earlier than 1.6, the `mv` command isn’t necessary — Git started naming the hooks examples with the .sample postfix only recently.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si utilizas una versión de Git anterior a la 1.6, el comando 'mv' no es necesario, ya que solo recientemente lleva Git los anclajes de ejemplo con el sufijo .sample</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>What does this `post-update` hook do?</seg>
      </tuv>
      <tuv lang="ES">
        <seg>¿Que hace este anclaje 'post-update'?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It looks basically like this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Pues tiene una pinta tal como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ cat .git/hooks/post-update 
	#!/bin/sh
	exec git-update-server-info</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ cat .git/hooks/post-update 
	#!/bin/sh
	exec git-update-server-info</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This means that when you push to the server via SSH, Git will run this command to update the files needed for HTTP fetching.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Lo que significa que cada vez que envias (push) algo al servidor vía SSH, Git lanzará este comando y actualizará así los archivos necesarios para HTTP fetching. (_i_pendientedetraducir) </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Next, you need to add a VirtualHost entry to your Apache configuration with the document root as the root directory of your Git projects.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>A continuación, has de añadir una entrada VirtualHost al archivo de configuración de Apache, fijando su raiz de documentos a la ubicación donde tengas tus proyectos Git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Here, we’re assuming that you have wildcard DNS set up to send `*.gitserver` to whatever box you’re using to run all this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Aquí, estamos asumiendo que tienes un DNS comodin para redirigir '*.gitserver' hacia cualquier máquina que estés utilizando para todo esto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>&lt;VirtualHost *:80&gt;
	    ServerName git.gitserver
	    DocumentRoot /opt/git
	    &lt;Directory /opt/git/&gt;
	        Order allow, deny
	        allow from all
	    &lt;/Directory&gt;
	&lt;/VirtualHost&gt;</seg>
      </tuv>
      <tuv lang="ES">
        <seg>&lt;VirtualHost *:80&gt;
	    ServerName git.gitserver
	    DocumentRoot /opt/git
	    &lt;Directory /opt/git/&gt;
	        Order allow, deny
	        allow from all
	    &lt;/Directory&gt;
	&lt;/VirtualHost&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You’ll also need to set the Unix user group of the `/opt/git` directories to `www-data` so your web server can read-access the repositories, because the Apache instance running the CGI script will (by default) be running as that user:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Asimismo, has de ajustar el grupo Unix de las carpetas bajo '/opt/git' a 'www-data', para que tu servidor web tenga acceso de lectura a los repositorios contenidos en ellas; porque la instancia de Apache que maneja los scripts CGI trabaja bajo dicho usuario:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ chgrp -R www-data /opt/git</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ chgrp -R www-data /opt/git</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When you restart Apache, you should be able to clone your repositories under that directory by specifying the URL for your project:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Una vez reinicies Apache, ya deberias ser capaz de clonar tus repositorios bajo dicha carpeta, simplemente indicando la URL de tu projecto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git clone http://git.gitserver/project.git</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git clone http://git.gitserver/project.git</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This way, you can set up HTTP-based read access to any of your projects for a fair number of users in a few minutes.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>De esta manera, puedes preparar en cuestión de minutos accesos de lectura basados en HTTP a tus proyectos, para grandes cantidades de usuarios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Another simple option for public unauthenticated access is to start a Git daemon, although that requires you to daemonize the process - we’ll cover this option in the next section, if you prefer that route.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Otra opción simple para habilitar accesos públicos sin autentificar, es arrancar el demonio Git, aunque esto supone demonizar el proceso. (Se verá esta opción en la siguiente sección.)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## GitWeb ##</seg>
      </tuv>
      <tuv lang="ES">
        <seg>## GitWeb ##</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now that you have basic read/write and read-only access to your project, you may want to set up a simple web-based visualizer.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Ahora que ya tienes acceso básico de lectura/escritura y de solo-lectura a tu proyecto, puedes querer instalar un visualizador web.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Git comes with a CGI script called GitWeb that is commonly used for this.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Git trae un script CGI, denominado GitWeb, que es el que usaremos para este propósito.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can see GitWeb in use at sites like `http://git.kernel.org` (see Figure 4-1).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes ver a GitWeb en acción en sitios como `http://git.kernel.org` (ver figura 4-1)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0401.png 
Figure 4-1.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0401.png 
Figura 4-1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The GitWeb web-based user interface.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El interface web GitWeb.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you want to check out what GitWeb would look like for your project, Git comes with a command to fire up a temporary instance if you have a lightweight server on your system like `lighttpd` or `webrick`.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si quieres comprobar cómo podría quedar GitWeb con tu proyecto, Git dispone de un comando para activar una instancia temporal, si en tu sistema tienes un servidor web ligero, como por ejemplo 'lighttup' o 'webrick'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>On Linux machines, `lighttpd` is often installed, so you may be able to get it to run by typing `git instaweb` in your project directory.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En las máquinas Linux, 'lighttpd' suele estar habitualmente instalado. Por lo que tan solo has de activarlo lanzando el comando 'git instaweb', estando en la carpeta de tu proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you’re running a Mac, Leopard comes preinstalled with Ruby, so `webrick` may be your best bet.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si tienes una máquina Mac, Leopard trae preinstalado Ruby, por lo que 'webrick' puede ser tu mejor apuesta.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To start `instaweb` with a non-lighttpd handler, you can run it with the `--httpd` option.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para instalar 'instaweb' disponiendo de un controlador no-lighttpd, puedes lanzarlo con la opción '--httpd'.  </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git instaweb --httpd=webrick
	[2009-02-21 10:02:21] INFO  WEBrick 1.3.1
	[2009-02-21 10:02:21] INFO  ruby 1.8.6 (2008-03-03) [universal-darwin9.0]</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git instaweb --httpd=webrick
	[2009-02-21 10:02:21] INFO  WEBrick 1.3.1
	[2009-02-21 10:02:21] INFO  ruby 1.8.6 (2008-03-03) [universal-darwin9.0]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>That starts up an HTTPD server on port 1234 and then automatically starts a web browser that opens on that page.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto arranca un servidor HTTPD en el puerto 1234, y luego arranca un navegador que abre esa página.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It’s pretty easy on your part.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Es realmente sencillo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When you’re done and want to shut down the server, you can run the same command with the `--stop` option:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cuando ya has terminado y quieras apagar el servidor, puedes lanzar el mismo comando con la opción '--stop'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git instaweb --httpd=webrick --stop</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git instaweb --httpd=webrick --stop</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you want to run the web interface on a server all the time for your team or for an open source project you’re hosting, you’ll need to set up the CGI script to be served by your normal web server.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si quieres disponer permanentemente de un interface web para tu equipo o para un proyecto de código abierto que alberges, necesitarás ajustar el script CGI para ser servido por tu servidor web habitual.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Some Linux distributions have a `gitweb` package that you may be able to install via `apt` or `yum`, so you may want to try that first.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Algunas distribuciones Linux suelen incluir el paquete 'gitweb', y podrás instalarlo a través de las utilidades 'apt' o 'yum'; merece la pena probarlo en primer lugar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>We’ll walk though installing GitWeb manually very quickly.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Enseguida vamos a revisar el proceso de instalar GitWeb manualmente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>First, you need to get the Git source code, which GitWeb comes with, and generate the custom CGI script:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Primero, necesitas el código fuente de Git, que viene con GitWeb, para generar un script CGI personalizado:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git clone git://git.kernel.org/pub/scm/git/git.git
	$ cd git/
	$ make GITWEB_PROJECTROOT=&quot;/opt/git&quot; \
	        prefix=/usr gitweb/gitweb.cgi
	$ sudo cp -Rf gitweb /var/www/</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git clone git://git.kernel.org/pub/scm/git/git.git
	$ cd git/
	$ make GITWEB_PROJECTROOT=&quot;/opt/git&quot; \
	        prefix=/usr gitweb/gitweb.cgi
	$ sudo cp -Rf gitweb /var/www/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Notice that you have to tell the command where to find your Git repositories with the `GITWEB_PROJECTROOT` variable.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Fijate que es necesario indicar la ubicación donde se encuentran los repositorios Git, utilizando la variable 'GITWEB_PROJECTROOT'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now, you need to make Apache use CGI for that script, for which you can add a VirtualHost:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>A continuación, tienes que preparar Apache para que utilice dicho script, Para ello, puedes añadir un VirtualHost:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>&lt;VirtualHost *:80&gt;
	    ServerName gitserver
	    DocumentRoot /var/www/gitweb
	    &lt;Directory /var/www/gitweb&gt;
	        Options ExecCGI +FollowSymLinks +SymLinksIfOwnerMatch
	        AllowOverride All
	        order allow,deny
	        Allow from all
	        AddHandler cgi-script cgi
	        DirectoryIndex gitweb.cgi
	    &lt;/Directory&gt;
	&lt;/VirtualHost&gt;</seg>
      </tuv>
      <tuv lang="ES">
        <seg>&lt;VirtualHost *:80&gt;
	    ServerName gitserver
	    DocumentRoot /var/www/gitweb
	    &lt;Directory /var/www/gitweb&gt;
	        Options ExecCGI +FollowSymLinks +SymLinksIfOwnerMatch
	        AllowOverride All
	        order allow,deny
	        Allow from all
	        AddHandler cgi-script cgi
	        DirectoryIndex gitweb.cgi
	    &lt;/Directory&gt;
	&lt;/VirtualHost&gt;</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Again, GitWeb can be served with any CGI capable web server; if you prefer to use something else, it shouldn’t be difficult to set up.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Recordar una vez más que GitWeb puede servirse desde cualquier servidor web con capacidades CGI. Por lo que si prefieres utilizar algún otro, no debería ser dificil de configurarlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>At this point, you should be able to visit `http://gitserver/` to view your repositories online, and you can use `http://git.gitserver` to clone and fetch your repositories over HTTP.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En este momento, deberias poder visitar 'http://gitserver/' para ver tus repositorios online. Y utilizar 'http://git.gitserver' para clonar (clone) y recuperar (fetch) tus repositorios a través de HTTP.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## Gitosis ##</seg>
      </tuv>
      <tuv lang="ES">
        <seg>## Gitosis ##</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Keeping all users’ public keys in the `authorized_keys` file for access works well only for a while.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Mantener claves públicas, para todos los usuarios, en el archivo 'authorized_keys', puede ser una buena solución inicial.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When you have hundreds of users, it’s much more of a pain to manage that process.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Pero, cuanto tengas cientos de usuarios, se hace bastante pesado gestionar así ese proceso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You have to shell onto the server each time, and there is no access control — everyone in the file has read and write access to every project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tienes que iniciar sesión en el servidor cada vez. Y, ademas, no tienes control de acceso --todo el mundo presente en el archivo tiene permisos de lectura y escritura a todos y cada uno de los proyectos--.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>At this point, you may want to turn to a widely used software project called Gitosis.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En este punto, es posible que desees cambiar a un popular programa llamado Gitosis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Gitosis is basically a set of scripts that help you manage the `authorized_keys` file as well as implement some simple access controls.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Gitosis es básicamente un conjunto de scripts que te ayudarán a gestionar el archivo 'authorized_keys', así como a implementar algunos controles de acceso simples.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The really interesting part is that the UI for this tool for adding people and determining access isn’t a web interface but a special Git repository.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Lo interesante de la interfaz de usuario para esta herramienta de gestión de usuarios y de control de accesos, es que, en lugar de un interface web, es un repositorio especial de Git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You set up the information in that project; and when you push it, Gitosis reconfigures the server based on that, which is cool.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Preparas la información en ese proyecto especial, y cuando la envias (push), Gitosis reconfigura el servidor en base a ella. ¡Realmente interesante!.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Installing Gitosis isn’t the simplest task ever, but it’s not too difficult.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Instalar Gitosis no es precisamente sencillo. Pero tampoco demasiado complicado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It’s easiest to use a Linux server for it — these examples use a stock Ubuntu 8.10 server.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Es más sencillo hacerlo si utilizas un servidor Linux --estos ejemplos se han hecho sobre un servidor Ubuntu 8.10--.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Gitosis requires some Python tools, so first you have to install the Python setuptools package, which Ubuntu provides as python-setuptools:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Gitosis necesita de ciertas herramientas Python, por lo que la  primera tarea será instalar el paquete de herramientas Pyton. En Ubuntu viene como el paquete python-stuptools:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ apt-get install python-setuptools</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ apt-get install python-setuptools</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Next, you clone and install Gitosis from the project’s main site:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>A continuación, has de clonar e instalar Gitosis desde el repositorio principal de su proyecto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git clone git://eagain.net/gitosis.git
	$ cd gitosis
	$ sudo python setup.py install</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git clone git://eagain.net/gitosis.git
	$ cd gitosis
	$ sudo python setup.py install</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>That installs a couple of executables that Gitosis will use.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto instala un par de ejecutables, que serán los que Gitosis utilice.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Next, Gitosis wants to put its repositories under `/home/git`, which is fine.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Gitosis intentará instalar sus repositorios bajo la carpeta '/home/git', lo cual está bien.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>But you have already set up your repositories in `/opt/git`, so instead of reconfiguring everything, you create a symlink:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Pero si, en lugar de en esa, has instalado tus repositorios bajo la carpeta '/opt/git'. Sin necesidad de reconfigurarlo todo, tan solo has de crear un enlace virtual:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ ln -s /opt/git /home/git/repositories</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ ln -s /opt/git /home/git/repositories</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Gitosis is going to manage your keys for you, so you need to remove the current file, re-add the keys later, and let Gitosis control the `authorized_keys` file automatically.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Gitosis manejará tus claves por tí, por lo que tendrás que quitar el archivo actual, añadir de nuevo las claves más tarde, y dejar que Gitosis tome automáticamente el control del archivo 'authorized_keys'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For now, move the `authorized_keys` file out of the way:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para empezar, mueve el archivo 'authorized_keys a otro lado:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ mv /home/git/.ssh/authorized_keys /home/git/.ssh/ak.bak</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ mv /home/git/.ssh/authorized_keys /home/git/.ssh/ak.bak</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Next you need to turn your shell back on for the 'git' user, if you changed it to the `git-shell` command.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>A continuación, restaura el inicio de sesión (shell) para el usuario 'git', (si es que lo habias cambiado al comando 'git-shell').</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>People still won’t be able to log in, but Gitosis will control that for you.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Los usuarios no podrán todavia iniciar sesión, pero Gitosis se encargará de ello.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>So, let’s change this line in your `/etc/passwd` file</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Así pues, cambia esta línea en tu archivo '/etc/passwd':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>back to this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>de vuelta a:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now it’s time to initialize Gitosis.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y, en este punto, ya podemos inicializar Gitosis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You do this by running the `gitosis-init` command with your personal public key.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Lo puedes hacer lanzando el comando 'gitosis-init' con tu clave pública personal.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If your public key isn’t on the server, you’ll have to copy it there:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si tu clave pública personal no está en el servidor, la has de copiar a él:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ sudo -H -u git gitosis-init &lt; /tmp/id_dsa.pub
	Initialized empty Git repository in /opt/git/gitosis-admin.git/
	Reinitialized existing Git repository in /opt/git/gitosis-admin.git/</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ sudo -H -u git gitosis-init &lt; /tmp/id_dsa.pub
	Initialized empty Git repository in /opt/git/gitosis-admin.git/
	Reinitialized existing Git repository in /opt/git/gitosis-admin.git/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This lets the user with that key modify the main Git repository that controls the Gitosis setup.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto habilita al usuario con dicha clave pública para que pueda modificar el repositorio principal de Git, y, con ello, pueda controlar la instalación de Gitosis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Next, you have to manually set the execute bit on the `post-update` script for your new control repository.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>A continuanción, has de ajustar manualmente el bit de ejecución en el script 'post-update' de tu nuevo repositorio de contrrol:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ sudo chmod 755 /opt/git/gitosis-admin.git/hooks/post-update</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ sudo chmod 755 /opt/git/gitosis-admin.git/hooks/post-update</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You’re ready to roll.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y ya estás preparado para trabajar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you’re set up correctly, you can try to SSH into your server as the user for which you added the public key to initialize Gitosis.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si lo has configurado todo correctamente, puedes intentar conectarte, vía SSH, a tu servidor como el usuario con cuya clave pública has inicializado Gitosis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You should see something like this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y deberás ver algo así como esto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ ssh git@gitserver
	PTY allocation request failed on channel 0
	fatal: unrecognized command 'gitosis-serve schacon@quaternion'
	  Connection to gitserver closed.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ ssh git@gitserver
	PTY allocation request failed on channel 0
	fatal: unrecognized command 'gitosis-serve schacon@quaternion'
	  Connection to gitserver closed.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>That means Gitosis recognized you but shut you out because you’re not trying to do any Git commands.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Indicandote que Gitosis te ha reconocido, pero te está hechando debido a que no estás intentando lanzar ningún comando Git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>So, let’s do an actual Git command — you’ll clone the Gitosis control repository:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por tanto, intentalo con un comando Git real --por ejemplo, clonar el propio repositorio de control de Gitosis </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg># on your local computer
	$ git clone git@gitserver:gitosis-admin.git</seg>
      </tuv>
      <tuv lang="ES">
        <seg>a tu ordenador personal-- 
	$ git clone git@gitserver:gitosis-admin.git</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now you have a directory named `gitosis-admin`, which has two major parts:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Con ello, tendrás una carpeta denominada 'gitosis-admin', con dos partes principales dentro de ella:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ cd gitosis-admin
	$ find .</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ cd gitosis-admin
	$ find .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>./gitosis.conf
	./keydir
	./keydir/scott.pub</seg>
      </tuv>
      <tuv lang="ES">
        <seg>./gitosis.conf
	./keydir
	./keydir/scott.pub</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The `gitosis.conf` file is the control file you use to specify users, repositories, and permissions.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El archivo 'gitosis.conf' es el archivo de control que usarás para especificar usuarios, repositorios y permisos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The `keydir` directory is where you store the public keys of all the users who have any sort of access to your repositories — one file per user.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La carpeta 'keydir' es donde almacenarás las claves públicas para los usuarios con acceso a tus repositorios --un archivo por usuario--.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The name of the file in `keydir` (in the previous example, `scott.pub`) will be different for you — Gitosis takes that name from the description at the end of the public key that was imported with the `gitosis-init` script.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El nombre del archivo en la carpeta 'keydir' ('scott.pub' en el ejemplo), puede ser diferente en tu instalación, (Gitosis lo obtiene a partir de la descripción existente al final de la clave pública que haya sido importada con el script 'gitosis-init').</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you look at the `gitosis.conf` file, it should only specify information about the `gitosis-admin` project that you just cloned:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si miras dentro del archivo 'gitosis.conf', encontrarás únicamente información sobre el proyecto 'gitosis-admin' que acabas de clonar:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ cat gitosis.conf 
	[gitosis]</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ cat gitosis.conf 
	[gitosis]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>[group gitosis-admin]
	writable = gitosis-admin
	members = scott</seg>
      </tuv>
      <tuv lang="ES">
        <seg>[group gitosis-admin]
	writable = gitosis-admin
	members = scott</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It shows you that the 'scott' user — the user with whose public key you initialized Gitosis — is the only one who has access to the `gitosis-admin` project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Indicando que el usuario 'scott' --el usuario con cuya clave pública se ha inicializado Gitosis-- es el único con acceso al proyecto 'gitosis-admin'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now, let’s add a new project for you.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>A partir de ahora, puedes añadir nuevos proyectos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You’ll add a new section called `mobile` where you’ll list the developers on your mobile team and projects that those developers need access to.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por ejemplo, puedes añadir una nueva sección denominada 'mobile', donde poner la lista de los desarrolladores en tu equipo movil y los proyectos donde estos vayan a trabajar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Because 'scott' is the only user in the system right now, you’ll add him as the only member, and you’ll create a new project called `iphone_project` to start on:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por ser 'scott' el único usuario que tienes definido por ahora, lo añadirás como el único miembro. Y puedes crear además un proyecto llamado 'iphone_project' para empezar:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>[group mobile]
	writable = iphone_project
	members = scott</seg>
      </tuv>
      <tuv lang="ES">
        <seg>[group mobile]
	writable = iphone_project
	members = scott</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Whenever you make changes to the `gitosis-admin` project, you have to commit the changes and push them back up to the server in order for them to take effect:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cada cambio en el proyecto 'gitosis-admin', lo has de confirmar (commit) y enviar (push) de vuelta al servidor, para que tenga efecto sobre él:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git commit -am 'add iphone_project and mobile group'
	[master]: created 8962da8: &quot;changed name&quot;
	 1 files changed, 4 insertions(+), 0 deletions(-)
	$ git push
	Counting objects: 5, done.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git commit -am 'add iphone_project and mobile group'
	[master]: created 8962da8: &quot;changed name&quot;
	 1 files changed, 4 insertions(+), 0 deletions(-)
	$ git push
	Counting objects: 5, done.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Compressing objects: 100% (2/2), done.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Compressing objects: 100% (2/2), done.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Writing objects: 100% (3/3), 272 bytes, done.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Writing objects: 100% (3/3), 272 bytes, done.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Total 3 (delta 1), reused 0 (delta 0)
	To git@gitserver:/opt/git/gitosis-admin.git
	   fb27aec..8962da8  master -&gt; master</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Total 3 (delta 1), reused 0 (delta 0)
	To git@gitserver:/opt/git/gitosis-admin.git
	   fb27aec..8962da8  master -&gt; master</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can make your first push to the new `iphone_project` project by adding your server as a remote to your local version of the project and pushing.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes crear tu nuevo proyecto 'iphone_project' simplemente añadiendo tu servidor como un remoto a tu versión local del proyecto de control y enviando (push).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You no longer have to manually create a bare repository for new projects on the server — Gitosis creates them automatically when it sees the first push:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Ya no necesitarás crear manualmente repositorios básicos vacios para los nuevos proyectos en el servidor. Gitosis se encargará de hacerlo por tí, en cuanto realices el primer envio (push) de un nuevo proyecto:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git remote add origin git@gitserver:iphone_project.git
	$ git push origin master
	Initialized empty Git repository in /opt/git/iphone_project.git/
	Counting objects: 3, done.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git remote add origin git@gitserver:iphone_project.git
	$ git push origin master
	Initialized empty Git repository in /opt/git/iphone_project.git/
	Counting objects: 3, done.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Writing objects: 100% (3/3), 230 bytes, done.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Writing objects: 100% (3/3), 230 bytes, done.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Total 3 (delta 0), reused 0 (delta 0)
	To git@gitserver:iphone_project.git
	 * [new branch]      master -&gt; master</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Total 3 (delta 0), reused 0 (delta 0)
	To git@gitserver:iphone_project.git
	 * [new branch]      master -&gt; master</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Notice that you don’t need to specify the path (in fact, doing so won’t work), just a colon and then the name of the project — Gitosis finds it for you.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Ten en cuenta que no es necesario indicar expresamente un camino (path), --de hecho, si lo haces, no funcionará--. Simplemente, has de poner un punto y el nombre del proyecto, --Gitosis se encargará de encontrarlo--.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You want to work on this project with your friends, so you’ll have to re-add their public keys.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si deseas compartir el proyecto con tus compañeros, tienes que añadir de nuevo sus claves públicas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>But instead of appending them manually to the `~/.ssh/authorized_keys` file on your server, you’ll add them, one key per file, into the `keydir` directory.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Pero en lugar de hacerlo manualmente sobre el archivo `~/.ssh/authorized_keys` de tu servidor, has de hacerlo --un archivo por clave-- en la carpeta 'keydir' del proyecto de control.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>How you name the keys determines how you refer to the users in the `gitosis.conf` file.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Según pongas los nombres a estos archivos, así tendrás que referirte a los usuarios en el archivo 'gitosis.conf'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Let’s re-add the public keys for John, Josie, and Jessica:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por ejemplo, para añadir las claves públicas de John, Josie y Jessica:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ cp /tmp/id_rsa.john.pub keydir/john.pub
	$ cp /tmp/id_rsa.josie.pub keydir/josie.pub
	$ cp /tmp/id_rsa.jessica.pub keydir/jessica.pub</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ cp /tmp/id_rsa.john.pub keydir/john.pub
	$ cp /tmp/id_rsa.josie.pub keydir/josie.pub
	$ cp /tmp/id_rsa.jessica.pub keydir/jessica.pub</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now you can add them all to your 'mobile' team so they have read and write access to `iphone_project`:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y para añadirlos al equipo 'mobile', dándoles permisos de lectura y escritura sobre el proyecto 'phone_project':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>[group mobile]
	writable = iphone_project
	members = scott john josie jessica</seg>
      </tuv>
      <tuv lang="ES">
        <seg>[group mobile]
	writable = iphone_project
	members = scott john josie jessica</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>After you commit and push that change, all four users will be able to read from and write to that project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tras confirmar (commit) y enviar (push) estos cambios, los cuatro usuarios podrán acceder a leer y escribir sobre el proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Gitosis has simple access controls as well.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Gitosis permite también sencillos controles de acceso.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you want John to have only read access to this project, you can do this instead:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por ejemplo, si quieres que John tenga únicamente acceso de lectura sobre el proyecto, puedes hacer:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>[group mobile]
	writable = iphone_project
	members = scott josie jessica</seg>
      </tuv>
      <tuv lang="ES">
        <seg>[group mobile]
	writable = iphone_project
	members = scott josie jessica</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>[group mobile_ro]
	readonly = iphone_project
	members = john</seg>
      </tuv>
      <tuv lang="ES">
        <seg>[group mobile_ro]
	readonly = iphone_project
	members = john</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now John can clone the project and get updates, but Gitosis won’t allow him to push back up to the project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Habilitandole así para clonar y recibir actualizaciónes desde el servidor; pero impidiendole enviar de vuelta cambios al proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can create as many of these groups as you want, each containing different users and projects.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes crear tantos grupos como desees, para diferentes usuarios y proyectos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can also specify another group as one of the members (using `@` as prefix), to inherit all of its members automatically:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>También puedes indicar un grupo como miembro de otro (utilizado el prefijo '@'), para incluir todos sus miembros automáticamente:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>[group mobile_committers]
	members = scott josie jessica</seg>
      </tuv>
      <tuv lang="ES">
        <seg>[group mobile_committers]
	members = scott josie jessica</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>[group mobile]
	writable  = iphone_project
	members   = @mobile_committers</seg>
      </tuv>
      <tuv lang="ES">
        <seg>[group mobile]
	writable  = iphone_project
	members   = @mobile_committers</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>[group mobile_2]
	writable  = another_iphone_project
	members   = @mobile_committers john</seg>
      </tuv>
      <tuv lang="ES">
        <seg>[group mobile_2]
	writable  = another_iphone_project
	members   = @mobile_committers john</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you have any issues, it may be useful to add `loglevel=DEBUG` under the `[gitosis]` section.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si tienes problemas, puede ser util añadir `loglevel=DEBUG` en la sección `[gitosis]`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you’ve lost push access by pushing a messed-up configuration, you can manually fix the file on the server under `/home/git/.gitosis.conf` — the file from which Gitosis reads its info.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si, por lo que sea, pierdes acceso de envio (push) de nuevos cambios, (por ejemplo, tras haber enviado una configuración problemática); siempre puedes arreglar manualmente ,en el propio servidor, el archivo '/home/git/.gitosis.conf', (el archivo del que Gitosis lee su configuración).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>A push to the project takes the `gitosis.conf` file you just pushed up and sticks it there.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Un envio (push) de cambios al proyecto, coge el archivo 'gitosis.conf' enviado y sobreescribe con él el del servidor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you edit that file manually, it remains like that until the next successful push to the `gitosis-admin` project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si lo editas manualmente, permanecerá como lo dejes; hasta el próximo envio (push) al proyecto 'gitosis-admin'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## Git Daemon ##</seg>
      </tuv>
      <tuv lang="ES">
        <seg>## El demonio Git ##</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For public, unauthenticated read access to your projects, you’ll want to move past the HTTP protocol and start using the Git protocol.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para dar a tus proyectos un acceso público, sin autentificar, de solo lectura, querrás ir más allá del protocolo HTTP y comenzar a utilizar el protocolo Git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The main reason is speed.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Principalmente, por razones de velocidad.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The Git protocol is far more efficient and thus faster than the HTTP protocol, so using it will save your users time.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El protocolo Git es mucho más eficiente y, por tanto, más rápido que el protocolo HTTP. Utilizándolo, ahorrarás mucho tiempo a tus usuarios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Again, this is for unauthenticated read-only access.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Aunque, sigue siendo solo para acceso unicamente de lectura y sin autentificar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you’re running this on a server outside your firewall, it should only be used for projects that are publicly visible to the world.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si lo estás utilizando en un servidor fuera del perímetro de tu cortafuegos, se debe utilizar exclusivamente para proyectos que han de ser públicos, visibles para todo el mundo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If the server you’re running it on is inside your firewall, you might use it for projects that a large number of people or computers (continuous integration or build servers) have read-only access to, when you don’t want to have to add an SSH key for each.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si lo estás utilizando en un servidor dentro del perímetro de tu cortafuegos, puedes utilizarlo para proyectos donde un gran número de personas o de ordenadores (integración contínua o servidores de desarrollo) necesiten acceso de solo lectura. Y donde quieras evitar la gestión de claves SSH para cada una de ellas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In any case, the Git protocol is relatively easy to set up.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En cualquier caso, el protocolo Git es relativamente sencillo de configurar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Basically, you need to run this command in a daemonized manner:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tan solo necesitas lanzar este comando de forma demonizada:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>git daemon --reuseaddr --base-path=/opt/git/ /opt/git/</seg>
      </tuv>
      <tuv lang="ES">
        <seg>git daemon --reuseaddr --base-path=/opt/git/ /opt/git/</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>`--reuseaddr` allows the server to restart without waiting for old connections to time out, the `--base-path` option allows people to clone projects without specifying the entire path, and the path at the end tells the Git daemon where to look for repositories to export.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El parámetro '--reuseaddr' permite al servidor reiniciarse sin esperar a que se liberen viejas conexiones; el parámetro '--base-path' permite a los usuarios clonar proyectos sin necesidad de indicar su camino completo; y el camino indicado al final del comando mostrará al demonio Git dónde buscar los repositorios a exportar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you’re running a firewall, you’ll also need to punch a hole in it at port 9418 on the box you’re setting this up on.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si tienes un cortafuegos activo, necesitarás abrir el puerto 9418 para la máquina donde estás configurando el demónio Git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can daemonize this process a number of ways, depending on the operating system you’re running.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Este proceso se puede demonizar de diferentes maneras, dependiendo del sistema operativo con el que trabajas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>On an Ubuntu machine, you use an Upstart script.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En una máquina Ubuntu, puedes usar un script de arranque.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>So, in the following file</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Poniendo en el siguiente archivo: </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>/etc/event.d/local-git-daemon</seg>
      </tuv>
      <tuv lang="ES">
        <seg>/etc/event.d/local-git-daemon</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>you put this script:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>un script tal como: </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>start on startup
	stop on shutdown
	exec /usr/bin/git daemon \
	    --user=git --group=git \
	    --reuseaddr \
	    --base-path=/opt/git/ \
	    /opt/git/
	respawn</seg>
      </tuv>
      <tuv lang="ES">
        <seg>start on startup
	stop on shutdown
	exec /usr/bin/git daemon \
	    --user=git --group=git \
	    --reuseaddr \
	    --base-path=/opt/git/ \
	    /opt/git/
	respawn</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For security reasons, it is strongly encouraged to have this daemon run as a user with read-only permissions to the repositories – you can easily do this by creating a new user 'git-ro' and running the daemon as them.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por razones de seguridad, es recomendable lanzar este demonio con un usuario que tenga unicamente permisos de lectura en los repositorios --lo puedes hacer creando un nuevo usuario 'git-ro' y lanzando el demonio con él--.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For the sake of simplicity we’ll simply run it as the same 'git' user that Gitosis is running as.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para simplificar, en estos ejemplos vamos a lanzar el demonio Git bajo el mismo usuario 'git' con el que hemos lanzado Gitosis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When you restart your machine, your Git daemon will start automatically and respawn if it goes down.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tras reiniciar tu máquina, el demonio Git arrancará automáticamente y se reiniciará cuando se caiga.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To get it running without having to reboot, you can run this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para arrancarlo sin necesidad de reiniciar la máquina, puedes utilizar el comando:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>initctl start local-git-daemon</seg>
      </tuv>
      <tuv lang="ES">
        <seg>initctl start local-git-daemon</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>On other systems, you may want to use `xinetd`, a script in your `sysvinit` system, or something else — as long as you get that command daemonized and watched somehow.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En otros sistemas operativos, puedes utilizar 'xinetd', un script en el sistema 'sysvinit', o alguna otra manera --siempre y cuando demonizes el comando y puedas monitorizarlo--.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Next, you have to tell your Gitosis server which repositories to allow unauthenticated Git server-based access to.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>A continuación, has de indicar en tu servidor Gitosis a cuales de tus repositorios ha de permitir acceso sin autentificar por parte del servidor Git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you add a section for each repository, you can specify the ones from which you want your Git daemon to allow reading.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Añadiendo una sección por cada repositorio, puedes indicar a cuáles permitirá leer el demonio Git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you want to allow Git protocol access for your iphone project, you add this to the end of the `gitosis.conf` file:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por ejemplo, si quieres permitir acceso a tu 'proyecto iphone', puedes añadir lo siguiente al archivo 'gitosis.conf':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>[repo iphone_project]
	daemon = yes</seg>
      </tuv>
      <tuv lang="ES">
        <seg>[repo iphone_project]
	daemon = yes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When that is committed and pushed up, your running daemon should start serving requests for the project to anyone who has access to port 9418 on your server.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cuando confirmes (commit) y envies (push) estos cambios, el demonio que está en marcha en el servidor comenzará a responder a peticiones de cualquiera que solicite dicho proyecto a través del puerto 9418 de tu servidor.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you decide not to use Gitosis, but you want to set up a Git daemon, you’ll have to run this on each project you want the Git daemon to serve:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si decides no utilizar Gitosis, pero sigues queriendo utilizar un demonio Git, has de lanzar este comando en cada proyecto que desees servír vía el demonio Git:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ cd /path/to/project.git
	$ touch git-daemon-export-ok</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ cd /path/to/project.git
	$ touch git-daemon-export-ok</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The presence of that file tells Git that it’s OK to serve this project without authentication.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La presencia de este archivo, indica a Git que está permitido el servir este proyecto sin necesidad de autentificación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Gitosis can also control which projects GitWeb shows.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>También podemos controlar a través de Gitosis los proyectos a ser mostrados por GitWeb.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>First, you need to add something like the following to the `/etc/gitweb.conf` file:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Previamente, has de añadir algo como esto al archivo '/etc/gitweb.conf':</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$projects_list = &quot;/home/git/gitosis/projects.list&quot;;
	$projectroot = &quot;/home/git/repositories&quot;;
	$export_ok = &quot;git-daemon-export-ok&quot;;
	@git_base_url_list = ('git://gitserver');</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$projects_list = &quot;/home/git/gitosis/projects.list&quot;;
	$projectroot = &quot;/home/git/repositories&quot;;
	$export_ok = &quot;git-daemon-export-ok&quot;;
	@git_base_url_list = ('git://gitserver');</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can control which projects GitWeb lets users browse by adding or removing a `gitweb` setting in the Gitosis configuration file.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Los proyectos a ser mostrados por GitWeb se controlarán añadiendo o quitando parámetros 'gitweb' en el archivo de configuración de Gitosis.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For instance, if you want the iphone project to show up on GitWeb, you make the `repo` setting look like this:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por ejemplo, si quieres mostrar el proyecto iphone, has de poner algo así como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>[repo iphone_project]
	daemon = yes
	gitweb = yes</seg>
      </tuv>
      <tuv lang="ES">
        <seg>[repo iphone_project]
	daemon = yes
	gitweb = yes</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now, if you commit and push the project, GitWeb will automatically start showing your iphone project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>A partir de ese momento, cuando confirmes cambios (commit) y envies (push) el proyecto, GitWeb comenzará a mostrar tu proyecto iphone.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>## Hosted Git ##</seg>
      </tuv>
      <tuv lang="ES">
        <seg>## Git en un alojamiento externo ##</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you don’t want to go through all of the work involved in setting up your own Git server, you have several options for hosting your Git projects on an external dedicated hosting site.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si no quieres realizar todo el trabajo de preparar tu propio servidor Git, tienes varias opciones para alojar tus proyectos Git en una ubicación externa dedicada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Doing so offers a number of advantages: a hosting site is generally quick to set up and easy to start projects on, and no server maintenance or monitoring is involved.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esta forma de trabajar tiene varias ventajas: un alberge externo suele ser rápido de configurar y sencillo de iniciar proyectos en él; además de no ser necesario preocuparte de su mantenimiento ni de su monitorización.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Even if you set up and run your own server internally, you may still want to use a public hosting site for your open source code — it’s generally easier for the open source community to find and help you with.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Incluso en el caso de que tengas tu propio servidor interno, puede resultar interesante utilizar también un lugar público; para albergar tu código abierto --normalmente, ahí suele ser más sencillo de localizar por parte de la comunidad--</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>These days, you have a huge number of hosting options to choose from, each with different advantages and disadvantages.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Actualmente tienes un gran número de opciones del alojamiento, cada una con sus ventajas y desventajas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To see an up-to-date list, check out the GitHosting page on the main Git wiki:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para obtener una lista actualizada, puedes mirar en la página GitHosting del wiki principal de Git:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>http://git.or.cz/gitwiki/GitHosting</seg>
      </tuv>
      <tuv lang="ES">
        <seg>http://git.or.cz/gitwiki/GitHosting</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Because we can’t cover all of them, and because I happen to work at one of them, we’ll use this section to walk through setting up an account and creating a new project at GitHub.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Por ser imposible el cubrir todos ellos, y porque da la casualidad de que trabajo en uno de ellos, concretamente, en esta sección veremos cómo crear una cuenta y nuevos proyectos albergados en 'GitHub'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This will give you an idea of what is involved.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Así podrás hacerte una idea de cómo suelen funcionar estos alberges externos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>GitHub is by far the largest open source Git hosting site and it’s also one of the very few that offers both public and private hosting options so you can keep your open source and private commercial code in the same place.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>GitHub es, de lejos, el mayor sitio de alberge público de proyectos Git de código abierto. Y es también uno de los pocos que ofrece asimismo opciones de alberge privado; de tal forma que puedes tener tanto tus proyectos de código abierto y como los de código comercial cerrado en un mismo emplazamiento.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In fact, we used GitHub to privately collaborate on this book.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>De hecho, nosotros utilizamos también GitHub para colaborar privadamente en este libro.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### GitHub ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### GitHub ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>GitHub is slightly different than most code-hosting sites in the way that it namespaces projects.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>GitHub es ligeramente distinto a otros sitios de alberge, en tanto en cuanto que contempla espacios de nombres para los proyectos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Instead of being primarily based on the project, GitHub is user centric.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En lugar de estar focalizado en los proyectos, GitHub gira en torno a los usuarios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>That means when I host my `grit` project on GitHub, you won’t find it at `github.com/grit` but instead at `github.com/schacon/grit`.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto significa que, cuando alojo mi proyecto 'grit' en GitHub, no lo encontraras bajo 'github.com/grit', sino bajo 'github.com/schacon/grit'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>There is no canonical version of any project, which allows a project to move from one user to another seamlessly if the first author abandons the project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>No existe una versión canónica de ningún proyecto, lo que permite a cualquiera de ellos ser movido facilmente de un usuario a otro en el caso de que el primer autor lo abandone.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>GitHub is also a commercial company that charges for accounts that maintain private repositories, but anyone can quickly get a free account to host as many open source projects as they want.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>GitHub es también una compañia comercial, que cobra por las cuentas que tienen repositorios privados. Pero, para albergar proyectos públicos de código abierto, cualquiera puede crear una cuenta gratuita.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>We’ll quickly go over how that is done.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Vamos a ver cómo hacerlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Setting Up a User Account ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Configurando una cuenta de usuario ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The first thing you need to do is set up a free user account.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El primer paso es dar de alta una cuenta gratuita.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you visit the Pricing and Signup page at `http://github.com/plans` and click the &quot;Sign Up&quot; button on the Free account (see figure 4-2), you’re taken to the signup page.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si visitas la página de Precios e Inicio de Sesión, en 'http://github.com/plans', y clicas sobre el botón &quot;Registro&quot; (&quot;Sign Up&quot;) de las cuentas gratuitas, verás una página de registro:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0402.png
Figure 4-2.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0402.png
Figura 4-2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The GitHub plan page.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La página de planes GitHub.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Here you must choose a username that isn’t yet taken in the system and enter an e-mail address that will be associated with the account and a password (see Figure 4-3).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En ella, has de elegir un nombre de usuario que esté libre, indicar una cuenta de correo electrónico y poner una contraseña.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0403.png 
Figure 4-3.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0403.png 
Figura 4-3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The GitHub user signup form.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El formulario de registro en GitHub.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you have it available, this is a good time to add your public SSH key as well.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si la tuvieras, es también un buen momento para añadir tu clave pública SSH.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>We covered how to generate a new key earlier, in the &quot;Simple Setups&quot; section.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Veremos cómo generar una de estas claves, más adelante, en la sección &quot;Ajustes Simples&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Take the contents of the public key of that pair, and paste it into the SSH Public Key text box.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Pero, si ya tienes un par de claves SSH, puedes coger el contenido correspondiente a la clave pública y pegarlo en la caja de texto preparada para tal fin.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Clicking the &quot;explain ssh keys&quot; link takes you to detailed instructions on how to do so on all major operating systems.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El enlace &quot;explicar claves ssh&quot; (&quot;explain ssh keys&quot;) te llevará a unas detalladas instrucciones de cómo generarlas en la mayor parte de los principales sistemas operativos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Clicking the &quot;I agree, sign me up&quot; button takes you to your new user dashboard (see Figure 4-4).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Clicando sobre el botón de &quot;Estoy de acuerdo, registramé&quot; (&quot;I agree, sign me up&quot;), irás al panel de control de tu recién creado usuario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0404.png 
Figure 4-4.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0404.png 
Figura 4-4.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The GitHub user dashboard.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El panel de control del usuario GitHub.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Next you can create a new repository.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>A continuación, puedes crear nuevos repositorios.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Creating a New Repository ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Creando un nuevo repositorio ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Start by clicking the &quot;create a new one&quot; link next to Your Repositories on the user dashboard.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes empezar clicando sobre el enlace &quot;crear uno nuevo&quot; (&quot;create a new one&quot;), en la zona 'Tus repositorios' ('Your Repositories') del panel de control.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You’re taken to the Create a New Repository form (see Figure 4-5).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Irás al formulario de Crear un Nuevo Repositorio (ver Figura 4-5).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0405.png 
Figure 4-5.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0405.png 
Figura 4-5.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Creating a new repository on GitHub.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Creando un nuevo repositorio en GitHub.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>All you really have to do is provide a project name, but you can also add a description.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Es suficiente con dar un nombre al proyecto, pero también puedes añadirle una descripción.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When that is done, click the &quot;Create Repository&quot; button.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cuando lo hayas escrito, clica sobre el botón &quot;Crear Repositorio&quot; (&quot;Create Repository&quot;).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now you have a new repository on GitHub (see Figure 4-6).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y ya tienes un nuevo repositorio en GitHub (ver Figura 4-6)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0406.png 
Figure 4-6.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0406.png 
Figura 4-6.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>GitHub project header information.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Información de cabecera de un proyecto GitHub.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Since you have no code there yet, GitHub will show you instructions for how create a brand-new project, push an existing Git project up, or import a project from a public Subversion repository (see Figure 4-7).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Como aún no tienes código, GitHub mostrará instrucciones sobre cómo iniciar un nuevo proyecto, cómo enviar (push) un proyecto Git preexistente, o cómo importar un proyecto desde un repositorio público Subversion (ver Figura 4-7).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0407.png 
Figure 4-7.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0407.png 
Figura 4-7.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Instructions for a new repository.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Instrucciones para un nuevo repositorio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>These instructions are similar to what we’ve already gone over.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Estas instrucciones son similares a las que ya hemos visto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To initialize a project if it isn’t already a Git project, you use</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para inicializar un proyecto, no siendo aún un proyecto Git, sueles utilizar:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git init
	$ git add .</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git init
	$ git add .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git commit -m 'initial commit'</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git commit -m 'initial commit'</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When you have a Git repository locally, add GitHub as a remote and push up your master branch:</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Una vez tengas un repositorio local Git, añadele el sitio GitHub como un remoto y envia (push) allí tu rama principal:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>$ git remote add origin git@github.com:testinguser/iphone_project.git
	$ git push origin master</seg>
      </tuv>
      <tuv lang="ES">
        <seg>$ git remote add origin git@github.com:testinguser/iphone_project.git
	$ git push origin master</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Now your project is hosted on GitHub, and you can give the URL to anyone you want to share your project with.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Así, tu proyecto estará alojado en GitHub; y podrás dar su URL a cualquiera con quien desees compartirlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In this case, it’s `http://github.com/testinguser/iphone_project`.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En este ejemplo, la URL es `http://github.com/testinguser/iphone_project`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can also see from the header on each of your project’s pages that you have two Git URLs (see Figure 4-8).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En la página de cabecera de cada uno de tus proyectos, podrás ver dos URLs (ver Figura 4-8).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0408.png 
Figure 4-8.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0408.png 
Figura 4-8.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Project header with a public URL and a private URL.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cabecera de proyecto, con una URL pública y otra URL privada.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The Public Clone URL is a public, read-only Git URL over which anyone can clone the project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El enlace &quot;Public Clone URL&quot;, es un enlace público, de solo lectura; a través del cual cualquiera puede clonar el proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Feel free to give out that URL and post it on your web site or what have you.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes comunicar libremente ese URL o puedes publicarlo en tu sitio web o en cualquier otro médio que desees.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The Your Clone URL is a read/write SSH-based URL that you can read or write over only if you connect with the SSH private key associated with the public key you uploaded for your user.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El enlace &quot;Your Clone URL&quot;, es un enlace de lectura/escritura basado en SSH; a través del cual puedes leer y escribir, pero solo si te conectas con la clave SSH privada correspondiente a la clave pública que has cargado para tu usuario.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When other users visit this project page, they won’t see that URL—only the public one.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cuando otros usuarios visiten la página del proyecto, no verán esta segunda URL --solo verán la URL pública--.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Importing from Subversion ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Importación desde Subversion ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you have an existing public Subversion project that you want to import into Git, GitHub can often do that for you.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si tienes un proyecto público Subversion que deseas pasar a Git, GitHub suele poder realizar la importación.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>At the bottom of the instructions page is a link to a Subversion import.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>All fondo de la página de instrucciones, tienes un enlace &quot;Subversion import&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you click it, you see a form with information about the import process and a text box where you can paste in the URL of your public Subversion project (see Figure 4-9).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si clicas sobre dicho enlace, verás un formulario con información sobre el proceso de importación y un cuadro de texto donde puedes pegar la URL de tu proyecto Subversion (ver Figura 4-9).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0409.png 
Figure 4-9.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0409.png 
Figura 4-9.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Subversion importing interface.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>El interface de importación desde Subversion.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If your project is very large, nonstandard, or private, this process probably won’t work for you.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si tu proyecto es muy grande, no-estandar o privado, es muy posible que no se pueda importar.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>In Chapter 7, you’ll learn how to do more complicated manual project imports.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En el capítulo 7, aprenderás cómo realizar importaciones manuales de proyectos complejos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Adding Collaborators ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Añadiendo colaboradores ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Let’s add the rest of the team.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Vamos a añadir al resto del equipo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If John, Josie, and Jessica all sign up for accounts on GitHub, and you want to give them push access to your repository, you can add them to your project as collaborators.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si tanto John, como Josie, como Jessica, todos ellos registran sus respectivas cuentas en GitHub. Y deseas darles acceso de escritura a tu repositorio. Puedes incluirlos en tu proyecto como colaboradores.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Doing so will allow pushes from their public keys to work.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>De esta forma, funcionarán los envios (push) desde sus respectivas claves públicas.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Click the &quot;edit&quot; button in the project header or the Admin tab at the top of the project to reach the Admin page of your GitHub project (see Figure 4-10).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Has de hacer clic sobre el botón &quot;edit&quot; en la cabecera del proyecto o en la pestaña Admin de la parte superior del proyecto; yendo así a la página de administración del proyecto GitHub.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0410.png 
Figure 4-10.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0410.png 
Figura 4-10.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>GitHub administration page.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Página de administración GitHub.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To give another user write access to your project, click the “Add another collaborator” link.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para dar acceso de escritura a otro usuario, clica sobre el enlace &quot;Add another collaborator&quot;.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>A new text box appears, into which you can type a username.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Aparecerá un cuadro de texto, donde podrás teclear un nombre.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>As you type, a helper pops up, showing you possible username matches.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Según  tecleas, aparecerá un cuadro de ayuda, mostrando posibles nombres de usuario que encajen con lo tecleado.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When you find the correct user, click the Add button to add that user as a collaborator on your project (see Figure 4-11).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cuando localices al usuario deseado, clica sobre el botón &quot;Add&quot; para añadirlo como colaborador en tu proyecto (ver Figura 4-11).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0411.png 
Figure 4-11.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0411.png 
Figura 4-11.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Adding a collaborator to your project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Añadirendo un colaborador a tu proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When you’re finished adding collaborators, you should see a list of them in the Repository Collaborators box (see Figure 4-12).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cuando termines de añadir colaboradores, podrás ver a todos ellos en la lista &quot;Repository Collaborators&quot; (ver Figura 4-12).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0412.png 
Figure 4-12.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0412.png 
Figura 4-12.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>A list of collaborators on your project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Lista de colaboradores en tu proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you need to revoke access to individuals, you can click the &quot;revoke&quot; link, and their push access will be removed.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si deseas revocar el acceso a alguno de ellos, puedes clicar sobre el enlace &quot;revoke&quot;, y sus permisos de envio (push) serán revocados.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>For future projects, you can also copy collaborator groups by copying the permissions of an existing project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>En proyectos futuros, podras incluir también a tu grupo de colaboradores copiando los permisos desde otro proyecto ya existente.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Your Project ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Tu proyecto ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>After you push your project up or have it imported from Subversion, you have a main project page that looks something like Figure 4-13.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Una vez hayas enviado (push) tu proyecto, o lo hayas importado desde Subversion, tendrás una página principal de proyecto tal como:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0413.png 
Figure 4-13.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0413.png 
Figura 4-13.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>A GitHub main project page.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Una página principal de proyecto GitHub.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When people visit your project, they see this page.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cuando la gente visite tu proyecto, verá esta página.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It contains tabs to different aspects of your projects.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tiene pestañas que llevan a distintos aspectos del proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The Commits tab shows a list of commits in reverse chronological order, similar to the output of the `git log` command.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La pestaña &quot;Commits&quot; muestra una lista de confirmaciones de cambio, en orden cronológico inverso, de forma similar a la salida del comando 'git log'.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The Network tab shows all the people who have forked your project and contributed back.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La pestaña &quot;Network&quot; muestra una lista de toda la gente que ha bifurcado (forked) tu proyecto y ha contribuido a él.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The Downloads tab allows you to upload project binaries and link to tarballs and zipped versions of any tagged points in your project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La pestaña &quot;Downloads&quot; permite cargar binarios del proyecto y enlaza con tarballs o versiones comprimidas de cualquier punto marcado (tagged) en tu proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The Wiki tab provides a wiki where you can write documentation or other information about your project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La pestaña &quot;Wiki&quot; enlaza con un espacio wiki donde puedes escribir documentación o cualquier otra información relevante sobre tu proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The Graphs tab has some contribution visualizations and statistics about your project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La pestaña &quot;Graphs&quot; muestra diversas visualizaciones sobre contribuciones y estadísticas de tu proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>The main Source tab that you land on shows your project’s main directory listing and automatically renders the README file below it if you have one.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La pestaña principal &quot;Source&quot; en la que aterrizas cuando llegas al proyecto, muestra un listado de la carpeta principal; y muestra también el contenido del archivo README, si tienes uno en ella.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This tab also shows a box with the latest commit information.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esta pestaña muestra también un cuadro con información sobre la última confirmación de cambio (commit) realizada en el proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### Forking Projects ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Bifurcando proyectos ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you want to contribute to an existing project to which you don’t have push access, GitHub encourages forking the project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si deseas contribuir a un proyecto ya existente, en el que no tengas permisos de envio (push). GitHub recomienda bifurcar el proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>When you land on a project page that looks interesting and you want to hack on it a bit, you can click the &quot;fork&quot; button in the project header to have GitHub copy that project to your user so you can push to it.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Cuando aterrizas en la página de un proyecto que te parece interesante y con el que deseas trastear un poco, puedes clicar sobre el botón &quot;fork&quot; de la cabecera del proyecto; de tal forma que GitHub haga una copia del proyecto a tu cuenta de usuario y puedas así enviar (push) cambios sobre él.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>This way, projects don’t have to worry about adding users as collaborators to give them push access.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>De esta forma, los proyectos no han de preocuparse de añadir usuarios como colaboradores para darles acceso de envio (push).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>People can fork a project and push to it, and the main project maintainer can pull in those changes by adding them as remotes and merging in their work.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>La gente puede bifurcar (fork) un proyecto y enviar (push) sobre su propia copia. El gestor del proyecto principal, puede recuperar (pull) esos cambios añadiendo las copias como remotos y fusionando (merge) el trabajo en ellas contenido.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>To fork a project, visit the project page (in this case, mojombo/chronic) and click the &quot;fork&quot; button in the header (see Figure 4-14).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Para bifurcar un proyecto, visita su página (en el ejemplo, mojombo/chronic) y clica sobre el botón &quot;fork&quot; de su cabecera (ver Figura 4-14) </seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0414.png 
Figure 4-14.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0414.png 
Figura 4-14.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Get a writable copy of any repository by clicking the &quot;fork&quot; button.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Obtener una copia sobre la que escribir, clicando sobre el botón &quot;fork&quot; de un repositorio.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>After a few seconds, you’re taken to your new project page, which indicates that this project is a fork of another one (see Figure 4-15).</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tras unos segundos, serás redirigido a la página del nuevo proyecto; y en ella se verá que este proyecto es una bifuración (fork) de otro existente (ver Figura 4-15).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Insert 18333fig0415.png 
Figure 4-15.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Insert 18333fig0415.png 
Figura 4-15.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Your fork of a project.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tu bifurcación (fork) de un proyecto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>### GitHub Summary ###</seg>
      </tuv>
      <tuv lang="ES">
        <seg>### Resumen de GitHub ###</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>That’s all we’ll cover about GitHub, but it’s important to note how quickly you can do all this.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Esto es todo lo que vamos a ver aquí sobre GitHub, pero merece la pena destacar lo rápido que puedes hacer todo esto.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You can create an account, add a new project, and push to it in a matter of minutes.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Puedes crear una cuenta, añadir un nuevo proyecto y contribuir a él en cuestión de minutos.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If your project is open source, you also get a huge community of developers who now have visibility into your project and may well fork it and help contribute to it.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si tu proyecto es de código abierto, puedes tener también una amplia comunidad de desarrolladores que podrán ver tu proyecto, bifurcarlo (fork) y ayudar contribuyendo a él.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>At the very least, this may be a way to get up and running with Git and try it out quickly.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Y, por último, comentar que esta puede ser una buena manera de iniciarte y comenzar rápidamente a trabajar con Git.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>You have several options to get a remote Git repository up and running so that you can collaborate with others or share your work.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Tienes varias maneras de preparar un repositorio remoto Git, de colaborar con otras personas o de compartir tu trabajo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>Running your own server gives you a lot of control and allows you to run the server within your own firewall, but such a server generally requires a fair amount of your time to set up and maintain.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Disponer de tu propio servidor te da pleno control sobre él y te permite trabajar dentro de tu propio cortafuegos. Pero un servidor así suele requerir bastante de tu tiempo para prepararlo y mantenerlo.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>If you place your data on a hosted server, it’s easy to set up and maintain; however, you have to be able to keep your code on someone else’s servers, and some organizations don’t allow that.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>Si ubicas tus datos en un servidor albergado, será sencillo configurarlo y mantenerlo. Pero tienes que estar dispuesto a mantener tu código en servidores de terceros, cosa que no suele estar permitido en algunas organizaciones.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="EN">
        <seg>It should be fairly straightforward to determine which solution or combination of solutions is appropriate for you and your organization.</seg>
      </tuv>
      <tuv lang="ES">
        <seg>No te será dificil el determinar cual de estas soluciones o combinación de soluciones es apropiada para tí y para tu organización.</seg>
      </tuv>
    </tu>
  </body>
</tmx>
